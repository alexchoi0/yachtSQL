-- Cte - SQL:2023
-- Description: Common Table Expressions (WITH clause) for query organization
--
-- PostgreSQL: Full support
-- BigQuery: Full support
-- SQL Standard: SQL:2023

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (2), (4), (1), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('A', 2), ('B', 3), ('B', 4), ('B', 5);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (2), (3), (3), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_001
SELECT ARRAY[1, 2, 3, 4, 5] as numbers;
-- Tag: cte_cte_test_select_002
SELECT ARRAY['apple', 'banana', 'cherry'] as fruits;
-- Tag: cte_cte_test_select_003
SELECT ARRAY[] as empty;
-- Tag: cte_cte_test_select_004
SELECT ARRAY[1, NULL, 3, NULL, 5] as mixed;
-- Tag: cte_cte_test_select_005
SELECT ARRAY[ARRAY[1, 2], ARRAY[3, 4]] as nested;
-- Tag: cte_cte_test_select_006
SELECT ARRAY[1, 'two', 3.0] as invalid;
-- Tag: cte_cte_test_select_007
SELECT ARRAY_LENGTH(ARRAY[1, 2, 3, 4, 5]) as len;
-- Tag: cte_cte_test_select_008
SELECT ARRAY_LENGTH(ARRAY[]) as len;
-- Tag: cte_cte_test_select_009
SELECT ARRAY_LENGTH(NULL) as len;
-- Tag: cte_cte_test_select_010
SELECT ARRAY_LENGTH(ARRAY[1, NULL, 3]) as len;
-- Tag: cte_cte_test_select_011
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_012
SELECT ARRAY_AGG(value ORDER BY value) as arr FROM data;
-- Tag: cte_cte_test_select_013
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_014
SELECT ARRAY_AGG(value IGNORE NULLS) as arr FROM data;
-- Tag: cte_cte_test_select_015
SELECT category, ARRAY_AGG(value) as arr FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_016
SELECT ARRAY_AGG(value) as arr FROM empty;
-- Tag: cte_cte_test_select_017
SELECT ARRAY_AGG(DISTINCT value) as arr FROM data;
-- Tag: cte_cte_test_select_018
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_019
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_020
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_021
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_022
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_023
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_024
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_025
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_026
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_027
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_028
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_029
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_030
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_031
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_032
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_033
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_034
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_035
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_036
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_037
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_038
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_039
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_040
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_041
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_042
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_043
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_044
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_045
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_046
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_047
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_048
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_049
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_050
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_051
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_052
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_053
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (2), (4), (1), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('A', 2), ('B', 3), ('B', 4), ('B', 5);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (2), (3), (3), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_054
SELECT ARRAY['apple', 'banana', 'cherry'] as fruits;
-- Tag: cte_cte_test_select_055
SELECT ARRAY[] as empty;
-- Tag: cte_cte_test_select_056
SELECT ARRAY[1, NULL, 3, NULL, 5] as mixed;
-- Tag: cte_cte_test_select_057
SELECT ARRAY[ARRAY[1, 2], ARRAY[3, 4]] as nested;
-- Tag: cte_cte_test_select_058
SELECT ARRAY[1, 'two', 3.0] as invalid;
-- Tag: cte_cte_test_select_059
SELECT ARRAY_LENGTH(ARRAY[1, 2, 3, 4, 5]) as len;
-- Tag: cte_cte_test_select_060
SELECT ARRAY_LENGTH(ARRAY[]) as len;
-- Tag: cte_cte_test_select_061
SELECT ARRAY_LENGTH(NULL) as len;
-- Tag: cte_cte_test_select_062
SELECT ARRAY_LENGTH(ARRAY[1, NULL, 3]) as len;
-- Tag: cte_cte_test_select_063
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_064
SELECT ARRAY_AGG(value ORDER BY value) as arr FROM data;
-- Tag: cte_cte_test_select_065
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_066
SELECT ARRAY_AGG(value IGNORE NULLS) as arr FROM data;
-- Tag: cte_cte_test_select_067
SELECT category, ARRAY_AGG(value) as arr FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_068
SELECT ARRAY_AGG(value) as arr FROM empty;
-- Tag: cte_cte_test_select_069
SELECT ARRAY_AGG(DISTINCT value) as arr FROM data;
-- Tag: cte_cte_test_select_070
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_071
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_072
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_073
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_074
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_075
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_076
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_077
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_078
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_079
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_080
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_081
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_082
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_083
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_084
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_085
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_086
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_087
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_088
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_089
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_090
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_091
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_092
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_093
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_094
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_095
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_096
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_097
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_098
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_099
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_100
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_101
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_102
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_103
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_104
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_105
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (2), (4), (1), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('A', 2), ('B', 3), ('B', 4), ('B', 5);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (2), (3), (3), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_106
SELECT ARRAY[] as empty;
-- Tag: cte_cte_test_select_107
SELECT ARRAY[1, NULL, 3, NULL, 5] as mixed;
-- Tag: cte_cte_test_select_108
SELECT ARRAY[ARRAY[1, 2], ARRAY[3, 4]] as nested;
-- Tag: cte_cte_test_select_109
SELECT ARRAY[1, 'two', 3.0] as invalid;
-- Tag: cte_cte_test_select_110
SELECT ARRAY_LENGTH(ARRAY[1, 2, 3, 4, 5]) as len;
-- Tag: cte_cte_test_select_111
SELECT ARRAY_LENGTH(ARRAY[]) as len;
-- Tag: cte_cte_test_select_112
SELECT ARRAY_LENGTH(NULL) as len;
-- Tag: cte_cte_test_select_113
SELECT ARRAY_LENGTH(ARRAY[1, NULL, 3]) as len;
-- Tag: cte_cte_test_select_114
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_115
SELECT ARRAY_AGG(value ORDER BY value) as arr FROM data;
-- Tag: cte_cte_test_select_116
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_117
SELECT ARRAY_AGG(value IGNORE NULLS) as arr FROM data;
-- Tag: cte_cte_test_select_118
SELECT category, ARRAY_AGG(value) as arr FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_119
SELECT ARRAY_AGG(value) as arr FROM empty;
-- Tag: cte_cte_test_select_120
SELECT ARRAY_AGG(DISTINCT value) as arr FROM data;
-- Tag: cte_cte_test_select_121
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_122
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_123
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_124
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_125
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_126
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_127
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_128
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_129
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_130
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_131
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_132
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_133
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_134
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_135
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_136
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_137
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_138
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_139
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_140
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_141
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_142
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_143
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_144
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_145
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_146
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_147
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_148
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_149
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_150
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_151
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_152
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_153
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_154
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_155
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_156
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (2), (4), (1), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('A', 2), ('B', 3), ('B', 4), ('B', 5);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (2), (3), (3), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_157
SELECT ARRAY[1, NULL, 3, NULL, 5] as mixed;
-- Tag: cte_cte_test_select_158
SELECT ARRAY[ARRAY[1, 2], ARRAY[3, 4]] as nested;
-- Tag: cte_cte_test_select_159
SELECT ARRAY[1, 'two', 3.0] as invalid;
-- Tag: cte_cte_test_select_160
SELECT ARRAY_LENGTH(ARRAY[1, 2, 3, 4, 5]) as len;
-- Tag: cte_cte_test_select_161
SELECT ARRAY_LENGTH(ARRAY[]) as len;
-- Tag: cte_cte_test_select_162
SELECT ARRAY_LENGTH(NULL) as len;
-- Tag: cte_cte_test_select_163
SELECT ARRAY_LENGTH(ARRAY[1, NULL, 3]) as len;
-- Tag: cte_cte_test_select_164
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_165
SELECT ARRAY_AGG(value ORDER BY value) as arr FROM data;
-- Tag: cte_cte_test_select_166
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_167
SELECT ARRAY_AGG(value IGNORE NULLS) as arr FROM data;
-- Tag: cte_cte_test_select_168
SELECT category, ARRAY_AGG(value) as arr FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_169
SELECT ARRAY_AGG(value) as arr FROM empty;
-- Tag: cte_cte_test_select_170
SELECT ARRAY_AGG(DISTINCT value) as arr FROM data;
-- Tag: cte_cte_test_select_171
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_172
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_173
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_174
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_175
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_176
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_177
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_178
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_179
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_180
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_181
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_182
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_183
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_184
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_185
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_186
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_187
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_188
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_189
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_190
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_191
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_192
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_193
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_194
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_195
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_196
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_197
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_198
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_199
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_200
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_201
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_202
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_203
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_204
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_205
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_206
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (2), (4), (1), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('A', 2), ('B', 3), ('B', 4), ('B', 5);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (2), (3), (3), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_207
SELECT ARRAY[ARRAY[1, 2], ARRAY[3, 4]] as nested;
-- Tag: cte_cte_test_select_208
SELECT ARRAY[1, 'two', 3.0] as invalid;
-- Tag: cte_cte_test_select_209
SELECT ARRAY_LENGTH(ARRAY[1, 2, 3, 4, 5]) as len;
-- Tag: cte_cte_test_select_210
SELECT ARRAY_LENGTH(ARRAY[]) as len;
-- Tag: cte_cte_test_select_211
SELECT ARRAY_LENGTH(NULL) as len;
-- Tag: cte_cte_test_select_212
SELECT ARRAY_LENGTH(ARRAY[1, NULL, 3]) as len;
-- Tag: cte_cte_test_select_213
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_214
SELECT ARRAY_AGG(value ORDER BY value) as arr FROM data;
-- Tag: cte_cte_test_select_215
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_216
SELECT ARRAY_AGG(value IGNORE NULLS) as arr FROM data;
-- Tag: cte_cte_test_select_217
SELECT category, ARRAY_AGG(value) as arr FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_218
SELECT ARRAY_AGG(value) as arr FROM empty;
-- Tag: cte_cte_test_select_219
SELECT ARRAY_AGG(DISTINCT value) as arr FROM data;
-- Tag: cte_cte_test_select_220
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_221
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_222
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_223
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_224
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_225
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_226
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_227
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_228
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_229
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_230
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_231
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_232
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_233
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_234
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_235
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_236
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_237
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_238
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_239
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_240
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_241
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_242
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_243
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_244
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_245
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_246
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_247
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_248
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_249
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_250
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_251
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_252
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_253
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_254
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_255
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (2), (4), (1), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('A', 2), ('B', 3), ('B', 4), ('B', 5);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (2), (3), (3), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_256
SELECT ARRAY[1, 'two', 3.0] as invalid;
-- Tag: cte_cte_test_select_257
SELECT ARRAY_LENGTH(ARRAY[1, 2, 3, 4, 5]) as len;
-- Tag: cte_cte_test_select_258
SELECT ARRAY_LENGTH(ARRAY[]) as len;
-- Tag: cte_cte_test_select_259
SELECT ARRAY_LENGTH(NULL) as len;
-- Tag: cte_cte_test_select_260
SELECT ARRAY_LENGTH(ARRAY[1, NULL, 3]) as len;
-- Tag: cte_cte_test_select_261
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_262
SELECT ARRAY_AGG(value ORDER BY value) as arr FROM data;
-- Tag: cte_cte_test_select_263
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_264
SELECT ARRAY_AGG(value IGNORE NULLS) as arr FROM data;
-- Tag: cte_cte_test_select_265
SELECT category, ARRAY_AGG(value) as arr FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_266
SELECT ARRAY_AGG(value) as arr FROM empty;
-- Tag: cte_cte_test_select_267
SELECT ARRAY_AGG(DISTINCT value) as arr FROM data;
-- Tag: cte_cte_test_select_268
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_269
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_270
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_271
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_272
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_273
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_274
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_275
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_276
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_277
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_278
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_279
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_280
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_281
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_282
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_283
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_284
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_285
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_286
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_287
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_288
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_289
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_290
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_291
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_292
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_293
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_294
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_295
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_296
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_297
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_298
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_299
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_300
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_301
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_302
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_303
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (2), (4), (1), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('A', 2), ('B', 3), ('B', 4), ('B', 5);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (2), (3), (3), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_304
SELECT ARRAY_LENGTH(ARRAY[1, 2, 3, 4, 5]) as len;
-- Tag: cte_cte_test_select_305
SELECT ARRAY_LENGTH(ARRAY[]) as len;
-- Tag: cte_cte_test_select_306
SELECT ARRAY_LENGTH(NULL) as len;
-- Tag: cte_cte_test_select_307
SELECT ARRAY_LENGTH(ARRAY[1, NULL, 3]) as len;
-- Tag: cte_cte_test_select_308
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_309
SELECT ARRAY_AGG(value ORDER BY value) as arr FROM data;
-- Tag: cte_cte_test_select_310
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_311
SELECT ARRAY_AGG(value IGNORE NULLS) as arr FROM data;
-- Tag: cte_cte_test_select_312
SELECT category, ARRAY_AGG(value) as arr FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_313
SELECT ARRAY_AGG(value) as arr FROM empty;
-- Tag: cte_cte_test_select_314
SELECT ARRAY_AGG(DISTINCT value) as arr FROM data;
-- Tag: cte_cte_test_select_315
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_316
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_317
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_318
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_319
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_320
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_321
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_322
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_323
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_324
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_325
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_326
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_327
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_328
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_329
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_330
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_331
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_332
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_333
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_334
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_335
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_336
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_337
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_338
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_339
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_340
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_341
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_342
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_343
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_344
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_345
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_346
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_347
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_348
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_349
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_350
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (2), (4), (1), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('A', 2), ('B', 3), ('B', 4), ('B', 5);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (2), (3), (3), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_351
SELECT ARRAY_LENGTH(ARRAY[]) as len;
-- Tag: cte_cte_test_select_352
SELECT ARRAY_LENGTH(NULL) as len;
-- Tag: cte_cte_test_select_353
SELECT ARRAY_LENGTH(ARRAY[1, NULL, 3]) as len;
-- Tag: cte_cte_test_select_354
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_355
SELECT ARRAY_AGG(value ORDER BY value) as arr FROM data;
-- Tag: cte_cte_test_select_356
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_357
SELECT ARRAY_AGG(value IGNORE NULLS) as arr FROM data;
-- Tag: cte_cte_test_select_358
SELECT category, ARRAY_AGG(value) as arr FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_359
SELECT ARRAY_AGG(value) as arr FROM empty;
-- Tag: cte_cte_test_select_360
SELECT ARRAY_AGG(DISTINCT value) as arr FROM data;
-- Tag: cte_cte_test_select_361
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_362
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_363
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_364
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_365
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_366
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_367
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_368
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_369
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_370
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_371
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_372
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_373
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_374
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_375
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_376
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_377
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_378
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_379
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_380
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_381
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_382
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_383
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_384
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_385
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_386
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_387
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_388
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_389
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_390
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_391
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_392
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_393
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_394
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_395
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_396
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (2), (4), (1), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('A', 2), ('B', 3), ('B', 4), ('B', 5);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (2), (3), (3), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_397
SELECT ARRAY_LENGTH(NULL) as len;
-- Tag: cte_cte_test_select_398
SELECT ARRAY_LENGTH(ARRAY[1, NULL, 3]) as len;
-- Tag: cte_cte_test_select_399
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_400
SELECT ARRAY_AGG(value ORDER BY value) as arr FROM data;
-- Tag: cte_cte_test_select_401
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_402
SELECT ARRAY_AGG(value IGNORE NULLS) as arr FROM data;
-- Tag: cte_cte_test_select_403
SELECT category, ARRAY_AGG(value) as arr FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_404
SELECT ARRAY_AGG(value) as arr FROM empty;
-- Tag: cte_cte_test_select_405
SELECT ARRAY_AGG(DISTINCT value) as arr FROM data;
-- Tag: cte_cte_test_select_406
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_407
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_408
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_409
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_410
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_411
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_412
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_413
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_414
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_415
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_416
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_417
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_418
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_419
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_420
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_421
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_422
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_423
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_424
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_425
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_426
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_427
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_428
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_429
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_430
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_431
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_432
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_433
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_434
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_435
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_436
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_437
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_438
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_439
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_440
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_441
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (2), (4), (1), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('A', 2), ('B', 3), ('B', 4), ('B', 5);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (2), (3), (3), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_442
SELECT ARRAY_LENGTH(ARRAY[1, NULL, 3]) as len;
-- Tag: cte_cte_test_select_443
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_444
SELECT ARRAY_AGG(value ORDER BY value) as arr FROM data;
-- Tag: cte_cte_test_select_445
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_446
SELECT ARRAY_AGG(value IGNORE NULLS) as arr FROM data;
-- Tag: cte_cte_test_select_447
SELECT category, ARRAY_AGG(value) as arr FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_448
SELECT ARRAY_AGG(value) as arr FROM empty;
-- Tag: cte_cte_test_select_449
SELECT ARRAY_AGG(DISTINCT value) as arr FROM data;
-- Tag: cte_cte_test_select_450
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_451
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_452
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_453
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_454
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_455
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_456
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_457
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_458
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_459
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_460
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_461
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_462
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_463
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_464
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_465
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_466
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_467
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_468
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_469
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_470
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_471
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_472
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_473
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_474
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_475
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_476
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_477
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_478
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_479
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_480
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_481
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_482
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_483
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_484
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_485
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (2), (4), (1), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('A', 2), ('B', 3), ('B', 4), ('B', 5);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (2), (3), (3), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_486
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_487
SELECT ARRAY_AGG(value ORDER BY value) as arr FROM data;
-- Tag: cte_cte_test_select_488
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_489
SELECT ARRAY_AGG(value IGNORE NULLS) as arr FROM data;
-- Tag: cte_cte_test_select_490
SELECT category, ARRAY_AGG(value) as arr FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_491
SELECT ARRAY_AGG(value) as arr FROM empty;
-- Tag: cte_cte_test_select_492
SELECT ARRAY_AGG(DISTINCT value) as arr FROM data;
-- Tag: cte_cte_test_select_493
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_494
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_495
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_496
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_497
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_498
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_499
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_500
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_501
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_502
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_503
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_504
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_505
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_506
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_507
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_508
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_509
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_510
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_511
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_512
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_513
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_514
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_515
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_516
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_517
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_518
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_519
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_520
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_521
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_522
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_523
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_524
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_525
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_526
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_527
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_528
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (2), (4), (1), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('A', 2), ('B', 3), ('B', 4), ('B', 5);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (2), (3), (3), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_529
SELECT ARRAY_AGG(value ORDER BY value) as arr FROM data;
-- Tag: cte_cte_test_select_530
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_531
SELECT ARRAY_AGG(value IGNORE NULLS) as arr FROM data;
-- Tag: cte_cte_test_select_532
SELECT category, ARRAY_AGG(value) as arr FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_533
SELECT ARRAY_AGG(value) as arr FROM empty;
-- Tag: cte_cte_test_select_534
SELECT ARRAY_AGG(DISTINCT value) as arr FROM data;
-- Tag: cte_cte_test_select_535
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_536
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_537
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_538
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_539
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_540
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_541
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_542
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_543
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_544
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_545
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_546
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_547
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_548
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_549
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_550
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_551
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_552
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_553
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_554
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_555
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_556
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_557
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_558
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_559
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_560
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_561
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_562
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_563
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_564
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_565
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_566
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_567
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_568
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_569
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_570
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('A', 2), ('B', 3), ('B', 4), ('B', 5);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (2), (3), (3), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_571
SELECT ARRAY_AGG(value) as arr FROM data;
-- Tag: cte_cte_test_select_572
SELECT ARRAY_AGG(value IGNORE NULLS) as arr FROM data;
-- Tag: cte_cte_test_select_573
SELECT category, ARRAY_AGG(value) as arr FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_574
SELECT ARRAY_AGG(value) as arr FROM empty;
-- Tag: cte_cte_test_select_575
SELECT ARRAY_AGG(DISTINCT value) as arr FROM data;
-- Tag: cte_cte_test_select_576
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_577
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_578
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_579
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_580
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_581
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_582
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_583
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_584
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_585
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_586
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_587
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_588
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_589
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_590
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_591
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_592
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_593
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_594
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_595
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_596
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_597
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_598
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_599
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_600
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_601
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_602
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_603
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_604
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_605
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_606
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_607
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_608
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_609
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_610
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_611
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (NULL), (3), (NULL), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('A', 2), ('B', 3), ('B', 4), ('B', 5);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (2), (3), (3), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_612
SELECT ARRAY_AGG(value IGNORE NULLS) as arr FROM data;
-- Tag: cte_cte_test_select_613
SELECT category, ARRAY_AGG(value) as arr FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_614
SELECT ARRAY_AGG(value) as arr FROM empty;
-- Tag: cte_cte_test_select_615
SELECT ARRAY_AGG(DISTINCT value) as arr FROM data;
-- Tag: cte_cte_test_select_616
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_617
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_618
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_619
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_620
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_621
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_622
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_623
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_624
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_625
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_626
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_627
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_628
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_629
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_630
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_631
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_632
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_633
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_634
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_635
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_636
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_637
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_638
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_639
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_640
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_641
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_642
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_643
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_644
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_645
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_646
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_647
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_648
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_649
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_650
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_651
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('A', 2), ('B', 3), ('B', 4), ('B', 5);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (2), (3), (3), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_652
SELECT category, ARRAY_AGG(value) as arr FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_653
SELECT ARRAY_AGG(value) as arr FROM empty;
-- Tag: cte_cte_test_select_654
SELECT ARRAY_AGG(DISTINCT value) as arr FROM data;
-- Tag: cte_cte_test_select_655
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_656
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_657
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_658
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_659
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_660
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_661
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_662
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_663
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_664
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_665
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_666
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_667
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_668
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_669
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_670
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_671
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_672
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_673
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_674
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_675
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_676
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_677
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_678
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_679
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_680
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_681
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_682
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_683
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_684
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_685
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_686
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_687
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_688
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_689
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_690
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS empty;
CREATE TABLE empty (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (2), (3), (3), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_691
SELECT ARRAY_AGG(value) as arr FROM empty;
-- Tag: cte_cte_test_select_692
SELECT ARRAY_AGG(DISTINCT value) as arr FROM data;
-- Tag: cte_cte_test_select_693
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_694
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_695
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_696
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_697
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_698
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_699
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_700
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_701
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_702
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_703
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_704
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_705
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_706
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_707
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_708
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_709
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_710
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_711
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_712
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_713
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_714
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_715
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_716
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_717
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_718
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_719
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_720
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_721
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_722
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_723
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_724
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_725
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_726
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_727
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_728
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (2), (3), (3), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_729
SELECT ARRAY_AGG(DISTINCT value) as arr FROM data;
-- Tag: cte_cte_test_select_730
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_731
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_732
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_733
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_734
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_735
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_736
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_737
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_738
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_739
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_740
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_741
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_742
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_743
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_744
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_745
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_746
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_747
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_748
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_749
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_750
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_751
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_752
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_753
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_754
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_755
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_756
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_757
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_758
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_759
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_760
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_761
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_762
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_763
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_764
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_765
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_766
SELECT ARRAY_APPEND(ARRAY[1, 2, 3], 4) as arr;
-- Tag: cte_cte_test_select_767
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_768
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_769
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_770
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_771
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_772
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_773
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_774
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_775
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_776
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_777
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_778
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_779
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_780
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_781
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_782
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_783
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_784
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_785
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_786
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_787
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_788
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_789
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_790
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_791
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_792
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_793
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_794
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_795
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_796
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_797
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_798
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_799
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_800
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_801
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_802
SELECT ARRAY_APPEND(ARRAY[], 1) as arr;
-- Tag: cte_cte_test_select_803
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_804
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_805
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_806
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_807
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_808
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_809
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_810
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_811
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_812
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_813
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_814
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_815
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_816
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_817
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_818
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_819
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_820
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_821
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_822
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_823
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_824
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_825
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_826
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_827
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_828
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_829
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_830
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_831
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_832
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_833
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_834
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_835
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_836
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_837
SELECT ARRAY_APPEND(ARRAY[1, 2], NULL) as arr;
-- Tag: cte_cte_test_select_838
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_839
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_840
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_841
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_842
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_843
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_844
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_845
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_846
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_847
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_848
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_849
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_850
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_851
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_852
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_853
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_854
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_855
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_856
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_857
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_858
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_859
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_860
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_861
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_862
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_863
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_864
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_865
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_866
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_867
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_868
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_869
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_870
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_871
SELECT ARRAY_PREPEND(0, ARRAY[1, 2, 3]) as arr;
-- Tag: cte_cte_test_select_872
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_873
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_874
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_875
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_876
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_877
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_878
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_879
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_880
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_881
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_882
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_883
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_884
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_885
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_886
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_887
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_888
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_889
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_890
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_891
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_892
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_893
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_894
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_895
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_896
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_897
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_898
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_899
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_900
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_901
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_902
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_903
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_904
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4, 5]) as arr;
-- Tag: cte_cte_test_select_905
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_906
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_907
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_908
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_909
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_910
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_911
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_912
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_913
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_914
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_915
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_916
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_917
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_918
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_919
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_920
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_921
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_922
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_923
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_924
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_925
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_926
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_927
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_928
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_929
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_930
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_931
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_932
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_933
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_934
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_935
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_936
SELECT ARRAY_CAT(ARRAY[1, 2], ARRAY[]) as arr;
-- Tag: cte_cte_test_select_937
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_938
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_939
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_940
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_941
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_942
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_943
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_944
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_945
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_946
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_947
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_948
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_949
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_950
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_951
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_952
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_953
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_954
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_955
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_956
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_957
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_958
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_959
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_960
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_961
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_962
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_963
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_964
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_965
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_966
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_967
SELECT ARRAY_CAT(ARRAY_CAT(ARRAY[1], ARRAY[2, 3]), ARRAY[4, 5]) as arr;
-- Tag: cte_cte_test_select_968
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_969
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_970
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_971
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_972
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_973
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_974
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_975
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_976
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_977
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_978
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_979
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_980
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_981
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_982
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_983
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_984
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_985
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_986
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_987
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_988
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_989
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_990
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_991
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_992
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_993
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_994
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_995
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_996
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_997
SELECT ARRAY_POSITION(ARRAY['a', 'b', 'c', 'd'], 'c') as pos;
-- Tag: cte_cte_test_select_998
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_999
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_1000
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_1001
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_1002
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_1003
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_1004
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_1005
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_1006
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_1007
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_1008
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_1009
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_1010
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_1011
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_1012
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_1013
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_1014
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_1015
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_1016
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_1017
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_1018
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_1019
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_1020
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_1021
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_1022
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_1023
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_1024
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_1025
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_1026
SELECT ARRAY_POSITION(ARRAY[1, 2, 3], 5) as pos;
-- Tag: cte_cte_test_select_1027
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_1028
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_1029
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_1030
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_1031
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_1032
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_1033
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_1034
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_1035
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_1036
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_1037
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_1038
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_1039
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_1040
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_1041
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_1042
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_1043
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_1044
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_1045
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_1046
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_1047
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_1048
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_1049
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_1050
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_1051
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_1052
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_1053
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_1054
SELECT ARRAY_POSITION(ARRAY[1, 2, 3, 2, 1], 2) as pos;
-- Tag: cte_cte_test_select_1055
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_1056
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_1057
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_1058
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_1059
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_1060
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_1061
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_1062
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_1063
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_1064
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_1065
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_1066
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_1067
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_1068
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_1069
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_1070
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_1071
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_1072
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_1073
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_1074
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_1075
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_1076
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_1077
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_1078
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_1079
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_1080
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_1081
SELECT ARRAY_POSITION(ARRAY[1, NULL, 3], NULL) as pos;
-- Tag: cte_cte_test_select_1082
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_1083
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_1084
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_1085
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_1086
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_1087
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_1088
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_1089
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_1090
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_1091
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_1092
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_1093
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_1094
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_1095
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_1096
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_1097
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_1098
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_1099
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_1100
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_1101
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_1102
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_1103
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_1104
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_1105
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_1106
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_1107
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3, 4], 3) as arr;
-- Tag: cte_cte_test_select_1108
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_1109
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_1110
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_1111
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_1112
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_1113
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_1114
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_1115
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_1116
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_1117
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_1118
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_1119
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_1120
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_1121
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_1122
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_1123
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_1124
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_1125
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_1126
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_1127
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_1128
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_1129
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_1130
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_1131
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_1132
SELECT ARRAY_REMOVE(ARRAY[1, 2, 2, 3, 2, 4], 2) as arr;
-- Tag: cte_cte_test_select_1133
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_1134
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_1135
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_1136
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_1137
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_1138
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_1139
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_1140
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_1141
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_1142
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_1143
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_1144
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_1145
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_1146
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_1147
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_1148
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_1149
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_1150
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_1151
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_1152
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_1153
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_1154
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_1155
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_1156
SELECT ARRAY_REMOVE(ARRAY[1, 2, 3], 5) as arr;
-- Tag: cte_cte_test_select_1157
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_1158
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_1159
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_1160
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_1161
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_1162
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_1163
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_1164
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_1165
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_1166
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_1167
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_1168
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_1169
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_1170
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_1171
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_1172
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_1173
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_1174
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_1175
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_1176
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_1177
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_1178
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_1179
SELECT ARRAY_REPLACE(ARRAY[1, 2, 3, 4], 3, 99) as arr;
-- Tag: cte_cte_test_select_1180
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_1181
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_1182
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_1183
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_1184
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_1185
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_1186
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_1187
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_1188
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_1189
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_1190
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_1191
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_1192
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_1193
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_1194
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_1195
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_1196
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_1197
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_1198
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_1199
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_1200
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_1201
SELECT ARRAY_REPLACE(ARRAY[1, 2, 2, 3, 2], 2, 20) as arr;
-- Tag: cte_cte_test_select_1202
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_1203
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_1204
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_1205
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_1206
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_1207
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_1208
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_1209
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_1210
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_1211
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_1212
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_1213
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_1214
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_1215
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_1216
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_1217
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_1218
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_1219
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_1220
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_1221
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_1222
SELECT * FROM UNNEST(ARRAY[1, 2, 3, 4, 5]) as num;
-- Tag: cte_cte_test_select_1223
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_1224
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_1225
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_1226
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_1227
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_1228
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_1229
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_1230
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_1231
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_1232
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_1233
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_1234
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_1235
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_1236
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_1237
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_1238
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_1239
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_1240
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_1241
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_1242
SELECT * FROM UNNEST(ARRAY[]) as num;
-- Tag: cte_cte_test_select_1243
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_1244
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_1245
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_1246
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_1247
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_1248
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_1249
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_1250
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_1251
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_1252
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_1253
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_1254
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_1255
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_1256
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_1257
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_1258
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_1259
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_1260
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_1261
SELECT * FROM UNNEST(ARRAY[1, NULL, 3]) as num;
-- Tag: cte_cte_test_select_1262
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_1263
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_1264
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_1265
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_1266
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_1267
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_1268
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_1269
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_1270
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_1271
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_1272
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_1273
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_1274
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_1275
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_1276
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_1277
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_1278
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, tags ARRAY<STRING>);
INSERT INTO data VALUES (1, ARRAY['tag1', 'tag2']), (2, ARRAY['tag3']);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 5), (2, 10), (3, 15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (1, 20), (2, 30);

-- Tag: cte_cte_test_select_1279
SELECT * FROM UNNEST(ARRAY['a', 'b', 'c']) WITH ORDINALITY as t(elem, idx);
-- Tag: cte_cte_test_select_1280
SELECT * FROM UNNEST(ARRAY[1, 2, 3], ARRAY['a', 'b', 'c']) as t(num, letter);
-- Tag: cte_cte_test_select_1281
SELECT id, tag FROM data, UNNEST(tags) as tag;
-- Tag: cte_cte_test_select_1282
SELECT ARRAY[10, 20, 30, 40][2] as elem;
-- Tag: cte_cte_test_select_1283
SELECT ARRAY[10, 20, 30][1] as first, ARRAY[10, 20, 30][3] as last;
-- Tag: cte_cte_test_select_1284
SELECT ARRAY[1, 2, 3][10] as elem;
-- Tag: cte_cte_test_select_1285
SELECT ARRAY[10, 20, 30][-1] as last;
-- Tag: cte_cte_test_select_1286
SELECT ARRAY[1, 2, 3, 4, 5][2:4] as slice;
-- Tag: cte_cte_test_select_1287
SELECT ARRAY[1, 2, 3, 4, 5][:3] as slice;
-- Tag: cte_cte_test_select_1288
SELECT ARRAY[1, 2, 3, 4, 5][3:] as slice;
-- Tag: cte_cte_test_select_1289
SELECT * FROM data WHERE value = ANY(ARRAY[5, 10, 20]);
-- Tag: cte_cte_test_select_1290
SELECT * FROM data WHERE value > ALL(ARRAY[5, 8]);
-- Tag: cte_cte_test_select_1291
SELECT * FROM data WHERE value = ANY(ARRAY[]);
-- Tag: cte_cte_test_select_1292
SELECT * FROM UNNEST((SELECT ARRAY_AGG(value) FROM data)) as val;
-- Tag: cte_cte_test_select_1293
SELECT * FROM data WHERE ARRAY_LENGTH(arr) > 2;
-- Tag: cte_cte_test_select_1294
SELECT ARRAY_LENGTH(ARRAY_CAT(ARRAY[1, 2], ARRAY[3, 4])) as len;
-- Tag: cte_cte_test_select_1295
SELECT id, ARRAY_AGG(value) as values FROM data GROUP BY id ORDER BY id;

DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
INSERT INTO users VALUES (2, 'Bob', 25);
INSERT INTO users VALUES (3, 'Charlie', 35);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Apple', 1.99);
INSERT INTO products VALUES (2, 'Banana', 0.99);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary INT64, department STRING);
INSERT INTO employees VALUES (1, 'Alice', 50000, 'Engineering');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
INSERT INTO users VALUES (2, 'Bob', 25);
INSERT INTO users VALUES (3, 'Charlie', 30);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Apple', 1.99);
INSERT INTO products VALUES (2, 'Banana', 0.99);
INSERT INTO products VALUES (3, 'Cherry', 2.99);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, age INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', 30, 60000);
INSERT INTO employees VALUES (2, 'Bob', 25, 50000);
INSERT INTO employees VALUES (3, 'Charlie', 30, 55000);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, city STRING);
INSERT INTO users VALUES (1, 'Alice', 'NYC');
INSERT INTO users VALUES (2, 'Bob', 'LA');
INSERT INTO users VALUES (3, 'Charlie', 'SF');
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (value INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (name STRING, price FLOAT64);
INSERT INTO products VALUES ('Apple', 1.99);
INSERT INTO products VALUES ('Banana', 0.99);
INSERT INTO products VALUES ('Cherry', 2.99);
INSERT INTO products VALUES ('Date', 3.99);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64, name STRING);
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1);
INSERT INTO table2 VALUES (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_1296
SELECT * FROM users;
-- Tag: cte_cte_test_select_1297
SELECT * FROM products;
-- Tag: cte_cte_test_select_1298
SELECT name, salary FROM employees;
-- Tag: cte_cte_test_select_1299
SELECT * FROM users WHERE age = 30;
-- Tag: cte_cte_test_select_1300
SELECT * FROM products WHERE price > 1.5;
-- Tag: cte_cte_test_select_1301
SELECT * FROM employees WHERE age = 30 AND salary > 58000;
-- Tag: cte_cte_test_select_1302
SELECT * FROM users WHERE city = 'NYC' OR city = 'SF';
-- Tag: cte_cte_test_select_1303
SELECT * FROM scores ORDER BY score ASC;
-- Tag: cte_cte_test_select_1304
SELECT * FROM scores ORDER BY score DESC;
-- Tag: cte_cte_test_select_1305
SELECT * FROM numbers LIMIT 5;
-- Tag: cte_cte_test_select_1306
SELECT * FROM products ORDER BY price DESC LIMIT 2;
-- Tag: cte_cte_test_select_1307
SELECT * FROM empty_table;
-- Tag: cte_cte_test_select_1308
SELECT * FROM table1;
-- Tag: cte_cte_test_select_1309
SELECT * FROM table2;
-- Tag: cte_cte_test_select_1310
SELECT * FROM nullable;
-- Tag: cte_cte_test_select_1311
SELECT * FROM nullable WHERE value IS NULL;
-- Tag: cte_cte_test_select_1312
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_1313
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_1314
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_1315
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_1316
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_1317
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_1318
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_1319
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_1320
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_1321
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_1322
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_1323
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_1324
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_1325
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_1326
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_1327
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_1328
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_1329
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_1330
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_1331
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_1332
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_1333
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1334
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1335
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1336
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_1337
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_1338
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_1339
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1340
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1341
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1342
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1343
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1344
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_1345
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_1346
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_1347
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
INSERT INTO users VALUES (2, 'Bob', 25);
INSERT INTO users VALUES (3, 'Charlie', 35);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Apple', 1.99);
INSERT INTO products VALUES (2, 'Banana', 0.99);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary INT64, department STRING);
INSERT INTO employees VALUES (1, 'Alice', 50000, 'Engineering');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
INSERT INTO users VALUES (2, 'Bob', 25);
INSERT INTO users VALUES (3, 'Charlie', 30);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Apple', 1.99);
INSERT INTO products VALUES (2, 'Banana', 0.99);
INSERT INTO products VALUES (3, 'Cherry', 2.99);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, age INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', 30, 60000);
INSERT INTO employees VALUES (2, 'Bob', 25, 50000);
INSERT INTO employees VALUES (3, 'Charlie', 30, 55000);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, city STRING);
INSERT INTO users VALUES (1, 'Alice', 'NYC');
INSERT INTO users VALUES (2, 'Bob', 'LA');
INSERT INTO users VALUES (3, 'Charlie', 'SF');
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (value INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (name STRING, price FLOAT64);
INSERT INTO products VALUES ('Apple', 1.99);
INSERT INTO products VALUES ('Banana', 0.99);
INSERT INTO products VALUES ('Cherry', 2.99);
INSERT INTO products VALUES ('Date', 3.99);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64, name STRING);
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1);
INSERT INTO table2 VALUES (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_1348
SELECT * FROM users;
-- Tag: cte_cte_test_select_1349
SELECT * FROM products;
-- Tag: cte_cte_test_select_1350
SELECT name, salary FROM employees;
-- Tag: cte_cte_test_select_1351
SELECT * FROM users WHERE age = 30;
-- Tag: cte_cte_test_select_1352
SELECT * FROM products WHERE price > 1.5;
-- Tag: cte_cte_test_select_1353
SELECT * FROM employees WHERE age = 30 AND salary > 58000;
-- Tag: cte_cte_test_select_1354
SELECT * FROM users WHERE city = 'NYC' OR city = 'SF';
-- Tag: cte_cte_test_select_1355
SELECT * FROM scores ORDER BY score ASC;
-- Tag: cte_cte_test_select_1356
SELECT * FROM scores ORDER BY score DESC;
-- Tag: cte_cte_test_select_1357
SELECT * FROM numbers LIMIT 5;
-- Tag: cte_cte_test_select_1358
SELECT * FROM products ORDER BY price DESC LIMIT 2;
-- Tag: cte_cte_test_select_1359
SELECT * FROM empty_table;
-- Tag: cte_cte_test_select_1360
SELECT * FROM table1;
-- Tag: cte_cte_test_select_1361
SELECT * FROM table2;
-- Tag: cte_cte_test_select_1362
SELECT * FROM nullable;
-- Tag: cte_cte_test_select_1363
SELECT * FROM nullable WHERE value IS NULL;
-- Tag: cte_cte_test_select_1364
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_1365
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_1366
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_1367
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_1368
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_1369
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_1370
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_1371
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_1372
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_1373
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_1374
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_1375
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_1376
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_1377
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_1378
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_1379
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_1380
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_1381
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_1382
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_1383
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_1384
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_1385
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1386
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1387
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1388
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_1389
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_1390
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_1391
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1392
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1393
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1394
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1395
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1396
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_1397
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_1398
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_1399
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
INSERT INTO users VALUES (2, 'Bob', 25);
INSERT INTO users VALUES (3, 'Charlie', 35);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Apple', 1.99);
INSERT INTO products VALUES (2, 'Banana', 0.99);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary INT64, department STRING);
INSERT INTO employees VALUES (1, 'Alice', 50000, 'Engineering');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
INSERT INTO users VALUES (2, 'Bob', 25);
INSERT INTO users VALUES (3, 'Charlie', 30);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Apple', 1.99);
INSERT INTO products VALUES (2, 'Banana', 0.99);
INSERT INTO products VALUES (3, 'Cherry', 2.99);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, age INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', 30, 60000);
INSERT INTO employees VALUES (2, 'Bob', 25, 50000);
INSERT INTO employees VALUES (3, 'Charlie', 30, 55000);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, city STRING);
INSERT INTO users VALUES (1, 'Alice', 'NYC');
INSERT INTO users VALUES (2, 'Bob', 'LA');
INSERT INTO users VALUES (3, 'Charlie', 'SF');
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (value INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (name STRING, price FLOAT64);
INSERT INTO products VALUES ('Apple', 1.99);
INSERT INTO products VALUES ('Banana', 0.99);
INSERT INTO products VALUES ('Cherry', 2.99);
INSERT INTO products VALUES ('Date', 3.99);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64, name STRING);
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1);
INSERT INTO table2 VALUES (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_1400
SELECT * FROM users;
-- Tag: cte_cte_test_select_1401
SELECT * FROM products;
-- Tag: cte_cte_test_select_1402
SELECT name, salary FROM employees;
-- Tag: cte_cte_test_select_1403
SELECT * FROM users WHERE age = 30;
-- Tag: cte_cte_test_select_1404
SELECT * FROM products WHERE price > 1.5;
-- Tag: cte_cte_test_select_1405
SELECT * FROM employees WHERE age = 30 AND salary > 58000;
-- Tag: cte_cte_test_select_1406
SELECT * FROM users WHERE city = 'NYC' OR city = 'SF';
-- Tag: cte_cte_test_select_1407
SELECT * FROM scores ORDER BY score ASC;
-- Tag: cte_cte_test_select_1408
SELECT * FROM scores ORDER BY score DESC;
-- Tag: cte_cte_test_select_1409
SELECT * FROM numbers LIMIT 5;
-- Tag: cte_cte_test_select_1410
SELECT * FROM products ORDER BY price DESC LIMIT 2;
-- Tag: cte_cte_test_select_1411
SELECT * FROM empty_table;
-- Tag: cte_cte_test_select_1412
SELECT * FROM table1;
-- Tag: cte_cte_test_select_1413
SELECT * FROM table2;
-- Tag: cte_cte_test_select_1414
SELECT * FROM nullable;
-- Tag: cte_cte_test_select_1415
SELECT * FROM nullable WHERE value IS NULL;
-- Tag: cte_cte_test_select_1416
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_1417
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_1418
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_1419
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_1420
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_1421
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_1422
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_1423
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_1424
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_1425
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_1426
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_1427
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_1428
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_1429
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_1430
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_1431
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_1432
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_1433
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_1434
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_1435
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_1436
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_1437
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1438
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1439
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1440
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_1441
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_1442
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_1443
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1444
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1445
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1446
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1447
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1448
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_1449
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_1450
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_1451
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Apple', 1.99);
INSERT INTO products VALUES (2, 'Banana', 0.99);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary INT64, department STRING);
INSERT INTO employees VALUES (1, 'Alice', 50000, 'Engineering');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
INSERT INTO users VALUES (2, 'Bob', 25);
INSERT INTO users VALUES (3, 'Charlie', 30);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Apple', 1.99);
INSERT INTO products VALUES (2, 'Banana', 0.99);
INSERT INTO products VALUES (3, 'Cherry', 2.99);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, age INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', 30, 60000);
INSERT INTO employees VALUES (2, 'Bob', 25, 50000);
INSERT INTO employees VALUES (3, 'Charlie', 30, 55000);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, city STRING);
INSERT INTO users VALUES (1, 'Alice', 'NYC');
INSERT INTO users VALUES (2, 'Bob', 'LA');
INSERT INTO users VALUES (3, 'Charlie', 'SF');
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (value INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (name STRING, price FLOAT64);
INSERT INTO products VALUES ('Apple', 1.99);
INSERT INTO products VALUES ('Banana', 0.99);
INSERT INTO products VALUES ('Cherry', 2.99);
INSERT INTO products VALUES ('Date', 3.99);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64, name STRING);
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1);
INSERT INTO table2 VALUES (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_1452
SELECT * FROM products;
-- Tag: cte_cte_test_select_1453
SELECT name, salary FROM employees;
-- Tag: cte_cte_test_select_1454
SELECT * FROM users WHERE age = 30;
-- Tag: cte_cte_test_select_1455
SELECT * FROM products WHERE price > 1.5;
-- Tag: cte_cte_test_select_1456
SELECT * FROM employees WHERE age = 30 AND salary > 58000;
-- Tag: cte_cte_test_select_1457
SELECT * FROM users WHERE city = 'NYC' OR city = 'SF';
-- Tag: cte_cte_test_select_1458
SELECT * FROM scores ORDER BY score ASC;
-- Tag: cte_cte_test_select_1459
SELECT * FROM scores ORDER BY score DESC;
-- Tag: cte_cte_test_select_1460
SELECT * FROM numbers LIMIT 5;
-- Tag: cte_cte_test_select_1461
SELECT * FROM products ORDER BY price DESC LIMIT 2;
-- Tag: cte_cte_test_select_1462
SELECT * FROM empty_table;
-- Tag: cte_cte_test_select_1463
SELECT * FROM table1;
-- Tag: cte_cte_test_select_1464
SELECT * FROM table2;
-- Tag: cte_cte_test_select_1465
SELECT * FROM nullable;
-- Tag: cte_cte_test_select_1466
SELECT * FROM nullable WHERE value IS NULL;
-- Tag: cte_cte_test_select_1467
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_1468
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_1469
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_1470
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_1471
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_1472
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_1473
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_1474
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_1475
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_1476
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_1477
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_1478
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_1479
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_1480
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_1481
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_1482
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_1483
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_1484
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_1485
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_1486
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_1487
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_1488
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1489
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1490
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1491
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_1492
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_1493
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_1494
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1495
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1496
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1497
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1498
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1499
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_1500
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_1501
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_1502
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary INT64, department STRING);
INSERT INTO employees VALUES (1, 'Alice', 50000, 'Engineering');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
INSERT INTO users VALUES (2, 'Bob', 25);
INSERT INTO users VALUES (3, 'Charlie', 30);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Apple', 1.99);
INSERT INTO products VALUES (2, 'Banana', 0.99);
INSERT INTO products VALUES (3, 'Cherry', 2.99);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, age INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', 30, 60000);
INSERT INTO employees VALUES (2, 'Bob', 25, 50000);
INSERT INTO employees VALUES (3, 'Charlie', 30, 55000);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, city STRING);
INSERT INTO users VALUES (1, 'Alice', 'NYC');
INSERT INTO users VALUES (2, 'Bob', 'LA');
INSERT INTO users VALUES (3, 'Charlie', 'SF');
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (value INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (name STRING, price FLOAT64);
INSERT INTO products VALUES ('Apple', 1.99);
INSERT INTO products VALUES ('Banana', 0.99);
INSERT INTO products VALUES ('Cherry', 2.99);
INSERT INTO products VALUES ('Date', 3.99);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64, name STRING);
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1);
INSERT INTO table2 VALUES (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_1503
SELECT name, salary FROM employees;
-- Tag: cte_cte_test_select_1504
SELECT * FROM users WHERE age = 30;
-- Tag: cte_cte_test_select_1505
SELECT * FROM products WHERE price > 1.5;
-- Tag: cte_cte_test_select_1506
SELECT * FROM employees WHERE age = 30 AND salary > 58000;
-- Tag: cte_cte_test_select_1507
SELECT * FROM users WHERE city = 'NYC' OR city = 'SF';
-- Tag: cte_cte_test_select_1508
SELECT * FROM scores ORDER BY score ASC;
-- Tag: cte_cte_test_select_1509
SELECT * FROM scores ORDER BY score DESC;
-- Tag: cte_cte_test_select_1510
SELECT * FROM numbers LIMIT 5;
-- Tag: cte_cte_test_select_1511
SELECT * FROM products ORDER BY price DESC LIMIT 2;
-- Tag: cte_cte_test_select_1512
SELECT * FROM empty_table;
-- Tag: cte_cte_test_select_1513
SELECT * FROM table1;
-- Tag: cte_cte_test_select_1514
SELECT * FROM table2;
-- Tag: cte_cte_test_select_1515
SELECT * FROM nullable;
-- Tag: cte_cte_test_select_1516
SELECT * FROM nullable WHERE value IS NULL;
-- Tag: cte_cte_test_select_1517
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_1518
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_1519
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_1520
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_1521
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_1522
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_1523
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_1524
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_1525
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_1526
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_1527
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_1528
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_1529
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_1530
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_1531
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_1532
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_1533
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_1534
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_1535
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_1536
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_1537
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_1538
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1539
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1540
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1541
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_1542
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_1543
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_1544
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1545
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1546
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1547
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1548
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1549
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_1550
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_1551
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_1552
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
INSERT INTO users VALUES (2, 'Bob', 25);
INSERT INTO users VALUES (3, 'Charlie', 30);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Apple', 1.99);
INSERT INTO products VALUES (2, 'Banana', 0.99);
INSERT INTO products VALUES (3, 'Cherry', 2.99);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, age INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', 30, 60000);
INSERT INTO employees VALUES (2, 'Bob', 25, 50000);
INSERT INTO employees VALUES (3, 'Charlie', 30, 55000);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, city STRING);
INSERT INTO users VALUES (1, 'Alice', 'NYC');
INSERT INTO users VALUES (2, 'Bob', 'LA');
INSERT INTO users VALUES (3, 'Charlie', 'SF');
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (value INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (name STRING, price FLOAT64);
INSERT INTO products VALUES ('Apple', 1.99);
INSERT INTO products VALUES ('Banana', 0.99);
INSERT INTO products VALUES ('Cherry', 2.99);
INSERT INTO products VALUES ('Date', 3.99);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64, name STRING);
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1);
INSERT INTO table2 VALUES (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_1553
SELECT * FROM users WHERE age = 30;
-- Tag: cte_cte_test_select_1554
SELECT * FROM products WHERE price > 1.5;
-- Tag: cte_cte_test_select_1555
SELECT * FROM employees WHERE age = 30 AND salary > 58000;
-- Tag: cte_cte_test_select_1556
SELECT * FROM users WHERE city = 'NYC' OR city = 'SF';
-- Tag: cte_cte_test_select_1557
SELECT * FROM scores ORDER BY score ASC;
-- Tag: cte_cte_test_select_1558
SELECT * FROM scores ORDER BY score DESC;
-- Tag: cte_cte_test_select_1559
SELECT * FROM numbers LIMIT 5;
-- Tag: cte_cte_test_select_1560
SELECT * FROM products ORDER BY price DESC LIMIT 2;
-- Tag: cte_cte_test_select_1561
SELECT * FROM empty_table;
-- Tag: cte_cte_test_select_1562
SELECT * FROM table1;
-- Tag: cte_cte_test_select_1563
SELECT * FROM table2;
-- Tag: cte_cte_test_select_1564
SELECT * FROM nullable;
-- Tag: cte_cte_test_select_1565
SELECT * FROM nullable WHERE value IS NULL;
-- Tag: cte_cte_test_select_1566
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_1567
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_1568
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_1569
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_1570
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_1571
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_1572
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_1573
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_1574
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_1575
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_1576
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_1577
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_1578
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_1579
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_1580
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_1581
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_1582
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_1583
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_1584
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_1585
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_1586
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_1587
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1588
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1589
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1590
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_1591
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_1592
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_1593
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1594
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1595
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1596
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1597
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1598
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_1599
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_1600
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_1601
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Apple', 1.99);
INSERT INTO products VALUES (2, 'Banana', 0.99);
INSERT INTO products VALUES (3, 'Cherry', 2.99);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, age INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', 30, 60000);
INSERT INTO employees VALUES (2, 'Bob', 25, 50000);
INSERT INTO employees VALUES (3, 'Charlie', 30, 55000);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, city STRING);
INSERT INTO users VALUES (1, 'Alice', 'NYC');
INSERT INTO users VALUES (2, 'Bob', 'LA');
INSERT INTO users VALUES (3, 'Charlie', 'SF');
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (value INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (name STRING, price FLOAT64);
INSERT INTO products VALUES ('Apple', 1.99);
INSERT INTO products VALUES ('Banana', 0.99);
INSERT INTO products VALUES ('Cherry', 2.99);
INSERT INTO products VALUES ('Date', 3.99);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64, name STRING);
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1);
INSERT INTO table2 VALUES (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_1602
SELECT * FROM products WHERE price > 1.5;
-- Tag: cte_cte_test_select_1603
SELECT * FROM employees WHERE age = 30 AND salary > 58000;
-- Tag: cte_cte_test_select_1604
SELECT * FROM users WHERE city = 'NYC' OR city = 'SF';
-- Tag: cte_cte_test_select_1605
SELECT * FROM scores ORDER BY score ASC;
-- Tag: cte_cte_test_select_1606
SELECT * FROM scores ORDER BY score DESC;
-- Tag: cte_cte_test_select_1607
SELECT * FROM numbers LIMIT 5;
-- Tag: cte_cte_test_select_1608
SELECT * FROM products ORDER BY price DESC LIMIT 2;
-- Tag: cte_cte_test_select_1609
SELECT * FROM empty_table;
-- Tag: cte_cte_test_select_1610
SELECT * FROM table1;
-- Tag: cte_cte_test_select_1611
SELECT * FROM table2;
-- Tag: cte_cte_test_select_1612
SELECT * FROM nullable;
-- Tag: cte_cte_test_select_1613
SELECT * FROM nullable WHERE value IS NULL;
-- Tag: cte_cte_test_select_1614
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_1615
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_1616
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_1617
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_1618
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_1619
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_1620
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_1621
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_1622
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_1623
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_1624
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_1625
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_1626
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_1627
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_1628
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_1629
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_1630
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_1631
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_1632
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_1633
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_1634
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_1635
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1636
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1637
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1638
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_1639
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_1640
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_1641
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1642
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1643
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1644
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1645
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1646
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_1647
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_1648
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_1649
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, age INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', 30, 60000);
INSERT INTO employees VALUES (2, 'Bob', 25, 50000);
INSERT INTO employees VALUES (3, 'Charlie', 30, 55000);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, city STRING);
INSERT INTO users VALUES (1, 'Alice', 'NYC');
INSERT INTO users VALUES (2, 'Bob', 'LA');
INSERT INTO users VALUES (3, 'Charlie', 'SF');
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (value INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (name STRING, price FLOAT64);
INSERT INTO products VALUES ('Apple', 1.99);
INSERT INTO products VALUES ('Banana', 0.99);
INSERT INTO products VALUES ('Cherry', 2.99);
INSERT INTO products VALUES ('Date', 3.99);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64, name STRING);
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1);
INSERT INTO table2 VALUES (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_1650
SELECT * FROM employees WHERE age = 30 AND salary > 58000;
-- Tag: cte_cte_test_select_1651
SELECT * FROM users WHERE city = 'NYC' OR city = 'SF';
-- Tag: cte_cte_test_select_1652
SELECT * FROM scores ORDER BY score ASC;
-- Tag: cte_cte_test_select_1653
SELECT * FROM scores ORDER BY score DESC;
-- Tag: cte_cte_test_select_1654
SELECT * FROM numbers LIMIT 5;
-- Tag: cte_cte_test_select_1655
SELECT * FROM products ORDER BY price DESC LIMIT 2;
-- Tag: cte_cte_test_select_1656
SELECT * FROM empty_table;
-- Tag: cte_cte_test_select_1657
SELECT * FROM table1;
-- Tag: cte_cte_test_select_1658
SELECT * FROM table2;
-- Tag: cte_cte_test_select_1659
SELECT * FROM nullable;
-- Tag: cte_cte_test_select_1660
SELECT * FROM nullable WHERE value IS NULL;
-- Tag: cte_cte_test_select_1661
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_1662
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_1663
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_1664
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_1665
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_1666
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_1667
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_1668
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_1669
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_1670
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_1671
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_1672
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_1673
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_1674
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_1675
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_1676
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_1677
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_1678
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_1679
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_1680
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_1681
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_1682
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1683
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1684
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1685
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_1686
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_1687
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_1688
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1689
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1690
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1691
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1692
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1693
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_1694
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_1695
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_1696
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, city STRING);
INSERT INTO users VALUES (1, 'Alice', 'NYC');
INSERT INTO users VALUES (2, 'Bob', 'LA');
INSERT INTO users VALUES (3, 'Charlie', 'SF');
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (value INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (name STRING, price FLOAT64);
INSERT INTO products VALUES ('Apple', 1.99);
INSERT INTO products VALUES ('Banana', 0.99);
INSERT INTO products VALUES ('Cherry', 2.99);
INSERT INTO products VALUES ('Date', 3.99);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64, name STRING);
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1);
INSERT INTO table2 VALUES (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_1697
SELECT * FROM users WHERE city = 'NYC' OR city = 'SF';
-- Tag: cte_cte_test_select_1698
SELECT * FROM scores ORDER BY score ASC;
-- Tag: cte_cte_test_select_1699
SELECT * FROM scores ORDER BY score DESC;
-- Tag: cte_cte_test_select_1700
SELECT * FROM numbers LIMIT 5;
-- Tag: cte_cte_test_select_1701
SELECT * FROM products ORDER BY price DESC LIMIT 2;
-- Tag: cte_cte_test_select_1702
SELECT * FROM empty_table;
-- Tag: cte_cte_test_select_1703
SELECT * FROM table1;
-- Tag: cte_cte_test_select_1704
SELECT * FROM table2;
-- Tag: cte_cte_test_select_1705
SELECT * FROM nullable;
-- Tag: cte_cte_test_select_1706
SELECT * FROM nullable WHERE value IS NULL;
-- Tag: cte_cte_test_select_1707
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_1708
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_1709
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_1710
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_1711
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_1712
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_1713
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_1714
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_1715
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_1716
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_1717
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_1718
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_1719
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_1720
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_1721
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_1722
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_1723
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_1724
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_1725
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_1726
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_1727
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_1728
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1729
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1730
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1731
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_1732
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_1733
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_1734
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1735
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1736
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1737
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1738
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1739
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_1740
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_1741
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_1742
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (value INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (name STRING, price FLOAT64);
INSERT INTO products VALUES ('Apple', 1.99);
INSERT INTO products VALUES ('Banana', 0.99);
INSERT INTO products VALUES ('Cherry', 2.99);
INSERT INTO products VALUES ('Date', 3.99);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64, name STRING);
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1);
INSERT INTO table2 VALUES (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_1743
SELECT * FROM scores ORDER BY score ASC;
-- Tag: cte_cte_test_select_1744
SELECT * FROM scores ORDER BY score DESC;
-- Tag: cte_cte_test_select_1745
SELECT * FROM numbers LIMIT 5;
-- Tag: cte_cte_test_select_1746
SELECT * FROM products ORDER BY price DESC LIMIT 2;
-- Tag: cte_cte_test_select_1747
SELECT * FROM empty_table;
-- Tag: cte_cte_test_select_1748
SELECT * FROM table1;
-- Tag: cte_cte_test_select_1749
SELECT * FROM table2;
-- Tag: cte_cte_test_select_1750
SELECT * FROM nullable;
-- Tag: cte_cte_test_select_1751
SELECT * FROM nullable WHERE value IS NULL;
-- Tag: cte_cte_test_select_1752
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_1753
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_1754
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_1755
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_1756
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_1757
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_1758
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_1759
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_1760
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_1761
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_1762
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_1763
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_1764
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_1765
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_1766
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_1767
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_1768
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_1769
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_1770
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_1771
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_1772
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_1773
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1774
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1775
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1776
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_1777
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_1778
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_1779
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1780
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1781
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1782
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1783
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1784
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_1785
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_1786
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_1787
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS scores;
CREATE TABLE scores (name STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 85);
INSERT INTO scores VALUES ('Bob', 92);
INSERT INTO scores VALUES ('Charlie', 78);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (value INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (name STRING, price FLOAT64);
INSERT INTO products VALUES ('Apple', 1.99);
INSERT INTO products VALUES ('Banana', 0.99);
INSERT INTO products VALUES ('Cherry', 2.99);
INSERT INTO products VALUES ('Date', 3.99);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64, name STRING);
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1);
INSERT INTO table2 VALUES (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_1788
SELECT * FROM scores ORDER BY score DESC;
-- Tag: cte_cte_test_select_1789
SELECT * FROM numbers LIMIT 5;
-- Tag: cte_cte_test_select_1790
SELECT * FROM products ORDER BY price DESC LIMIT 2;
-- Tag: cte_cte_test_select_1791
SELECT * FROM empty_table;
-- Tag: cte_cte_test_select_1792
SELECT * FROM table1;
-- Tag: cte_cte_test_select_1793
SELECT * FROM table2;
-- Tag: cte_cte_test_select_1794
SELECT * FROM nullable;
-- Tag: cte_cte_test_select_1795
SELECT * FROM nullable WHERE value IS NULL;
-- Tag: cte_cte_test_select_1796
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_1797
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_1798
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_1799
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_1800
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_1801
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_1802
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_1803
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_1804
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_1805
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_1806
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_1807
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_1808
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_1809
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_1810
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_1811
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_1812
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_1813
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_1814
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_1815
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_1816
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_1817
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1818
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1819
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1820
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_1821
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_1822
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_1823
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1824
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1825
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1826
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1827
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1828
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_1829
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_1830
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_1831
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (value INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (name STRING, price FLOAT64);
INSERT INTO products VALUES ('Apple', 1.99);
INSERT INTO products VALUES ('Banana', 0.99);
INSERT INTO products VALUES ('Cherry', 2.99);
INSERT INTO products VALUES ('Date', 3.99);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64, name STRING);
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1);
INSERT INTO table2 VALUES (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_1832
SELECT * FROM numbers LIMIT 5;
-- Tag: cte_cte_test_select_1833
SELECT * FROM products ORDER BY price DESC LIMIT 2;
-- Tag: cte_cte_test_select_1834
SELECT * FROM empty_table;
-- Tag: cte_cte_test_select_1835
SELECT * FROM table1;
-- Tag: cte_cte_test_select_1836
SELECT * FROM table2;
-- Tag: cte_cte_test_select_1837
SELECT * FROM nullable;
-- Tag: cte_cte_test_select_1838
SELECT * FROM nullable WHERE value IS NULL;
-- Tag: cte_cte_test_select_1839
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_1840
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_1841
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_1842
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_1843
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_1844
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_1845
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_1846
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_1847
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_1848
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_1849
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_1850
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_1851
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_1852
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_1853
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_1854
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_1855
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_1856
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_1857
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_1858
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_1859
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_1860
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1861
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1862
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1863
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_1864
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_1865
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_1866
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1867
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1868
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1869
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1870
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1871
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_1872
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_1873
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_1874
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS products;
CREATE TABLE products (name STRING, price FLOAT64);
INSERT INTO products VALUES ('Apple', 1.99);
INSERT INTO products VALUES ('Banana', 0.99);
INSERT INTO products VALUES ('Cherry', 2.99);
INSERT INTO products VALUES ('Date', 3.99);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64, name STRING);
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1);
INSERT INTO table2 VALUES (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_1875
SELECT * FROM products ORDER BY price DESC LIMIT 2;
-- Tag: cte_cte_test_select_1876
SELECT * FROM empty_table;
-- Tag: cte_cte_test_select_1877
SELECT * FROM table1;
-- Tag: cte_cte_test_select_1878
SELECT * FROM table2;
-- Tag: cte_cte_test_select_1879
SELECT * FROM nullable;
-- Tag: cte_cte_test_select_1880
SELECT * FROM nullable WHERE value IS NULL;
-- Tag: cte_cte_test_select_1881
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_1882
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_1883
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_1884
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_1885
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_1886
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_1887
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_1888
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_1889
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_1890
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_1891
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_1892
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_1893
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_1894
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_1895
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_1896
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_1897
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_1898
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_1899
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_1900
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_1901
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_1902
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1903
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1904
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1905
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_1906
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_1907
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_1908
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1909
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1910
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1911
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1912
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1913
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_1914
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_1915
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_1916
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64, name STRING);
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1);
INSERT INTO table2 VALUES (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_1917
SELECT * FROM empty_table;
-- Tag: cte_cte_test_select_1918
SELECT * FROM table1;
-- Tag: cte_cte_test_select_1919
SELECT * FROM table2;
-- Tag: cte_cte_test_select_1920
SELECT * FROM nullable;
-- Tag: cte_cte_test_select_1921
SELECT * FROM nullable WHERE value IS NULL;
-- Tag: cte_cte_test_select_1922
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_1923
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_1924
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_1925
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_1926
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_1927
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_1928
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_1929
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_1930
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_1931
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_1932
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_1933
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_1934
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_1935
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_1936
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_1937
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_1938
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_1939
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_1940
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_1941
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_1942
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_1943
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1944
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1945
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1946
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_1947
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_1948
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_1949
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1950
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1951
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1952
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1953
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1954
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_1955
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_1956
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_1957
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1);
INSERT INTO table2 VALUES (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_1958
SELECT * FROM table1;
-- Tag: cte_cte_test_select_1959
SELECT * FROM table2;
-- Tag: cte_cte_test_select_1960
SELECT * FROM nullable;
-- Tag: cte_cte_test_select_1961
SELECT * FROM nullable WHERE value IS NULL;
-- Tag: cte_cte_test_select_1962
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_1963
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_1964
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_1965
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_1966
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_1967
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_1968
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_1969
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_1970
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_1971
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_1972
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_1973
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_1974
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_1975
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_1976
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_1977
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_1978
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_1979
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_1980
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_1981
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_1982
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_1983
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1984
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1985
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_1986
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_1987
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_1988
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_1989
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1990
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1991
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1992
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_1993
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_1994
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_1995
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_1996
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_1997
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_1998
SELECT * FROM nullable;
-- Tag: cte_cte_test_select_1999
SELECT * FROM nullable WHERE value IS NULL;
-- Tag: cte_cte_test_select_2000
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_2001
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_2002
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_2003
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_2004
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_2005
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_2006
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_2007
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_2008
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_2009
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_2010
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_2011
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_2012
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_2013
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_2014
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_2015
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_2016
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_2017
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_2018
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_2019
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_2020
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_2021
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2022
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2023
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2024
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_2025
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_2026
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_2027
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2028
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2029
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2030
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2031
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2032
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_2033
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_2034
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_2035
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_2036
SELECT * FROM nullable WHERE value IS NULL;
-- Tag: cte_cte_test_select_2037
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_2038
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_2039
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_2040
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_2041
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_2042
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_2043
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_2044
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_2045
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_2046
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_2047
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_2048
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_2049
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_2050
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_2051
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_2052
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_2053
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_2054
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_2055
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_2056
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_2057
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_2058
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2059
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2060
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2061
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_2062
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_2063
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_2064
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2065
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2066
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2067
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2068
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2069
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_2070
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_2071
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_2072
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, value STRING);
INSERT INTO nullable VALUES (1, 'value');
INSERT INTO nullable VALUES (2, NULL);
INSERT INTO nullable VALUES (3, 'another');
DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_2073
SELECT * FROM nullable WHERE value IS NOT NULL;
-- Tag: cte_cte_test_select_2074
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_2075
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_2076
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_2077
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_2078
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_2079
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_2080
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_2081
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_2082
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_2083
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_2084
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_2085
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_2086
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_2087
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_2088
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_2089
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_2090
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_2091
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_2092
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_2093
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_2094
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2095
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2096
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2097
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_2098
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_2099
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_2100
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2101
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2102
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2103
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2104
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2105
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_2106
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_2107
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_2108
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS test_coalesce;
CREATE TABLE test_coalesce (id INT64, val1 STRING, val2 STRING, val3 STRING);
INSERT INTO test_coalesce VALUES (1, NULL, 'second', 'third');
INSERT INTO test_coalesce VALUES (2, NULL, NULL, 'third');
INSERT INTO test_coalesce VALUES (3, 'first', 'second', 'third');
INSERT INTO test_coalesce VALUES (4, NULL, NULL, NULL);
DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_2109
SELECT id, COALESCE(val1, val2, val3) as result FROM test_coalesce ORDER BY id;
-- Tag: cte_cte_test_select_2110
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_2111
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_2112
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_2113
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_2114
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_2115
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_2116
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_2117
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_2118
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_2119
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_2120
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_2121
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_2122
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_2123
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_2124
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_2125
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_2126
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_2127
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_2128
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_2129
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2130
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2131
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2132
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_2133
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_2134
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_2135
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2136
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2137
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2138
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2139
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2140
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_2141
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_2142
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_2143
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS test_ifnull;
CREATE TABLE test_ifnull (id INT64, value STRING);
INSERT INTO test_ifnull VALUES (1, 'data');
INSERT INTO test_ifnull VALUES (2, NULL);
DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_2144
SELECT id, IFNULL(value, 'default') as result FROM test_ifnull ORDER BY id;
-- Tag: cte_cte_test_select_2145
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_2146
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_2147
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_2148
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_2149
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_2150
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_2151
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_2152
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_2153
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_2154
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_2155
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_2156
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_2157
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_2158
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_2159
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_2160
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_2161
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_2162
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_2163
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2164
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2165
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2166
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_2167
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_2168
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_2169
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2170
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2171
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2172
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2173
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2174
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_2175
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_2176
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_2177
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS test_nullif;
CREATE TABLE test_nullif (id INT64, val1 STRING, val2 STRING);
INSERT INTO test_nullif VALUES (1, 'same', 'same');
INSERT INTO test_nullif VALUES (2, 'different', 'other');
DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_2178
SELECT id, NULLIF(val1, val2) as result FROM test_nullif ORDER BY id;
-- Tag: cte_cte_test_select_2179
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_2180
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_2181
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_2182
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_2183
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_2184
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_2185
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_2186
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_2187
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_2188
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_2189
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_2190
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_2191
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_2192
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_2193
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_2194
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_2195
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_2196
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2197
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2198
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2199
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_2200
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_2201
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_2202
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2203
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2204
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2205
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2206
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2207
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_2208
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_2209
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_2210
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS test_trim;
CREATE TABLE test_trim (id INT64, value STRING);
INSERT INTO test_trim VALUES (1, '  hello  ');
INSERT INTO test_trim VALUES (2, 'world');
INSERT INTO test_trim VALUES (3, '  spaces  ');
DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_2211
SELECT id, TRIM(value) as trimmed FROM test_trim ORDER BY id;
-- Tag: cte_cte_test_select_2212
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_2213
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_2214
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_2215
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_2216
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_2217
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_2218
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_2219
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_2220
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_2221
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_2222
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_2223
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_2224
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_2225
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_2226
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_2227
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_2228
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2229
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2230
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2231
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_2232
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_2233
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_2234
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2235
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2236
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2237
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2238
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2239
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_2240
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_2241
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_2242
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS test_ltrim;
CREATE TABLE test_ltrim (id INT64, value STRING);
INSERT INTO test_ltrim VALUES (1, '  left  ');
INSERT INTO test_ltrim VALUES (2, 'middle');
DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_2243
SELECT id, LTRIM(value) as trimmed FROM test_ltrim ORDER BY id;
-- Tag: cte_cte_test_select_2244
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_2245
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_2246
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_2247
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_2248
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_2249
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_2250
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_2251
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_2252
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_2253
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_2254
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_2255
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_2256
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_2257
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_2258
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_2259
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2260
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2261
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2262
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_2263
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_2264
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_2265
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2266
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2267
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2268
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2269
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2270
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_2271
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_2272
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_2273
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS test_rtrim;
CREATE TABLE test_rtrim (id INT64, value STRING);
INSERT INTO test_rtrim VALUES (1, '  right  ');
INSERT INTO test_rtrim VALUES (2, 'center');
DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_2274
SELECT id, RTRIM(value) as trimmed FROM test_rtrim ORDER BY id;
-- Tag: cte_cte_test_select_2275
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_2276
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_2277
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_2278
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_2279
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_2280
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_2281
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_2282
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_2283
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_2284
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_2285
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_2286
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_2287
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_2288
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_2289
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2290
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2291
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2292
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_2293
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_2294
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_2295
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2296
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2297
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2298
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2299
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2300
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_2301
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_2302
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_2303
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS test_replace;
CREATE TABLE test_replace (id INT64, value STRING);
INSERT INTO test_replace VALUES (1, 'hello world');
INSERT INTO test_replace VALUES (2, 'foo bar foo');
INSERT INTO test_replace VALUES (3, 'no match here');
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_2304
SELECT id, REPLACE(value, 'foo', 'baz') as replaced FROM test_replace ORDER BY id;
-- Tag: cte_cte_test_select_2305
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_2306
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_2307
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_2308
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_2309
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_2310
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_2311
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_2312
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_2313
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_2314
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_2315
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_2316
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_2317
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_2318
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2319
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2320
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2321
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_2322
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_2323
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_2324
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2325
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2326
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2327
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2328
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2329
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_2330
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_2331
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_2332
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_2333
SELECT id, CURRENT_DATE() as today FROM test_date;
-- Tag: cte_cte_test_select_2334
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_2335
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_2336
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_2337
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_2338
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_2339
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_2340
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_2341
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_2342
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_2343
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_2344
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_2345
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_2346
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2347
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2348
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2349
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_2350
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_2351
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_2352
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2353
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2354
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2355
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2356
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2357
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_2358
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_2359
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_2360
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS test_timestamp;
CREATE TABLE test_timestamp (id INT64);
INSERT INTO test_timestamp VALUES (1);
DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_2361
SELECT id, CURRENT_TIMESTAMP() as now FROM test_timestamp;
-- Tag: cte_cte_test_select_2362
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_2363
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_2364
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_2365
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_2366
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_2367
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_2368
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_2369
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_2370
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_2371
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_2372
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_2373
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2374
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2375
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2376
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_2377
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_2378
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_2379
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2380
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2381
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2382
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2383
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2384
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_2385
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_2386
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_2387
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS test_starts_with;
CREATE TABLE test_starts_with (id INT64, value STRING);
INSERT INTO test_starts_with VALUES (1, 'hello world');
INSERT INTO test_starts_with VALUES (2, 'goodbye world');
INSERT INTO test_starts_with VALUES (3, 'hello universe');
DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_2388
SELECT id FROM test_starts_with WHERE STARTS_WITH(value, 'hello') ORDER BY id;
-- Tag: cte_cte_test_select_2389
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_2390
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_2391
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_2392
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_2393
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_2394
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_2395
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_2396
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_2397
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_2398
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_2399
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2400
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2401
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2402
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_2403
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_2404
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_2405
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2406
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2407
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2408
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2409
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2410
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_2411
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_2412
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_2413
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS test_ends_with;
CREATE TABLE test_ends_with (id INT64, value STRING);
INSERT INTO test_ends_with VALUES (1, 'hello world');
INSERT INTO test_ends_with VALUES (2, 'hello universe');
INSERT INTO test_ends_with VALUES (3, 'goodbye world');
DROP TABLE IF EXISTS test_sign;
CREATE TABLE test_sign (id INT64, value INT64);
INSERT INTO test_sign VALUES (1, 10);
INSERT INTO test_sign VALUES (2, -5);
INSERT INTO test_sign VALUES (3, 0);
DROP TABLE IF EXISTS test_greatest;
CREATE TABLE test_greatest (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_greatest VALUES (1, 10, 20, 15);
INSERT INTO test_greatest VALUES (2, 5, 3, 8);
INSERT INTO test_greatest VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_least;
CREATE TABLE test_least (id INT64, val1 INT64, val2 INT64, val3 INT64);
INSERT INTO test_least VALUES (1, 10, 20, 15);
INSERT INTO test_least VALUES (2, 5, 3, 8);
INSERT INTO test_least VALUES (3, -1, -5, -3);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_date;
CREATE TABLE test_date (id INT64);
INSERT INTO test_date VALUES (1);
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, email STRING);
INSERT INTO test_regex VALUES (1, 'user@example.com');
INSERT INTO test_regex VALUES (2, 'invalid-email');
INSERT INTO test_regex VALUES (3, 'admin@test.org');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, phone STRING);
INSERT INTO test_regex VALUES (1, '123-456-7890');
INSERT INTO test_regex VALUES (2, '987-654-3210');
DROP TABLE IF EXISTS test_regex;
CREATE TABLE test_regex (id INT64, code STRING);
INSERT INTO test_regex VALUES (1, 'Error: 404 - Not Found');
INSERT INTO test_regex VALUES (2, 'Error: 500 - Server Error');
INSERT INTO test_regex VALUES (3, 'Success: OK');
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64);
INSERT INTO test_dates VALUES (1);
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64);
INSERT INTO test_timestamps VALUES (1);
DROP TABLE IF EXISTS test_dates;
CREATE TABLE test_dates (id INT64, date_str STRING);
INSERT INTO test_dates VALUES (1, '2024-03-15');
DROP TABLE IF EXISTS test_timestamps;
CREATE TABLE test_timestamps (id INT64, ts_str STRING);
INSERT INTO test_timestamps VALUES (1, '2024-03-15 14:30:45');
DROP TABLE IF EXISTS test_split;
CREATE TABLE test_split (id INT64, text STRING);
INSERT INTO test_split VALUES (1, 'apple,banana,cherry');
INSERT INTO test_split VALUES (2, 'one-two-three');
DROP TABLE IF EXISTS test_split_null;
CREATE TABLE test_split_null (id INT64, text STRING);
INSERT INTO test_split_null VALUES (1, NULL);
INSERT INTO test_split_null VALUES (2, 'valid,string');
DROP TABLE IF EXISTS test_arrays;
CREATE TABLE test_arrays (id INT64, text STRING);
INSERT INTO test_arrays VALUES (1, 'a,b,c');
INSERT INTO test_arrays VALUES (2, 'x');
INSERT INTO test_arrays VALUES (3, 'one,two');
DROP TABLE IF EXISTS test_combined;
CREATE TABLE test_combined (id INT64, csv STRING);
INSERT INTO test_combined VALUES (1, 'a,b,c,d');
INSERT INTO test_combined VALUES (2, 'x,y');

-- Tag: cte_cte_test_select_2414
SELECT id FROM test_ends_with WHERE ENDS_WITH(value, 'world') ORDER BY id;
-- Tag: cte_cte_test_select_2415
SELECT id FROM test_sign WHERE SIGN(value) = 1;
-- Tag: cte_cte_test_select_2416
SELECT id FROM test_sign WHERE SIGN(value) = -1;
-- Tag: cte_cte_test_select_2417
SELECT id FROM test_sign WHERE SIGN(value) = 0;
-- Tag: cte_cte_test_select_2418
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 20;
-- Tag: cte_cte_test_select_2419
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = 8;
-- Tag: cte_cte_test_select_2420
SELECT id FROM test_greatest WHERE GREATEST(val1, val2, val3) = -1;
-- Tag: cte_cte_test_select_2421
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 10;
-- Tag: cte_cte_test_select_2422
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = 3;
-- Tag: cte_cte_test_select_2423
SELECT id FROM test_least WHERE LEAST(val1, val2, val3) = -5;
-- Tag: cte_cte_test_select_2424
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2425
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2426
SELECT id FROM test_date WHERE 1 = 1;
-- Tag: cte_cte_test_select_2427
SELECT id FROM test_regex WHERE REGEXP_CONTAINS(email, '@.*\.com$');
-- Tag: cte_cte_test_select_2428
SELECT id FROM test_regex WHERE REGEXP_REPLACE(phone, '-', '') = '1234567890';
-- Tag: cte_cte_test_select_2429
SELECT id FROM test_regex WHERE REGEXP_EXTRACT(code, 'Error: ([0-9]+)') = '404';
-- Tag: cte_cte_test_select_2430
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2431
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2432
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2433
SELECT id FROM test_dates WHERE 1 = 1;
-- Tag: cte_cte_test_select_2434
SELECT id FROM test_timestamps WHERE 1 = 1;
-- Tag: cte_cte_test_select_2435
SELECT id FROM test_split WHERE id = 1;
-- Tag: cte_cte_test_select_2436
SELECT id FROM test_split_null WHERE id = 1;
-- Tag: cte_cte_test_select_2437
SELECT id FROM test_arrays WHERE id = 1;
-- Tag: cte_cte_test_select_2438
SELECT id FROM test_combined WHERE id = 1;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (NULL), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (42), (42), (42), (42);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('Alice'), ('Bob'), ('Alice'), ('Charlie'), ('Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (42), (42), (42);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (30), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (42.0), (42.0), (42.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2439
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2440
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2441
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2442
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2443
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2444
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2445
SELECT COUNT(DISTINCT name) FROM data;
-- Tag: cte_cte_test_select_2446
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2447
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2448
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2449
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2450
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2451
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2452
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2453
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2454
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2455
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2456
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2457
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2458
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2459
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2460
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2461
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2462
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2463
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2464
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2465
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2466
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2467
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2468
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2469
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2470
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2471
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2472
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_2473
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_2474
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_2475
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_2476
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_2477
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2478
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (NULL), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (42), (42), (42), (42);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('Alice'), ('Bob'), ('Alice'), ('Charlie'), ('Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (42), (42), (42);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (30), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (42.0), (42.0), (42.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2479
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2480
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2481
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2482
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2483
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2484
SELECT COUNT(DISTINCT name) FROM data;
-- Tag: cte_cte_test_select_2485
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2486
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2487
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2488
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2489
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2490
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2491
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2492
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2493
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2494
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2495
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2496
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2497
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2498
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2499
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2500
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2501
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2502
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2503
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2504
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2505
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2506
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2507
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2508
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2509
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2510
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2511
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_2512
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_2513
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_2514
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_2515
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_2516
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2517
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (42), (42), (42), (42);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('Alice'), ('Bob'), ('Alice'), ('Charlie'), ('Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (42), (42), (42);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (30), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (42.0), (42.0), (42.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2518
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2519
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2520
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2521
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2522
SELECT COUNT(DISTINCT name) FROM data;
-- Tag: cte_cte_test_select_2523
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2524
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2525
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2526
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2527
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2528
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2529
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2530
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2531
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2532
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2533
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2534
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2535
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2536
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2537
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2538
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2539
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2540
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2541
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2542
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2543
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2544
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2545
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2546
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2547
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2548
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2549
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_2550
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_2551
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_2552
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_2553
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_2554
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2555
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('Alice'), ('Bob'), ('Alice'), ('Charlie'), ('Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (42), (42), (42);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (30), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (42.0), (42.0), (42.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2556
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2557
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2558
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2559
SELECT COUNT(DISTINCT name) FROM data;
-- Tag: cte_cte_test_select_2560
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2561
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2562
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2563
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2564
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2565
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2566
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2567
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2568
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2569
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2570
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2571
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2572
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2573
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2574
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2575
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2576
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2577
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2578
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2579
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2580
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2581
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2582
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2583
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2584
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2585
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2586
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_2587
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_2588
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_2589
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_2590
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_2591
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2592
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('Alice'), ('Bob'), ('Alice'), ('Charlie'), ('Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (42), (42), (42);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (30), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (42.0), (42.0), (42.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2593
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2594
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2595
SELECT COUNT(DISTINCT name) FROM data;
-- Tag: cte_cte_test_select_2596
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2597
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2598
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2599
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2600
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2601
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2602
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2603
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2604
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2605
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2606
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2607
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2608
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2609
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2610
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2611
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2612
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2613
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2614
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2615
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2616
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2617
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2618
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2619
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2620
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2621
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2622
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_2623
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_2624
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_2625
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_2626
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_2627
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2628
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('Alice'), ('Bob'), ('Alice'), ('Charlie'), ('Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (42), (42), (42);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (30), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (42.0), (42.0), (42.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2629
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2630
SELECT COUNT(DISTINCT name) FROM data;
-- Tag: cte_cte_test_select_2631
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2632
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2633
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2634
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2635
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2636
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2637
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2638
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2639
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2640
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2641
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2642
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2643
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2644
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2645
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2646
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2647
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2648
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2649
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2650
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2651
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2652
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2653
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2654
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2655
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2656
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2657
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_2658
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_2659
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_2660
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_2661
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_2662
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2663
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('Alice'), ('Bob'), ('Alice'), ('Charlie'), ('Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (42), (42), (42);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (30), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (42.0), (42.0), (42.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2664
SELECT COUNT(DISTINCT name) FROM data;
-- Tag: cte_cte_test_select_2665
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2666
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2667
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2668
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2669
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2670
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2671
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2672
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2673
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2674
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2675
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2676
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2677
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2678
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2679
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2680
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2681
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2682
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2683
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2684
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2685
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2686
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2687
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2688
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2689
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2690
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2691
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_2692
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_2693
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_2694
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_2695
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_2696
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2697
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (42), (42), (42);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (30), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (42.0), (42.0), (42.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2698
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2699
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2700
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2701
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2702
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2703
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2704
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2705
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2706
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2707
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2708
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2709
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2710
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2711
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2712
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2713
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2714
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2715
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2716
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2717
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2718
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2719
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2720
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2721
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2722
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2723
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2724
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_2725
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_2726
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_2727
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_2728
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_2729
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2730
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (42), (42), (42);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (30), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (42.0), (42.0), (42.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2731
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2732
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2733
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2734
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2735
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2736
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2737
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2738
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2739
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2740
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2741
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2742
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2743
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2744
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2745
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2746
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2747
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2748
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2749
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2750
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2751
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2752
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2753
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2754
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2755
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2756
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_2757
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_2758
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_2759
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_2760
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_2761
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2762
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (42), (42), (42);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (30), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (42.0), (42.0), (42.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2763
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2764
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2765
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2766
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2767
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2768
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2769
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2770
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2771
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2772
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2773
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2774
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2775
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2776
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2777
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2778
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2779
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2780
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2781
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2782
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2783
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2784
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2785
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2786
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2787
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_2788
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_2789
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_2790
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_2791
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_2792
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2793
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (42), (42), (42);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (30), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (42.0), (42.0), (42.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2794
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2795
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2796
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2797
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2798
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2799
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2800
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2801
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2802
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2803
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2804
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2805
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2806
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2807
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2808
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2809
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2810
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2811
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2812
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2813
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2814
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2815
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2816
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2817
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_2818
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_2819
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_2820
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_2821
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_2822
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2823
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (30), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (42.0), (42.0), (42.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2824
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2825
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2826
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2827
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2828
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2829
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2830
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2831
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2832
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2833
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2834
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2835
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2836
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2837
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2838
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2839
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2840
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2841
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2842
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2843
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2844
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2845
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2846
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_2847
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_2848
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_2849
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_2850
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_2851
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2852
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (1.5), (2.5), (1.5), (3.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (30), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (42.0), (42.0), (42.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2853
SELECT SUM(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2854
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2855
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2856
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2857
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2858
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2859
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2860
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2861
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2862
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2863
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2864
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2865
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2866
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2867
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2868
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2869
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2870
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2871
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2872
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2873
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2874
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_2875
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_2876
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_2877
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_2878
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_2879
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2880
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (30), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (42.0), (42.0), (42.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2881
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2882
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2883
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2884
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2885
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2886
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2887
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2888
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2889
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2890
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2891
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2892
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2893
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2894
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2895
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2896
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2897
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2898
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2899
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2900
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2901
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_2902
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_2903
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_2904
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_2905
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_2906
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2907
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (10), (30), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (42.0), (42.0), (42.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2908
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2909
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2910
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2911
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2912
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2913
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2914
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2915
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2916
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2917
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2918
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2919
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2920
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2921
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2922
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2923
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2924
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2925
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2926
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2927
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_2928
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_2929
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_2930
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_2931
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_2932
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2933
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (42.0), (42.0), (42.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2934
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2935
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2936
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2937
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2938
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2939
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2940
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2941
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2942
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2943
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2944
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2945
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2946
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2947
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2948
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2949
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2950
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2951
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2952
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_2953
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_2954
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_2955
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_2956
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_2957
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2958
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value FLOAT64);
INSERT INTO data VALUES (NULL), (NULL), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2959
SELECT AVG(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2960
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2961
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2962
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2963
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2964
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2965
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2966
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2967
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2968
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2969
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2970
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2971
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2972
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2973
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2974
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2975
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2976
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_2977
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_2978
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_2979
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_2980
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_2981
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2982
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_2983
SELECT MIN(DISTINCT value) as min_distinct, MIN(value) as min_regular FROM data;
-- Tag: cte_cte_test_select_2984
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_2985
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2986
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_2987
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2988
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2989
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_2990
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_2991
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_2992
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_2993
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_2994
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2995
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2996
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_2997
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_2998
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_2999
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_3000
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3001
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3002
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3003
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3004
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3005
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3006
SELECT MAX(DISTINCT value) as max_distinct, MAX(value) as max_regular FROM data;
-- Tag: cte_cte_test_select_3007
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3008
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3009
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_3010
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_3011
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_3012
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_3013
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_3014
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_3015
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_3016
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3017
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3018
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3019
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_3020
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_3021
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_3022
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3023
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3024
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3025
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3026
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3027
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3028
SELECT MIN(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3029
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3030
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_3031
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_3032
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_3033
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_3034
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_3035
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_3036
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_3037
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3038
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3039
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3040
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_3041
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_3042
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_3043
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3044
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3045
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3046
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3047
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3048
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20), (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3049
SELECT MAX(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3050
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_3051
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_3052
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_3053
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_3054
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_3055
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_3056
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_3057
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3058
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3059
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3060
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_3061
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_3062
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_3063
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3064
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3065
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3066
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3067
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3068
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3069
SELECT COUNT(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_3070
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_3071
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_3072
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_3073
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_3074
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_3075
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_3076
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3077
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3078
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3079
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_3080
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_3081
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_3082
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3083
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3084
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3085
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3086
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3087
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3088
SELECT SUM(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_3089
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_3090
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_3091
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_3092
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_3093
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_3094
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3095
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3096
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3097
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_3098
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_3099
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_3100
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3101
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3102
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3103
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3104
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3105
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (5), (15);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3106
SELECT AVG(DISTINCT value * 2) FROM data;
-- Tag: cte_cte_test_select_3107
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_3108
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_3109
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_3110
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_3111
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3112
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3113
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3114
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_3115
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_3116
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_3117
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3118
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3119
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3120
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3121
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3122
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5), (10), (15), (20), (25);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3123
SELECT COUNT(DISTINCT CASE WHEN value > 10 THEN 'high' ELSE 'low' END) FROM data;
-- Tag: cte_cte_test_select_3124
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_3125
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_3126
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_3127
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3128
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3129
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3130
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_3131
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_3132
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_3133
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3134
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3135
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3136
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3137
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3138
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING);
INSERT INTO data VALUES ('alice'), ('ALICE'), ('bob'), ('BOB');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3139
SELECT COUNT(DISTINCT UPPER(name)) FROM data;
-- Tag: cte_cte_test_select_3140
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_3141
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_3142
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3143
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3144
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3145
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_3146
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_3147
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_3148
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3149
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3150
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3151
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3152
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3153
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 'East', 100.0), ('A', 'West', 150.0), ('B', 'East', 200.0), ('B', 'East', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3154
SELECT COUNT(DISTINCT product) as products, COUNT(DISTINCT region) as regions, SUM(DISTINCT amount) as unique_amounts FROM sales;
-- Tag: cte_cte_test_select_3155
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_3156
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3157
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3158
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3159
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_3160
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_3161
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_3162
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3163
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3164
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3165
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3166
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3167
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3168
SELECT COUNT(DISTINCT value) as unique_count, COUNT(value) as total_count, SUM(DISTINCT value) as unique_sum, SUM(value) as total_sum FROM data;
-- Tag: cte_cte_test_select_3169
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3170
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3171
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3172
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_3173
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_3174
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_3175
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3176
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3177
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3178
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3179
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3180
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Phone'), ('Clothing', 'Shirt'), ('Clothing', 'Pants'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3181
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3182
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3183
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3184
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_3185
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_3186
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_3187
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3188
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3189
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3190
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3191
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3192
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30), ('B', 40), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3193
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3194
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3195
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_3196
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_3197
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_3198
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3199
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3200
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3201
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3202
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3203
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value FLOAT64);
INSERT INTO data VALUES ('A', 10.0), ('A', 20.0), ('A', 10.0), ('B', 30.0), ('B', 40.0), ('B', 30.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3204
SELECT category, AVG(DISTINCT value) as unique_avg FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3205
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_3206
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_3207
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_3208
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3209
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3210
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3211
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3212
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3213
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Clothing', 'Shirt');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3214
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category HAVING COUNT(DISTINCT product) > 1 ORDER BY category;
-- Tag: cte_cte_test_select_3215
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_3216
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_3217
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3218
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3219
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3220
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3221
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3222
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 5), ('B', 5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3223
SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category HAVING SUM(DISTINCT value) > 10 ORDER BY category;
-- Tag: cte_cte_test_select_3224
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_3225
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3226
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3227
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3228
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3229
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3230
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, product STRING);
INSERT INTO sales VALUES ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Electronics', 'Tablet'), ('Clothing', 'Shirt'), ('Food', 'Apple'), ('Food', 'Banana');
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3231
SELECT category, COUNT(DISTINCT product) as unique_products FROM sales GROUP BY category ORDER BY COUNT(DISTINCT product) DESC;
-- Tag: cte_cte_test_select_3232
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3233
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3234
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3235
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3236
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3237
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3238
SELECT category, COUNT(DISTINCT value) as unique_count FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3239
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3240
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3241
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3242
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3243
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 10), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

-- Tag: cte_cte_test_select_3244
SELECT * FROM ( SELECT category, SUM(DISTINCT value) as unique_sum FROM data GROUP BY category ) AS sub WHERE unique_sum > 20 ORDER BY category;
WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3245
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3246
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3247
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3248
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (20), (10), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3);

WITH unique_stats AS ( SELECT COUNT(DISTINCT value) as unique_count, SUM(DISTINCT value) as unique_sum FROM data ) SELECT unique_count, unique_sum FROM unique_stats;
-- Tag: cte_cte_test_select_3249
SELECT COUNT(DISTINCT *) FROM data;
-- Tag: cte_cte_test_select_3250
SELECT COUNT(DISTINCT SUM(DISTINCT value)) FROM data;
-- Tag: cte_cte_test_select_3251
SELECT COUNT(DISTINCT value) FROM data;
-- Tag: cte_cte_test_select_3252
SELECT SUM(DISTINCT value) FROM data;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);

WITH cte AS (SELECT * FROM data) SELECT * FROM nonexistent_cte;

DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS t;
CREATE TABLE t (column_name INT64);
DROP TABLE IF EXISTS t;
CREATE TABLE t (id INT64);
INSERT INTO t VALUES (1);
DROP TABLE IF EXISTS t;
CREATE TABLE t (id INT64);

WITH cte AS (SELECT * FROM cte) SELECT * FROM cte;
-- Tag: cte_cte_test_select_3253
SELECT val as v FROM t ORDER BY nonexistent;
-- Tag: cte_cte_test_select_3254
SELECT nonexistent_column FROM users;
-- Tag: cte_cte_test_select_3255
SELECT colum_name FROM t;
-- Tag: cte_cte_test_select_3256
SELECT * FROM t LIMIT 999999999999999;
-- Tag: cte_cte_test_select_3257
SELECT * FROM t LIMIT -1;

DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (2, 200.0);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10);
INSERT INTO test VALUES (2, 20);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS a;
CREATE TABLE a (id INT64, value STRING);
DROP TABLE IF EXISTS b;
CREATE TABLE b (id INT64, a_id INT64, data STRING);
DROP TABLE IF EXISTS c;
CREATE TABLE c (id INT64, b_id INT64, info STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (category STRING, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, price FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, message STRING);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN SELECT * FROM users;
EXPLAIN SELECT * FROM products WHERE price > 100;
EXPLAIN SELECT * FROM test;
-- Tag: cte_cte_test_select_3258
SELECT COUNT(*) as cnt FROM test;
EXPLAIN ANALYZE SELECT * FROM orders;
EXPLAIN ANALYZE SELECT * FROM test WHERE value > 15;
EXPLAIN ANALYZE INSERT INTO test VALUES (1, 'test');
EXPLAIN SELECT c.name, o.total FROM customers c INNER JOIN orders o ON c.id = o.customer_id;
EXPLAIN SELECT * FROM a JOIN b ON a.id = b.a_id JOIN c ON b.id = c.b_id;
EXPLAIN SELECT * FROM t1 CROSS JOIN t2;
EXPLAIN SELECT region, SUM(amount) as total FROM sales GROUP BY region;
EXPLAIN SELECT category, SUM(amount) as total FROM sales GROUP BY category HAVING SUM(amount) > 1000;
EXPLAIN SELECT DISTINCT category FROM products;
EXPLAIN SELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE name = 'Alice');
EXPLAIN SELECT * FROM orders o WHERE total > (SELECT AVG(price) FROM order_items WHERE order_id = o.id);
EXPLAIN SELECT * FROM customers c WHERE EXISTS (SELECT 1 FROM orders WHERE customer_id = c.id);
EXPLAIN SELECT * FROM products ORDER BY price DESC;
EXPLAIN SELECT * FROM logs LIMIT 10;
EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (2, 200.0);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10);
INSERT INTO test VALUES (2, 20);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS a;
CREATE TABLE a (id INT64, value STRING);
DROP TABLE IF EXISTS b;
CREATE TABLE b (id INT64, a_id INT64, data STRING);
DROP TABLE IF EXISTS c;
CREATE TABLE c (id INT64, b_id INT64, info STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (category STRING, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, price FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, message STRING);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN SELECT * FROM products WHERE price > 100;
EXPLAIN SELECT * FROM test;
-- Tag: cte_cte_test_select_3259
SELECT COUNT(*) as cnt FROM test;
EXPLAIN ANALYZE SELECT * FROM orders;
EXPLAIN ANALYZE SELECT * FROM test WHERE value > 15;
EXPLAIN ANALYZE INSERT INTO test VALUES (1, 'test');
EXPLAIN SELECT c.name, o.total FROM customers c INNER JOIN orders o ON c.id = o.customer_id;
EXPLAIN SELECT * FROM a JOIN b ON a.id = b.a_id JOIN c ON b.id = c.b_id;
EXPLAIN SELECT * FROM t1 CROSS JOIN t2;
EXPLAIN SELECT region, SUM(amount) as total FROM sales GROUP BY region;
EXPLAIN SELECT category, SUM(amount) as total FROM sales GROUP BY category HAVING SUM(amount) > 1000;
EXPLAIN SELECT DISTINCT category FROM products;
EXPLAIN SELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE name = 'Alice');
EXPLAIN SELECT * FROM orders o WHERE total > (SELECT AVG(price) FROM order_items WHERE order_id = o.id);
EXPLAIN SELECT * FROM customers c WHERE EXISTS (SELECT 1 FROM orders WHERE customer_id = c.id);
EXPLAIN SELECT * FROM products ORDER BY price DESC;
EXPLAIN SELECT * FROM logs LIMIT 10;
EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (2, 200.0);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10);
INSERT INTO test VALUES (2, 20);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS a;
CREATE TABLE a (id INT64, value STRING);
DROP TABLE IF EXISTS b;
CREATE TABLE b (id INT64, a_id INT64, data STRING);
DROP TABLE IF EXISTS c;
CREATE TABLE c (id INT64, b_id INT64, info STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (category STRING, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, price FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, message STRING);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN SELECT * FROM test;
-- Tag: cte_cte_test_select_3260
SELECT COUNT(*) as cnt FROM test;
EXPLAIN ANALYZE SELECT * FROM orders;
EXPLAIN ANALYZE SELECT * FROM test WHERE value > 15;
EXPLAIN ANALYZE INSERT INTO test VALUES (1, 'test');
EXPLAIN SELECT c.name, o.total FROM customers c INNER JOIN orders o ON c.id = o.customer_id;
EXPLAIN SELECT * FROM a JOIN b ON a.id = b.a_id JOIN c ON b.id = c.b_id;
EXPLAIN SELECT * FROM t1 CROSS JOIN t2;
EXPLAIN SELECT region, SUM(amount) as total FROM sales GROUP BY region;
EXPLAIN SELECT category, SUM(amount) as total FROM sales GROUP BY category HAVING SUM(amount) > 1000;
EXPLAIN SELECT DISTINCT category FROM products;
EXPLAIN SELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE name = 'Alice');
EXPLAIN SELECT * FROM orders o WHERE total > (SELECT AVG(price) FROM order_items WHERE order_id = o.id);
EXPLAIN SELECT * FROM customers c WHERE EXISTS (SELECT 1 FROM orders WHERE customer_id = c.id);
EXPLAIN SELECT * FROM products ORDER BY price DESC;
EXPLAIN SELECT * FROM logs LIMIT 10;
EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (2, 200.0);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10);
INSERT INTO test VALUES (2, 20);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS a;
CREATE TABLE a (id INT64, value STRING);
DROP TABLE IF EXISTS b;
CREATE TABLE b (id INT64, a_id INT64, data STRING);
DROP TABLE IF EXISTS c;
CREATE TABLE c (id INT64, b_id INT64, info STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (category STRING, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, price FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, message STRING);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN ANALYZE SELECT * FROM orders;
EXPLAIN ANALYZE SELECT * FROM test WHERE value > 15;
EXPLAIN ANALYZE INSERT INTO test VALUES (1, 'test');
EXPLAIN SELECT c.name, o.total FROM customers c INNER JOIN orders o ON c.id = o.customer_id;
EXPLAIN SELECT * FROM a JOIN b ON a.id = b.a_id JOIN c ON b.id = c.b_id;
EXPLAIN SELECT * FROM t1 CROSS JOIN t2;
EXPLAIN SELECT region, SUM(amount) as total FROM sales GROUP BY region;
EXPLAIN SELECT category, SUM(amount) as total FROM sales GROUP BY category HAVING SUM(amount) > 1000;
EXPLAIN SELECT DISTINCT category FROM products;
EXPLAIN SELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE name = 'Alice');
EXPLAIN SELECT * FROM orders o WHERE total > (SELECT AVG(price) FROM order_items WHERE order_id = o.id);
EXPLAIN SELECT * FROM customers c WHERE EXISTS (SELECT 1 FROM orders WHERE customer_id = c.id);
EXPLAIN SELECT * FROM products ORDER BY price DESC;
EXPLAIN SELECT * FROM logs LIMIT 10;
EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10);
INSERT INTO test VALUES (2, 20);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS a;
CREATE TABLE a (id INT64, value STRING);
DROP TABLE IF EXISTS b;
CREATE TABLE b (id INT64, a_id INT64, data STRING);
DROP TABLE IF EXISTS c;
CREATE TABLE c (id INT64, b_id INT64, info STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (category STRING, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, price FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, message STRING);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN ANALYZE SELECT * FROM test WHERE value > 15;
EXPLAIN ANALYZE INSERT INTO test VALUES (1, 'test');
EXPLAIN SELECT c.name, o.total FROM customers c INNER JOIN orders o ON c.id = o.customer_id;
EXPLAIN SELECT * FROM a JOIN b ON a.id = b.a_id JOIN c ON b.id = c.b_id;
EXPLAIN SELECT * FROM t1 CROSS JOIN t2;
EXPLAIN SELECT region, SUM(amount) as total FROM sales GROUP BY region;
EXPLAIN SELECT category, SUM(amount) as total FROM sales GROUP BY category HAVING SUM(amount) > 1000;
EXPLAIN SELECT DISTINCT category FROM products;
EXPLAIN SELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE name = 'Alice');
EXPLAIN SELECT * FROM orders o WHERE total > (SELECT AVG(price) FROM order_items WHERE order_id = o.id);
EXPLAIN SELECT * FROM customers c WHERE EXISTS (SELECT 1 FROM orders WHERE customer_id = c.id);
EXPLAIN SELECT * FROM products ORDER BY price DESC;
EXPLAIN SELECT * FROM logs LIMIT 10;
EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS a;
CREATE TABLE a (id INT64, value STRING);
DROP TABLE IF EXISTS b;
CREATE TABLE b (id INT64, a_id INT64, data STRING);
DROP TABLE IF EXISTS c;
CREATE TABLE c (id INT64, b_id INT64, info STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (category STRING, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, price FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, message STRING);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN ANALYZE INSERT INTO test VALUES (1, 'test');
EXPLAIN SELECT c.name, o.total FROM customers c INNER JOIN orders o ON c.id = o.customer_id;
EXPLAIN SELECT * FROM a JOIN b ON a.id = b.a_id JOIN c ON b.id = c.b_id;
EXPLAIN SELECT * FROM t1 CROSS JOIN t2;
EXPLAIN SELECT region, SUM(amount) as total FROM sales GROUP BY region;
EXPLAIN SELECT category, SUM(amount) as total FROM sales GROUP BY category HAVING SUM(amount) > 1000;
EXPLAIN SELECT DISTINCT category FROM products;
EXPLAIN SELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE name = 'Alice');
EXPLAIN SELECT * FROM orders o WHERE total > (SELECT AVG(price) FROM order_items WHERE order_id = o.id);
EXPLAIN SELECT * FROM customers c WHERE EXISTS (SELECT 1 FROM orders WHERE customer_id = c.id);
EXPLAIN SELECT * FROM products ORDER BY price DESC;
EXPLAIN SELECT * FROM logs LIMIT 10;
EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS a;
CREATE TABLE a (id INT64, value STRING);
DROP TABLE IF EXISTS b;
CREATE TABLE b (id INT64, a_id INT64, data STRING);
DROP TABLE IF EXISTS c;
CREATE TABLE c (id INT64, b_id INT64, info STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (category STRING, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, price FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, message STRING);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN SELECT c.name, o.total FROM customers c INNER JOIN orders o ON c.id = o.customer_id;
EXPLAIN SELECT * FROM a JOIN b ON a.id = b.a_id JOIN c ON b.id = c.b_id;
EXPLAIN SELECT * FROM t1 CROSS JOIN t2;
EXPLAIN SELECT region, SUM(amount) as total FROM sales GROUP BY region;
EXPLAIN SELECT category, SUM(amount) as total FROM sales GROUP BY category HAVING SUM(amount) > 1000;
EXPLAIN SELECT DISTINCT category FROM products;
EXPLAIN SELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE name = 'Alice');
EXPLAIN SELECT * FROM orders o WHERE total > (SELECT AVG(price) FROM order_items WHERE order_id = o.id);
EXPLAIN SELECT * FROM customers c WHERE EXISTS (SELECT 1 FROM orders WHERE customer_id = c.id);
EXPLAIN SELECT * FROM products ORDER BY price DESC;
EXPLAIN SELECT * FROM logs LIMIT 10;
EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS a;
CREATE TABLE a (id INT64, value STRING);
DROP TABLE IF EXISTS b;
CREATE TABLE b (id INT64, a_id INT64, data STRING);
DROP TABLE IF EXISTS c;
CREATE TABLE c (id INT64, b_id INT64, info STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (category STRING, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, price FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, message STRING);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN SELECT * FROM a JOIN b ON a.id = b.a_id JOIN c ON b.id = c.b_id;
EXPLAIN SELECT * FROM t1 CROSS JOIN t2;
EXPLAIN SELECT region, SUM(amount) as total FROM sales GROUP BY region;
EXPLAIN SELECT category, SUM(amount) as total FROM sales GROUP BY category HAVING SUM(amount) > 1000;
EXPLAIN SELECT DISTINCT category FROM products;
EXPLAIN SELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE name = 'Alice');
EXPLAIN SELECT * FROM orders o WHERE total > (SELECT AVG(price) FROM order_items WHERE order_id = o.id);
EXPLAIN SELECT * FROM customers c WHERE EXISTS (SELECT 1 FROM orders WHERE customer_id = c.id);
EXPLAIN SELECT * FROM products ORDER BY price DESC;
EXPLAIN SELECT * FROM logs LIMIT 10;
EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (category STRING, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, price FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, message STRING);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN SELECT * FROM t1 CROSS JOIN t2;
EXPLAIN SELECT region, SUM(amount) as total FROM sales GROUP BY region;
EXPLAIN SELECT category, SUM(amount) as total FROM sales GROUP BY category HAVING SUM(amount) > 1000;
EXPLAIN SELECT DISTINCT category FROM products;
EXPLAIN SELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE name = 'Alice');
EXPLAIN SELECT * FROM orders o WHERE total > (SELECT AVG(price) FROM order_items WHERE order_id = o.id);
EXPLAIN SELECT * FROM customers c WHERE EXISTS (SELECT 1 FROM orders WHERE customer_id = c.id);
EXPLAIN SELECT * FROM products ORDER BY price DESC;
EXPLAIN SELECT * FROM logs LIMIT 10;
EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (category STRING, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, price FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, message STRING);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN SELECT region, SUM(amount) as total FROM sales GROUP BY region;
EXPLAIN SELECT category, SUM(amount) as total FROM sales GROUP BY category HAVING SUM(amount) > 1000;
EXPLAIN SELECT DISTINCT category FROM products;
EXPLAIN SELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE name = 'Alice');
EXPLAIN SELECT * FROM orders o WHERE total > (SELECT AVG(price) FROM order_items WHERE order_id = o.id);
EXPLAIN SELECT * FROM customers c WHERE EXISTS (SELECT 1 FROM orders WHERE customer_id = c.id);
EXPLAIN SELECT * FROM products ORDER BY price DESC;
EXPLAIN SELECT * FROM logs LIMIT 10;
EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (category STRING, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, price FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, message STRING);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN SELECT category, SUM(amount) as total FROM sales GROUP BY category HAVING SUM(amount) > 1000;
EXPLAIN SELECT DISTINCT category FROM products;
EXPLAIN SELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE name = 'Alice');
EXPLAIN SELECT * FROM orders o WHERE total > (SELECT AVG(price) FROM order_items WHERE order_id = o.id);
EXPLAIN SELECT * FROM customers c WHERE EXISTS (SELECT 1 FROM orders WHERE customer_id = c.id);
EXPLAIN SELECT * FROM products ORDER BY price DESC;
EXPLAIN SELECT * FROM logs LIMIT 10;
EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS products;
CREATE TABLE products (category STRING, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, price FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, message STRING);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN SELECT DISTINCT category FROM products;
EXPLAIN SELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE name = 'Alice');
EXPLAIN SELECT * FROM orders o WHERE total > (SELECT AVG(price) FROM order_items WHERE order_id = o.id);
EXPLAIN SELECT * FROM customers c WHERE EXISTS (SELECT 1 FROM orders WHERE customer_id = c.id);
EXPLAIN SELECT * FROM products ORDER BY price DESC;
EXPLAIN SELECT * FROM logs LIMIT 10;
EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, price FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, message STRING);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN SELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE name = 'Alice');
EXPLAIN SELECT * FROM orders o WHERE total > (SELECT AVG(price) FROM order_items WHERE order_id = o.id);
EXPLAIN SELECT * FROM customers c WHERE EXISTS (SELECT 1 FROM orders WHERE customer_id = c.id);
EXPLAIN SELECT * FROM products ORDER BY price DESC;
EXPLAIN SELECT * FROM logs LIMIT 10;
EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, price FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, message STRING);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN SELECT * FROM orders o WHERE total > (SELECT AVG(price) FROM order_items WHERE order_id = o.id);
EXPLAIN SELECT * FROM customers c WHERE EXISTS (SELECT 1 FROM orders WHERE customer_id = c.id);
EXPLAIN SELECT * FROM products ORDER BY price DESC;
EXPLAIN SELECT * FROM logs LIMIT 10;
EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, message STRING);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN SELECT * FROM customers c WHERE EXISTS (SELECT 1 FROM orders WHERE customer_id = c.id);
EXPLAIN SELECT * FROM products ORDER BY price DESC;
EXPLAIN SELECT * FROM logs LIMIT 10;
EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, message STRING);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN SELECT * FROM products ORDER BY price DESC;
EXPLAIN SELECT * FROM logs LIMIT 10;
EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, message STRING);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN SELECT * FROM logs LIMIT 10;
EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, timestamp TIMESTAMP, data STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN SELECT * FROM events ORDER BY timestamp DESC LIMIT 100;
EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, name STRING);
CREATE INDEX idx_id ON large_table (id);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, data STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value STRING);
CREATE INDEX idx_value ON test (value);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, val INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS large_orders;
CREATE TABLE large_orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);

EXPLAIN WITH regional_totals AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY region ) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN WITH cte1 AS (SELECT * FROM data WHERE value > 10), cte2 AS (SELECT * FROM cte1 WHERE value < 100) SELECT * FROM cte2;
EXPLAIN SELECT * FROM test WHERE id > 100;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT * FROM large_table WHERE id = 500;
EXPLAIN SELECT c.name, COUNT(*) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.name HAVING COUNT(*) > 5 ORDER BY order_count DESC;
EXPLAIN SELECT * FORM users;
EXPLAIN SELECT * FROM nonexistent_table;
EXPLAIN SELECT id FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN SELECT * FROM test WHERE value = 'test';
EXPLAIN ANALYZE SELECT * FROM test;
EXPLAIN SELECT * FROM empty_table;
EXPLAIN SELECT * FROM t1 WHERE id IN ( SELECT id FROM t2 WHERE val > ( SELECT AVG(val) FROM t3 WHERE id IN (SELECT id FROM t1 WHERE val > 10) ) );
EXPLAIN SELECT * FROM test WHERE value IS NULL;
EXPLAIN ANALYZE SELECT c.name, SUM(o.amount) as total FROM customers c JOIN large_orders o ON c.id = o.customer_id GROUP BY c.name;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 100), (2, 200), (3, 300);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, 10), (2, 20), (3, 30);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, category STRING, amount INT64);
INSERT INTO sales VALUES (1, 'A', 100), (2, 'B', 200), (3, 'A', 150), (4, 'B', 250);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64, city STRING);
INSERT INTO users VALUES (1, 25, 'NYC'), (2, 30, 'SF'), (3, 35, 'NYC'), (4, 40, 'LA');
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, data STRING);
DROP TABLE IF EXISTS small;
CREATE TABLE small (id INT64, ref STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS wide_table;
CREATE TABLE wide_table (id INT64, col1 STRING, col2 STRING, col3 INT64, col4 FLOAT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS big;
CREATE TABLE big (id INT64, data STRING);
DROP TABLE IF EXISTS tiny;
CREATE TABLE tiny (id INT64, ref STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 100), (2, 200), (3, 300);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, t1_id INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, t2_id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount INT64, region STRING);
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (id INT64, name STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (id INT64, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, avg_salary INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, date DATE, amount INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);

EXPLAIN ANALYZE SELECT * FROM test WHERE value > 150;
EXPLAIN ANALYZE SELECT t1.id, t1.value, t2.value FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN ANALYZE SELECT category, SUM(amount), COUNT(*) FROM sales GROUP BY category;
EXPLAIN ANALYZE SELECT * FROM users WHERE age > 28 AND city = 'NYC';
EXPLAIN SELECT * FROM test WHERE id = 42;
EXPLAIN SELECT * FROM large JOIN small ON large.id = small.id;
EXPLAIN SELECT c.name FROM customers c JOIN orders o ON c.id = o.customer_id WHERE o.amount > 1000;
EXPLAIN SELECT id, col1 FROM wide_table;
EXPLAIN SELECT * FROM test WHERE value > 100;
EXPLAIN SELECT * FROM big JOIN tiny ON big.id = tiny.id;
EXPLAIN ANALYZE SELECT * FROM test WHERE value > 25;
EXPLAIN ANALYZE SELECT SUM(value) FROM test;
EXPLAIN ANALYZE SELECT id, data FROM test ORDER BY data;
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.id = t2.t1_id JOIN t3 ON t2.id = t3.t2_id;
EXPLAIN WITH regional_totals AS (SELECT region, SUM(amount) as total FROM sales GROUP BY region) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN SELECT name FROM active_users UNION SELECT name FROM inactive_users;
EXPLAIN SELECT e.id FROM employees e WHERE e.salary > (SELECT avg_salary FROM departments d WHERE d.id = e.dept_id);
EXPLAIN SELECT product, AVG(daily_total) FROM (SELECT product, date, SUM(amount) as daily_total FROM sales GROUP BY product, date) GROUP BY product;
EXPLAIN SELECT * FROM test;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN (FORMAT YAML) SELECT * FROM test;
EXPLAIN SELECT * FROM test;
EXPLAIN SELECT 1 + 1 as result;
EXPLAIN INSERT INTO test SELECT id, id * 2 FROM test WHERE id > 10;
EXPLAIN UPDATE test SET value = value * 2 WHERE id > 100;
EXPLAIN DELETE FROM test WHERE value < 10;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, 10), (2, 20), (3, 30);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, category STRING, amount INT64);
INSERT INTO sales VALUES (1, 'A', 100), (2, 'B', 200), (3, 'A', 150), (4, 'B', 250);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64, city STRING);
INSERT INTO users VALUES (1, 25, 'NYC'), (2, 30, 'SF'), (3, 35, 'NYC'), (4, 40, 'LA');
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, data STRING);
DROP TABLE IF EXISTS small;
CREATE TABLE small (id INT64, ref STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS wide_table;
CREATE TABLE wide_table (id INT64, col1 STRING, col2 STRING, col3 INT64, col4 FLOAT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS big;
CREATE TABLE big (id INT64, data STRING);
DROP TABLE IF EXISTS tiny;
CREATE TABLE tiny (id INT64, ref STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 100), (2, 200), (3, 300);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, t1_id INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, t2_id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount INT64, region STRING);
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (id INT64, name STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (id INT64, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, avg_salary INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, date DATE, amount INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);

EXPLAIN ANALYZE SELECT t1.id, t1.value, t2.value FROM t1 JOIN t2 ON t1.id = t2.id;
EXPLAIN ANALYZE SELECT category, SUM(amount), COUNT(*) FROM sales GROUP BY category;
EXPLAIN ANALYZE SELECT * FROM users WHERE age > 28 AND city = 'NYC';
EXPLAIN SELECT * FROM test WHERE id = 42;
EXPLAIN SELECT * FROM large JOIN small ON large.id = small.id;
EXPLAIN SELECT c.name FROM customers c JOIN orders o ON c.id = o.customer_id WHERE o.amount > 1000;
EXPLAIN SELECT id, col1 FROM wide_table;
EXPLAIN SELECT * FROM test WHERE value > 100;
EXPLAIN SELECT * FROM big JOIN tiny ON big.id = tiny.id;
EXPLAIN ANALYZE SELECT * FROM test WHERE value > 25;
EXPLAIN ANALYZE SELECT SUM(value) FROM test;
EXPLAIN ANALYZE SELECT id, data FROM test ORDER BY data;
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.id = t2.t1_id JOIN t3 ON t2.id = t3.t2_id;
EXPLAIN WITH regional_totals AS (SELECT region, SUM(amount) as total FROM sales GROUP BY region) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN SELECT name FROM active_users UNION SELECT name FROM inactive_users;
EXPLAIN SELECT e.id FROM employees e WHERE e.salary > (SELECT avg_salary FROM departments d WHERE d.id = e.dept_id);
EXPLAIN SELECT product, AVG(daily_total) FROM (SELECT product, date, SUM(amount) as daily_total FROM sales GROUP BY product, date) GROUP BY product;
EXPLAIN SELECT * FROM test;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN (FORMAT YAML) SELECT * FROM test;
EXPLAIN SELECT * FROM test;
EXPLAIN SELECT 1 + 1 as result;
EXPLAIN INSERT INTO test SELECT id, id * 2 FROM test WHERE id > 10;
EXPLAIN UPDATE test SET value = value * 2 WHERE id > 100;
EXPLAIN DELETE FROM test WHERE value < 10;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, category STRING, amount INT64);
INSERT INTO sales VALUES (1, 'A', 100), (2, 'B', 200), (3, 'A', 150), (4, 'B', 250);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64, city STRING);
INSERT INTO users VALUES (1, 25, 'NYC'), (2, 30, 'SF'), (3, 35, 'NYC'), (4, 40, 'LA');
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, data STRING);
DROP TABLE IF EXISTS small;
CREATE TABLE small (id INT64, ref STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS wide_table;
CREATE TABLE wide_table (id INT64, col1 STRING, col2 STRING, col3 INT64, col4 FLOAT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS big;
CREATE TABLE big (id INT64, data STRING);
DROP TABLE IF EXISTS tiny;
CREATE TABLE tiny (id INT64, ref STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 100), (2, 200), (3, 300);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, t1_id INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, t2_id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount INT64, region STRING);
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (id INT64, name STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (id INT64, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, avg_salary INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, date DATE, amount INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);

EXPLAIN ANALYZE SELECT category, SUM(amount), COUNT(*) FROM sales GROUP BY category;
EXPLAIN ANALYZE SELECT * FROM users WHERE age > 28 AND city = 'NYC';
EXPLAIN SELECT * FROM test WHERE id = 42;
EXPLAIN SELECT * FROM large JOIN small ON large.id = small.id;
EXPLAIN SELECT c.name FROM customers c JOIN orders o ON c.id = o.customer_id WHERE o.amount > 1000;
EXPLAIN SELECT id, col1 FROM wide_table;
EXPLAIN SELECT * FROM test WHERE value > 100;
EXPLAIN SELECT * FROM big JOIN tiny ON big.id = tiny.id;
EXPLAIN ANALYZE SELECT * FROM test WHERE value > 25;
EXPLAIN ANALYZE SELECT SUM(value) FROM test;
EXPLAIN ANALYZE SELECT id, data FROM test ORDER BY data;
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.id = t2.t1_id JOIN t3 ON t2.id = t3.t2_id;
EXPLAIN WITH regional_totals AS (SELECT region, SUM(amount) as total FROM sales GROUP BY region) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN SELECT name FROM active_users UNION SELECT name FROM inactive_users;
EXPLAIN SELECT e.id FROM employees e WHERE e.salary > (SELECT avg_salary FROM departments d WHERE d.id = e.dept_id);
EXPLAIN SELECT product, AVG(daily_total) FROM (SELECT product, date, SUM(amount) as daily_total FROM sales GROUP BY product, date) GROUP BY product;
EXPLAIN SELECT * FROM test;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN (FORMAT YAML) SELECT * FROM test;
EXPLAIN SELECT * FROM test;
EXPLAIN SELECT 1 + 1 as result;
EXPLAIN INSERT INTO test SELECT id, id * 2 FROM test WHERE id > 10;
EXPLAIN UPDATE test SET value = value * 2 WHERE id > 100;
EXPLAIN DELETE FROM test WHERE value < 10;

DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64, city STRING);
INSERT INTO users VALUES (1, 25, 'NYC'), (2, 30, 'SF'), (3, 35, 'NYC'), (4, 40, 'LA');
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, data STRING);
DROP TABLE IF EXISTS small;
CREATE TABLE small (id INT64, ref STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS wide_table;
CREATE TABLE wide_table (id INT64, col1 STRING, col2 STRING, col3 INT64, col4 FLOAT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS big;
CREATE TABLE big (id INT64, data STRING);
DROP TABLE IF EXISTS tiny;
CREATE TABLE tiny (id INT64, ref STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 100), (2, 200), (3, 300);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, t1_id INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, t2_id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount INT64, region STRING);
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (id INT64, name STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (id INT64, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, avg_salary INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, date DATE, amount INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);

EXPLAIN ANALYZE SELECT * FROM users WHERE age > 28 AND city = 'NYC';
EXPLAIN SELECT * FROM test WHERE id = 42;
EXPLAIN SELECT * FROM large JOIN small ON large.id = small.id;
EXPLAIN SELECT c.name FROM customers c JOIN orders o ON c.id = o.customer_id WHERE o.amount > 1000;
EXPLAIN SELECT id, col1 FROM wide_table;
EXPLAIN SELECT * FROM test WHERE value > 100;
EXPLAIN SELECT * FROM big JOIN tiny ON big.id = tiny.id;
EXPLAIN ANALYZE SELECT * FROM test WHERE value > 25;
EXPLAIN ANALYZE SELECT SUM(value) FROM test;
EXPLAIN ANALYZE SELECT id, data FROM test ORDER BY data;
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.id = t2.t1_id JOIN t3 ON t2.id = t3.t2_id;
EXPLAIN WITH regional_totals AS (SELECT region, SUM(amount) as total FROM sales GROUP BY region) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN SELECT name FROM active_users UNION SELECT name FROM inactive_users;
EXPLAIN SELECT e.id FROM employees e WHERE e.salary > (SELECT avg_salary FROM departments d WHERE d.id = e.dept_id);
EXPLAIN SELECT product, AVG(daily_total) FROM (SELECT product, date, SUM(amount) as daily_total FROM sales GROUP BY product, date) GROUP BY product;
EXPLAIN SELECT * FROM test;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN (FORMAT YAML) SELECT * FROM test;
EXPLAIN SELECT * FROM test;
EXPLAIN SELECT 1 + 1 as result;
EXPLAIN INSERT INTO test SELECT id, id * 2 FROM test WHERE id > 10;
EXPLAIN UPDATE test SET value = value * 2 WHERE id > 100;
EXPLAIN DELETE FROM test WHERE value < 10;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, data STRING);
DROP TABLE IF EXISTS small;
CREATE TABLE small (id INT64, ref STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS wide_table;
CREATE TABLE wide_table (id INT64, col1 STRING, col2 STRING, col3 INT64, col4 FLOAT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS big;
CREATE TABLE big (id INT64, data STRING);
DROP TABLE IF EXISTS tiny;
CREATE TABLE tiny (id INT64, ref STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 100), (2, 200), (3, 300);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, t1_id INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, t2_id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount INT64, region STRING);
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (id INT64, name STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (id INT64, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, avg_salary INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, date DATE, amount INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);

EXPLAIN SELECT * FROM test WHERE id = 42;
EXPLAIN SELECT * FROM large JOIN small ON large.id = small.id;
EXPLAIN SELECT c.name FROM customers c JOIN orders o ON c.id = o.customer_id WHERE o.amount > 1000;
EXPLAIN SELECT id, col1 FROM wide_table;
EXPLAIN SELECT * FROM test WHERE value > 100;
EXPLAIN SELECT * FROM big JOIN tiny ON big.id = tiny.id;
EXPLAIN ANALYZE SELECT * FROM test WHERE value > 25;
EXPLAIN ANALYZE SELECT SUM(value) FROM test;
EXPLAIN ANALYZE SELECT id, data FROM test ORDER BY data;
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.id = t2.t1_id JOIN t3 ON t2.id = t3.t2_id;
EXPLAIN WITH regional_totals AS (SELECT region, SUM(amount) as total FROM sales GROUP BY region) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN SELECT name FROM active_users UNION SELECT name FROM inactive_users;
EXPLAIN SELECT e.id FROM employees e WHERE e.salary > (SELECT avg_salary FROM departments d WHERE d.id = e.dept_id);
EXPLAIN SELECT product, AVG(daily_total) FROM (SELECT product, date, SUM(amount) as daily_total FROM sales GROUP BY product, date) GROUP BY product;
EXPLAIN SELECT * FROM test;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN (FORMAT YAML) SELECT * FROM test;
EXPLAIN SELECT * FROM test;
EXPLAIN SELECT 1 + 1 as result;
EXPLAIN INSERT INTO test SELECT id, id * 2 FROM test WHERE id > 10;
EXPLAIN UPDATE test SET value = value * 2 WHERE id > 100;
EXPLAIN DELETE FROM test WHERE value < 10;

DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, data STRING);
DROP TABLE IF EXISTS small;
CREATE TABLE small (id INT64, ref STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS wide_table;
CREATE TABLE wide_table (id INT64, col1 STRING, col2 STRING, col3 INT64, col4 FLOAT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS big;
CREATE TABLE big (id INT64, data STRING);
DROP TABLE IF EXISTS tiny;
CREATE TABLE tiny (id INT64, ref STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 100), (2, 200), (3, 300);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, t1_id INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, t2_id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount INT64, region STRING);
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (id INT64, name STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (id INT64, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, avg_salary INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, date DATE, amount INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);

EXPLAIN SELECT * FROM large JOIN small ON large.id = small.id;
EXPLAIN SELECT c.name FROM customers c JOIN orders o ON c.id = o.customer_id WHERE o.amount > 1000;
EXPLAIN SELECT id, col1 FROM wide_table;
EXPLAIN SELECT * FROM test WHERE value > 100;
EXPLAIN SELECT * FROM big JOIN tiny ON big.id = tiny.id;
EXPLAIN ANALYZE SELECT * FROM test WHERE value > 25;
EXPLAIN ANALYZE SELECT SUM(value) FROM test;
EXPLAIN ANALYZE SELECT id, data FROM test ORDER BY data;
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.id = t2.t1_id JOIN t3 ON t2.id = t3.t2_id;
EXPLAIN WITH regional_totals AS (SELECT region, SUM(amount) as total FROM sales GROUP BY region) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN SELECT name FROM active_users UNION SELECT name FROM inactive_users;
EXPLAIN SELECT e.id FROM employees e WHERE e.salary > (SELECT avg_salary FROM departments d WHERE d.id = e.dept_id);
EXPLAIN SELECT product, AVG(daily_total) FROM (SELECT product, date, SUM(amount) as daily_total FROM sales GROUP BY product, date) GROUP BY product;
EXPLAIN SELECT * FROM test;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN (FORMAT YAML) SELECT * FROM test;
EXPLAIN SELECT * FROM test;
EXPLAIN SELECT 1 + 1 as result;
EXPLAIN INSERT INTO test SELECT id, id * 2 FROM test WHERE id > 10;
EXPLAIN UPDATE test SET value = value * 2 WHERE id > 100;
EXPLAIN DELETE FROM test WHERE value < 10;

DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
DROP TABLE IF EXISTS wide_table;
CREATE TABLE wide_table (id INT64, col1 STRING, col2 STRING, col3 INT64, col4 FLOAT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS big;
CREATE TABLE big (id INT64, data STRING);
DROP TABLE IF EXISTS tiny;
CREATE TABLE tiny (id INT64, ref STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 100), (2, 200), (3, 300);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, t1_id INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, t2_id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount INT64, region STRING);
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (id INT64, name STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (id INT64, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, avg_salary INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, date DATE, amount INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);

EXPLAIN SELECT c.name FROM customers c JOIN orders o ON c.id = o.customer_id WHERE o.amount > 1000;
EXPLAIN SELECT id, col1 FROM wide_table;
EXPLAIN SELECT * FROM test WHERE value > 100;
EXPLAIN SELECT * FROM big JOIN tiny ON big.id = tiny.id;
EXPLAIN ANALYZE SELECT * FROM test WHERE value > 25;
EXPLAIN ANALYZE SELECT SUM(value) FROM test;
EXPLAIN ANALYZE SELECT id, data FROM test ORDER BY data;
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.id = t2.t1_id JOIN t3 ON t2.id = t3.t2_id;
EXPLAIN WITH regional_totals AS (SELECT region, SUM(amount) as total FROM sales GROUP BY region) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN SELECT name FROM active_users UNION SELECT name FROM inactive_users;
EXPLAIN SELECT e.id FROM employees e WHERE e.salary > (SELECT avg_salary FROM departments d WHERE d.id = e.dept_id);
EXPLAIN SELECT product, AVG(daily_total) FROM (SELECT product, date, SUM(amount) as daily_total FROM sales GROUP BY product, date) GROUP BY product;
EXPLAIN SELECT * FROM test;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN (FORMAT YAML) SELECT * FROM test;
EXPLAIN SELECT * FROM test;
EXPLAIN SELECT 1 + 1 as result;
EXPLAIN INSERT INTO test SELECT id, id * 2 FROM test WHERE id > 10;
EXPLAIN UPDATE test SET value = value * 2 WHERE id > 100;
EXPLAIN DELETE FROM test WHERE value < 10;

DROP TABLE IF EXISTS wide_table;
CREATE TABLE wide_table (id INT64, col1 STRING, col2 STRING, col3 INT64, col4 FLOAT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS big;
CREATE TABLE big (id INT64, data STRING);
DROP TABLE IF EXISTS tiny;
CREATE TABLE tiny (id INT64, ref STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 100), (2, 200), (3, 300);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, t1_id INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, t2_id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount INT64, region STRING);
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (id INT64, name STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (id INT64, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, avg_salary INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, date DATE, amount INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);

EXPLAIN SELECT id, col1 FROM wide_table;
EXPLAIN SELECT * FROM test WHERE value > 100;
EXPLAIN SELECT * FROM big JOIN tiny ON big.id = tiny.id;
EXPLAIN ANALYZE SELECT * FROM test WHERE value > 25;
EXPLAIN ANALYZE SELECT SUM(value) FROM test;
EXPLAIN ANALYZE SELECT id, data FROM test ORDER BY data;
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.id = t2.t1_id JOIN t3 ON t2.id = t3.t2_id;
EXPLAIN WITH regional_totals AS (SELECT region, SUM(amount) as total FROM sales GROUP BY region) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN SELECT name FROM active_users UNION SELECT name FROM inactive_users;
EXPLAIN SELECT e.id FROM employees e WHERE e.salary > (SELECT avg_salary FROM departments d WHERE d.id = e.dept_id);
EXPLAIN SELECT product, AVG(daily_total) FROM (SELECT product, date, SUM(amount) as daily_total FROM sales GROUP BY product, date) GROUP BY product;
EXPLAIN SELECT * FROM test;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN (FORMAT YAML) SELECT * FROM test;
EXPLAIN SELECT * FROM test;
EXPLAIN SELECT 1 + 1 as result;
EXPLAIN INSERT INTO test SELECT id, id * 2 FROM test WHERE id > 10;
EXPLAIN UPDATE test SET value = value * 2 WHERE id > 100;
EXPLAIN DELETE FROM test WHERE value < 10;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS big;
CREATE TABLE big (id INT64, data STRING);
DROP TABLE IF EXISTS tiny;
CREATE TABLE tiny (id INT64, ref STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 100), (2, 200), (3, 300);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, t1_id INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, t2_id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount INT64, region STRING);
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (id INT64, name STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (id INT64, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, avg_salary INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, date DATE, amount INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);

EXPLAIN SELECT * FROM test WHERE value > 100;
EXPLAIN SELECT * FROM big JOIN tiny ON big.id = tiny.id;
EXPLAIN ANALYZE SELECT * FROM test WHERE value > 25;
EXPLAIN ANALYZE SELECT SUM(value) FROM test;
EXPLAIN ANALYZE SELECT id, data FROM test ORDER BY data;
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.id = t2.t1_id JOIN t3 ON t2.id = t3.t2_id;
EXPLAIN WITH regional_totals AS (SELECT region, SUM(amount) as total FROM sales GROUP BY region) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN SELECT name FROM active_users UNION SELECT name FROM inactive_users;
EXPLAIN SELECT e.id FROM employees e WHERE e.salary > (SELECT avg_salary FROM departments d WHERE d.id = e.dept_id);
EXPLAIN SELECT product, AVG(daily_total) FROM (SELECT product, date, SUM(amount) as daily_total FROM sales GROUP BY product, date) GROUP BY product;
EXPLAIN SELECT * FROM test;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN (FORMAT YAML) SELECT * FROM test;
EXPLAIN SELECT * FROM test;
EXPLAIN SELECT 1 + 1 as result;
EXPLAIN INSERT INTO test SELECT id, id * 2 FROM test WHERE id > 10;
EXPLAIN UPDATE test SET value = value * 2 WHERE id > 100;
EXPLAIN DELETE FROM test WHERE value < 10;

DROP TABLE IF EXISTS big;
CREATE TABLE big (id INT64, data STRING);
DROP TABLE IF EXISTS tiny;
CREATE TABLE tiny (id INT64, ref STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 100), (2, 200), (3, 300);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, t1_id INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, t2_id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount INT64, region STRING);
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (id INT64, name STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (id INT64, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, avg_salary INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, date DATE, amount INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);

EXPLAIN SELECT * FROM big JOIN tiny ON big.id = tiny.id;
EXPLAIN ANALYZE SELECT * FROM test WHERE value > 25;
EXPLAIN ANALYZE SELECT SUM(value) FROM test;
EXPLAIN ANALYZE SELECT id, data FROM test ORDER BY data;
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.id = t2.t1_id JOIN t3 ON t2.id = t3.t2_id;
EXPLAIN WITH regional_totals AS (SELECT region, SUM(amount) as total FROM sales GROUP BY region) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN SELECT name FROM active_users UNION SELECT name FROM inactive_users;
EXPLAIN SELECT e.id FROM employees e WHERE e.salary > (SELECT avg_salary FROM departments d WHERE d.id = e.dept_id);
EXPLAIN SELECT product, AVG(daily_total) FROM (SELECT product, date, SUM(amount) as daily_total FROM sales GROUP BY product, date) GROUP BY product;
EXPLAIN SELECT * FROM test;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN (FORMAT YAML) SELECT * FROM test;
EXPLAIN SELECT * FROM test;
EXPLAIN SELECT 1 + 1 as result;
EXPLAIN INSERT INTO test SELECT id, id * 2 FROM test WHERE id > 10;
EXPLAIN UPDATE test SET value = value * 2 WHERE id > 100;
EXPLAIN DELETE FROM test WHERE value < 10;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 100), (2, 200), (3, 300);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, t1_id INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, t2_id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount INT64, region STRING);
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (id INT64, name STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (id INT64, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, avg_salary INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, date DATE, amount INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);

EXPLAIN ANALYZE SELECT * FROM test WHERE value > 25;
EXPLAIN ANALYZE SELECT SUM(value) FROM test;
EXPLAIN ANALYZE SELECT id, data FROM test ORDER BY data;
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.id = t2.t1_id JOIN t3 ON t2.id = t3.t2_id;
EXPLAIN WITH regional_totals AS (SELECT region, SUM(amount) as total FROM sales GROUP BY region) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN SELECT name FROM active_users UNION SELECT name FROM inactive_users;
EXPLAIN SELECT e.id FROM employees e WHERE e.salary > (SELECT avg_salary FROM departments d WHERE d.id = e.dept_id);
EXPLAIN SELECT product, AVG(daily_total) FROM (SELECT product, date, SUM(amount) as daily_total FROM sales GROUP BY product, date) GROUP BY product;
EXPLAIN SELECT * FROM test;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN (FORMAT YAML) SELECT * FROM test;
EXPLAIN SELECT * FROM test;
EXPLAIN SELECT 1 + 1 as result;
EXPLAIN INSERT INTO test SELECT id, id * 2 FROM test WHERE id > 10;
EXPLAIN UPDATE test SET value = value * 2 WHERE id > 100;
EXPLAIN DELETE FROM test WHERE value < 10;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 100), (2, 200), (3, 300);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, t1_id INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, t2_id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount INT64, region STRING);
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (id INT64, name STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (id INT64, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, avg_salary INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, date DATE, amount INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);

EXPLAIN ANALYZE SELECT SUM(value) FROM test;
EXPLAIN ANALYZE SELECT id, data FROM test ORDER BY data;
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.id = t2.t1_id JOIN t3 ON t2.id = t3.t2_id;
EXPLAIN WITH regional_totals AS (SELECT region, SUM(amount) as total FROM sales GROUP BY region) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN SELECT name FROM active_users UNION SELECT name FROM inactive_users;
EXPLAIN SELECT e.id FROM employees e WHERE e.salary > (SELECT avg_salary FROM departments d WHERE d.id = e.dept_id);
EXPLAIN SELECT product, AVG(daily_total) FROM (SELECT product, date, SUM(amount) as daily_total FROM sales GROUP BY product, date) GROUP BY product;
EXPLAIN SELECT * FROM test;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN (FORMAT YAML) SELECT * FROM test;
EXPLAIN SELECT * FROM test;
EXPLAIN SELECT 1 + 1 as result;
EXPLAIN INSERT INTO test SELECT id, id * 2 FROM test WHERE id > 10;
EXPLAIN UPDATE test SET value = value * 2 WHERE id > 100;
EXPLAIN DELETE FROM test WHERE value < 10;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, data STRING);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, t1_id INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, t2_id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount INT64, region STRING);
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (id INT64, name STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (id INT64, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, avg_salary INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, date DATE, amount INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);

EXPLAIN ANALYZE SELECT id, data FROM test ORDER BY data;
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.id = t2.t1_id JOIN t3 ON t2.id = t3.t2_id;
EXPLAIN WITH regional_totals AS (SELECT region, SUM(amount) as total FROM sales GROUP BY region) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN SELECT name FROM active_users UNION SELECT name FROM inactive_users;
EXPLAIN SELECT e.id FROM employees e WHERE e.salary > (SELECT avg_salary FROM departments d WHERE d.id = e.dept_id);
EXPLAIN SELECT product, AVG(daily_total) FROM (SELECT product, date, SUM(amount) as daily_total FROM sales GROUP BY product, date) GROUP BY product;
EXPLAIN SELECT * FROM test;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN (FORMAT YAML) SELECT * FROM test;
EXPLAIN SELECT * FROM test;
EXPLAIN SELECT 1 + 1 as result;
EXPLAIN INSERT INTO test SELECT id, id * 2 FROM test WHERE id > 10;
EXPLAIN UPDATE test SET value = value * 2 WHERE id > 100;
EXPLAIN DELETE FROM test WHERE value < 10;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, t1_id INT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (id INT64, t2_id INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount INT64, region STRING);
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (id INT64, name STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (id INT64, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, avg_salary INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, date DATE, amount INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);

EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.id = t2.t1_id JOIN t3 ON t2.id = t3.t2_id;
EXPLAIN WITH regional_totals AS (SELECT region, SUM(amount) as total FROM sales GROUP BY region) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN SELECT name FROM active_users UNION SELECT name FROM inactive_users;
EXPLAIN SELECT e.id FROM employees e WHERE e.salary > (SELECT avg_salary FROM departments d WHERE d.id = e.dept_id);
EXPLAIN SELECT product, AVG(daily_total) FROM (SELECT product, date, SUM(amount) as daily_total FROM sales GROUP BY product, date) GROUP BY product;
EXPLAIN SELECT * FROM test;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN (FORMAT YAML) SELECT * FROM test;
EXPLAIN SELECT * FROM test;
EXPLAIN SELECT 1 + 1 as result;
EXPLAIN INSERT INTO test SELECT id, id * 2 FROM test WHERE id > 10;
EXPLAIN UPDATE test SET value = value * 2 WHERE id > 100;
EXPLAIN DELETE FROM test WHERE value < 10;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount INT64, region STRING);
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (id INT64, name STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (id INT64, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, avg_salary INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, date DATE, amount INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);

EXPLAIN WITH regional_totals AS (SELECT region, SUM(amount) as total FROM sales GROUP BY region) SELECT * FROM regional_totals WHERE total > 1000;
EXPLAIN SELECT name FROM active_users UNION SELECT name FROM inactive_users;
EXPLAIN SELECT e.id FROM employees e WHERE e.salary > (SELECT avg_salary FROM departments d WHERE d.id = e.dept_id);
EXPLAIN SELECT product, AVG(daily_total) FROM (SELECT product, date, SUM(amount) as daily_total FROM sales GROUP BY product, date) GROUP BY product;
EXPLAIN SELECT * FROM test;
EXPLAIN (FORMAT JSON) SELECT * FROM test;
EXPLAIN (FORMAT YAML) SELECT * FROM test;
EXPLAIN SELECT * FROM test;
EXPLAIN SELECT 1 + 1 as result;
EXPLAIN INSERT INTO test SELECT id, id * 2 FROM test WHERE id > 10;
EXPLAIN UPDATE test SET value = value * 2 WHERE id > 100;
EXPLAIN DELETE FROM test WHERE value < 10;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'A'), (4, 'B'), (5, 'A');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, active BOOL);
INSERT INTO data VALUES (1, true), (2, false), (3, true), (4, true), (5, false), (6, true);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 90), (2, 95), (3, 85), (4, 100), (5, 88);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (5), (2), (8), (1), (9);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64);
INSERT INTO data VALUES ('A', 3), ('B', 1), ('A', 1), ('B', 2), ('A', 2);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0), (3, 1, 150.0), (4, 3, 300.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('C', 300), ('B', 250);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 5), ('C', 30), ('C', 40), ('D', 3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 100), (2, 200), (3, 150), (4, 250), (5, 180);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3261
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3262
SELECT id FROM data ORDER BY id FETCH FIRST ROW ONLY;
-- Tag: cte_cte_test_select_3263
SELECT id FROM data FETCH FIRST 0 ROWS ONLY;
-- Tag: cte_cte_test_select_3264
SELECT id FROM data ORDER BY id FETCH FIRST 100 ROWS ONLY;
-- Tag: cte_cte_test_select_3265
SELECT id FROM data ORDER BY id OFFSET 3 ROWS FETCH NEXT 4 ROWS ONLY;
-- Tag: cte_cte_test_select_3266
SELECT id FROM data ORDER BY id OFFSET 0 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3267
SELECT id FROM data ORDER BY id OFFSET 10 ROWS FETCH NEXT 5 ROWS ONLY;
-- Tag: cte_cte_test_select_3268
SELECT id FROM data ORDER BY id OFFSET 2 ROW FETCH NEXT 1 ROW ONLY;
-- Tag: cte_cte_test_select_3269
SELECT id FROM data WHERE category = 'A' ORDER BY id FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3270
SELECT id FROM data WHERE active = true ORDER BY id OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3271
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3272
SELECT id FROM data FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3273
SELECT category, id FROM data ORDER BY category ASC, id DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3274
SELECT o.id, c.name, o.amount FROM orders o JOIN customers c ON o.customer_id = c.id ORDER BY o.amount DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3275
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY total DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3276
SELECT category, SUM(value) as total FROM data GROUP BY category HAVING SUM(value) > 10 ORDER BY total OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3277
SELECT * FROM ( SELECT id, value FROM data ORDER BY value DESC FETCH FIRST 3 ROWS ONLY ) AS top3 ORDER BY id;
-- Tag: cte_cte_test_select_3278
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3279
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3280
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3281
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3282
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3283
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3284
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3285
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3286
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3287
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3288
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3289
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (10), (20), (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'A'), (4, 'B'), (5, 'A');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, active BOOL);
INSERT INTO data VALUES (1, true), (2, false), (3, true), (4, true), (5, false), (6, true);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 90), (2, 95), (3, 85), (4, 100), (5, 88);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (5), (2), (8), (1), (9);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64);
INSERT INTO data VALUES ('A', 3), ('B', 1), ('A', 1), ('B', 2), ('A', 2);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0), (3, 1, 150.0), (4, 3, 300.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('C', 300), ('B', 250);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 5), ('C', 30), ('C', 40), ('D', 3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 100), (2, 200), (3, 150), (4, 250), (5, 180);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3290
SELECT id FROM data ORDER BY id FETCH FIRST ROW ONLY;
-- Tag: cte_cte_test_select_3291
SELECT id FROM data FETCH FIRST 0 ROWS ONLY;
-- Tag: cte_cte_test_select_3292
SELECT id FROM data ORDER BY id FETCH FIRST 100 ROWS ONLY;
-- Tag: cte_cte_test_select_3293
SELECT id FROM data ORDER BY id OFFSET 3 ROWS FETCH NEXT 4 ROWS ONLY;
-- Tag: cte_cte_test_select_3294
SELECT id FROM data ORDER BY id OFFSET 0 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3295
SELECT id FROM data ORDER BY id OFFSET 10 ROWS FETCH NEXT 5 ROWS ONLY;
-- Tag: cte_cte_test_select_3296
SELECT id FROM data ORDER BY id OFFSET 2 ROW FETCH NEXT 1 ROW ONLY;
-- Tag: cte_cte_test_select_3297
SELECT id FROM data WHERE category = 'A' ORDER BY id FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3298
SELECT id FROM data WHERE active = true ORDER BY id OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3299
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3300
SELECT id FROM data FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3301
SELECT category, id FROM data ORDER BY category ASC, id DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3302
SELECT o.id, c.name, o.amount FROM orders o JOIN customers c ON o.customer_id = c.id ORDER BY o.amount DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3303
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY total DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3304
SELECT category, SUM(value) as total FROM data GROUP BY category HAVING SUM(value) > 10 ORDER BY total OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3305
SELECT * FROM ( SELECT id, value FROM data ORDER BY value DESC FETCH FIRST 3 ROWS ONLY ) AS top3 ORDER BY id;
-- Tag: cte_cte_test_select_3306
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3307
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3308
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3309
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3310
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3311
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3312
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3313
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3314
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3315
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3316
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3317
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'A'), (4, 'B'), (5, 'A');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, active BOOL);
INSERT INTO data VALUES (1, true), (2, false), (3, true), (4, true), (5, false), (6, true);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 90), (2, 95), (3, 85), (4, 100), (5, 88);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (5), (2), (8), (1), (9);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64);
INSERT INTO data VALUES ('A', 3), ('B', 1), ('A', 1), ('B', 2), ('A', 2);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0), (3, 1, 150.0), (4, 3, 300.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('C', 300), ('B', 250);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 5), ('C', 30), ('C', 40), ('D', 3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 100), (2, 200), (3, 150), (4, 250), (5, 180);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3318
SELECT id FROM data FETCH FIRST 0 ROWS ONLY;
-- Tag: cte_cte_test_select_3319
SELECT id FROM data ORDER BY id FETCH FIRST 100 ROWS ONLY;
-- Tag: cte_cte_test_select_3320
SELECT id FROM data ORDER BY id OFFSET 3 ROWS FETCH NEXT 4 ROWS ONLY;
-- Tag: cte_cte_test_select_3321
SELECT id FROM data ORDER BY id OFFSET 0 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3322
SELECT id FROM data ORDER BY id OFFSET 10 ROWS FETCH NEXT 5 ROWS ONLY;
-- Tag: cte_cte_test_select_3323
SELECT id FROM data ORDER BY id OFFSET 2 ROW FETCH NEXT 1 ROW ONLY;
-- Tag: cte_cte_test_select_3324
SELECT id FROM data WHERE category = 'A' ORDER BY id FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3325
SELECT id FROM data WHERE active = true ORDER BY id OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3326
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3327
SELECT id FROM data FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3328
SELECT category, id FROM data ORDER BY category ASC, id DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3329
SELECT o.id, c.name, o.amount FROM orders o JOIN customers c ON o.customer_id = c.id ORDER BY o.amount DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3330
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY total DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3331
SELECT category, SUM(value) as total FROM data GROUP BY category HAVING SUM(value) > 10 ORDER BY total OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3332
SELECT * FROM ( SELECT id, value FROM data ORDER BY value DESC FETCH FIRST 3 ROWS ONLY ) AS top3 ORDER BY id;
-- Tag: cte_cte_test_select_3333
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3334
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3335
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3336
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3337
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3338
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3339
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3340
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3341
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3342
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3343
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3344
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'A'), (4, 'B'), (5, 'A');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, active BOOL);
INSERT INTO data VALUES (1, true), (2, false), (3, true), (4, true), (5, false), (6, true);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 90), (2, 95), (3, 85), (4, 100), (5, 88);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (5), (2), (8), (1), (9);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64);
INSERT INTO data VALUES ('A', 3), ('B', 1), ('A', 1), ('B', 2), ('A', 2);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0), (3, 1, 150.0), (4, 3, 300.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('C', 300), ('B', 250);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 5), ('C', 30), ('C', 40), ('D', 3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 100), (2, 200), (3, 150), (4, 250), (5, 180);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3345
SELECT id FROM data ORDER BY id FETCH FIRST 100 ROWS ONLY;
-- Tag: cte_cte_test_select_3346
SELECT id FROM data ORDER BY id OFFSET 3 ROWS FETCH NEXT 4 ROWS ONLY;
-- Tag: cte_cte_test_select_3347
SELECT id FROM data ORDER BY id OFFSET 0 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3348
SELECT id FROM data ORDER BY id OFFSET 10 ROWS FETCH NEXT 5 ROWS ONLY;
-- Tag: cte_cte_test_select_3349
SELECT id FROM data ORDER BY id OFFSET 2 ROW FETCH NEXT 1 ROW ONLY;
-- Tag: cte_cte_test_select_3350
SELECT id FROM data WHERE category = 'A' ORDER BY id FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3351
SELECT id FROM data WHERE active = true ORDER BY id OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3352
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3353
SELECT id FROM data FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3354
SELECT category, id FROM data ORDER BY category ASC, id DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3355
SELECT o.id, c.name, o.amount FROM orders o JOIN customers c ON o.customer_id = c.id ORDER BY o.amount DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3356
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY total DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3357
SELECT category, SUM(value) as total FROM data GROUP BY category HAVING SUM(value) > 10 ORDER BY total OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3358
SELECT * FROM ( SELECT id, value FROM data ORDER BY value DESC FETCH FIRST 3 ROWS ONLY ) AS top3 ORDER BY id;
-- Tag: cte_cte_test_select_3359
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3360
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3361
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3362
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3363
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3364
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3365
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3366
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3367
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3368
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3369
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3370
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'A'), (4, 'B'), (5, 'A');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, active BOOL);
INSERT INTO data VALUES (1, true), (2, false), (3, true), (4, true), (5, false), (6, true);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 90), (2, 95), (3, 85), (4, 100), (5, 88);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (5), (2), (8), (1), (9);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64);
INSERT INTO data VALUES ('A', 3), ('B', 1), ('A', 1), ('B', 2), ('A', 2);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0), (3, 1, 150.0), (4, 3, 300.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('C', 300), ('B', 250);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 5), ('C', 30), ('C', 40), ('D', 3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 100), (2, 200), (3, 150), (4, 250), (5, 180);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3371
SELECT id FROM data ORDER BY id OFFSET 3 ROWS FETCH NEXT 4 ROWS ONLY;
-- Tag: cte_cte_test_select_3372
SELECT id FROM data ORDER BY id OFFSET 0 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3373
SELECT id FROM data ORDER BY id OFFSET 10 ROWS FETCH NEXT 5 ROWS ONLY;
-- Tag: cte_cte_test_select_3374
SELECT id FROM data ORDER BY id OFFSET 2 ROW FETCH NEXT 1 ROW ONLY;
-- Tag: cte_cte_test_select_3375
SELECT id FROM data WHERE category = 'A' ORDER BY id FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3376
SELECT id FROM data WHERE active = true ORDER BY id OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3377
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3378
SELECT id FROM data FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3379
SELECT category, id FROM data ORDER BY category ASC, id DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3380
SELECT o.id, c.name, o.amount FROM orders o JOIN customers c ON o.customer_id = c.id ORDER BY o.amount DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3381
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY total DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3382
SELECT category, SUM(value) as total FROM data GROUP BY category HAVING SUM(value) > 10 ORDER BY total OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3383
SELECT * FROM ( SELECT id, value FROM data ORDER BY value DESC FETCH FIRST 3 ROWS ONLY ) AS top3 ORDER BY id;
-- Tag: cte_cte_test_select_3384
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3385
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3386
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3387
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3388
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3389
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3390
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3391
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3392
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3393
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3394
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3395
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'A'), (4, 'B'), (5, 'A');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, active BOOL);
INSERT INTO data VALUES (1, true), (2, false), (3, true), (4, true), (5, false), (6, true);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 90), (2, 95), (3, 85), (4, 100), (5, 88);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (5), (2), (8), (1), (9);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64);
INSERT INTO data VALUES ('A', 3), ('B', 1), ('A', 1), ('B', 2), ('A', 2);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0), (3, 1, 150.0), (4, 3, 300.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('C', 300), ('B', 250);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 5), ('C', 30), ('C', 40), ('D', 3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 100), (2, 200), (3, 150), (4, 250), (5, 180);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3396
SELECT id FROM data ORDER BY id OFFSET 0 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3397
SELECT id FROM data ORDER BY id OFFSET 10 ROWS FETCH NEXT 5 ROWS ONLY;
-- Tag: cte_cte_test_select_3398
SELECT id FROM data ORDER BY id OFFSET 2 ROW FETCH NEXT 1 ROW ONLY;
-- Tag: cte_cte_test_select_3399
SELECT id FROM data WHERE category = 'A' ORDER BY id FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3400
SELECT id FROM data WHERE active = true ORDER BY id OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3401
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3402
SELECT id FROM data FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3403
SELECT category, id FROM data ORDER BY category ASC, id DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3404
SELECT o.id, c.name, o.amount FROM orders o JOIN customers c ON o.customer_id = c.id ORDER BY o.amount DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3405
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY total DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3406
SELECT category, SUM(value) as total FROM data GROUP BY category HAVING SUM(value) > 10 ORDER BY total OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3407
SELECT * FROM ( SELECT id, value FROM data ORDER BY value DESC FETCH FIRST 3 ROWS ONLY ) AS top3 ORDER BY id;
-- Tag: cte_cte_test_select_3408
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3409
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3410
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3411
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3412
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3413
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3414
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3415
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3416
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3417
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3418
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3419
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'A'), (4, 'B'), (5, 'A');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, active BOOL);
INSERT INTO data VALUES (1, true), (2, false), (3, true), (4, true), (5, false), (6, true);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 90), (2, 95), (3, 85), (4, 100), (5, 88);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (5), (2), (8), (1), (9);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64);
INSERT INTO data VALUES ('A', 3), ('B', 1), ('A', 1), ('B', 2), ('A', 2);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0), (3, 1, 150.0), (4, 3, 300.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('C', 300), ('B', 250);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 5), ('C', 30), ('C', 40), ('D', 3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 100), (2, 200), (3, 150), (4, 250), (5, 180);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3420
SELECT id FROM data ORDER BY id OFFSET 10 ROWS FETCH NEXT 5 ROWS ONLY;
-- Tag: cte_cte_test_select_3421
SELECT id FROM data ORDER BY id OFFSET 2 ROW FETCH NEXT 1 ROW ONLY;
-- Tag: cte_cte_test_select_3422
SELECT id FROM data WHERE category = 'A' ORDER BY id FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3423
SELECT id FROM data WHERE active = true ORDER BY id OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3424
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3425
SELECT id FROM data FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3426
SELECT category, id FROM data ORDER BY category ASC, id DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3427
SELECT o.id, c.name, o.amount FROM orders o JOIN customers c ON o.customer_id = c.id ORDER BY o.amount DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3428
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY total DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3429
SELECT category, SUM(value) as total FROM data GROUP BY category HAVING SUM(value) > 10 ORDER BY total OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3430
SELECT * FROM ( SELECT id, value FROM data ORDER BY value DESC FETCH FIRST 3 ROWS ONLY ) AS top3 ORDER BY id;
-- Tag: cte_cte_test_select_3431
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3432
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3433
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3434
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3435
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3436
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3437
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3438
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3439
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3440
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3441
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3442
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'A'), (4, 'B'), (5, 'A');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, active BOOL);
INSERT INTO data VALUES (1, true), (2, false), (3, true), (4, true), (5, false), (6, true);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 90), (2, 95), (3, 85), (4, 100), (5, 88);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (5), (2), (8), (1), (9);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64);
INSERT INTO data VALUES ('A', 3), ('B', 1), ('A', 1), ('B', 2), ('A', 2);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0), (3, 1, 150.0), (4, 3, 300.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('C', 300), ('B', 250);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 5), ('C', 30), ('C', 40), ('D', 3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 100), (2, 200), (3, 150), (4, 250), (5, 180);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3443
SELECT id FROM data ORDER BY id OFFSET 2 ROW FETCH NEXT 1 ROW ONLY;
-- Tag: cte_cte_test_select_3444
SELECT id FROM data WHERE category = 'A' ORDER BY id FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3445
SELECT id FROM data WHERE active = true ORDER BY id OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3446
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3447
SELECT id FROM data FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3448
SELECT category, id FROM data ORDER BY category ASC, id DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3449
SELECT o.id, c.name, o.amount FROM orders o JOIN customers c ON o.customer_id = c.id ORDER BY o.amount DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3450
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY total DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3451
SELECT category, SUM(value) as total FROM data GROUP BY category HAVING SUM(value) > 10 ORDER BY total OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3452
SELECT * FROM ( SELECT id, value FROM data ORDER BY value DESC FETCH FIRST 3 ROWS ONLY ) AS top3 ORDER BY id;
-- Tag: cte_cte_test_select_3453
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3454
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3455
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3456
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3457
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3458
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3459
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3460
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3461
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3462
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3463
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3464
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'A'), (4, 'B'), (5, 'A');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, active BOOL);
INSERT INTO data VALUES (1, true), (2, false), (3, true), (4, true), (5, false), (6, true);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 90), (2, 95), (3, 85), (4, 100), (5, 88);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (5), (2), (8), (1), (9);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64);
INSERT INTO data VALUES ('A', 3), ('B', 1), ('A', 1), ('B', 2), ('A', 2);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0), (3, 1, 150.0), (4, 3, 300.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('C', 300), ('B', 250);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 5), ('C', 30), ('C', 40), ('D', 3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 100), (2, 200), (3, 150), (4, 250), (5, 180);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3465
SELECT id FROM data WHERE category = 'A' ORDER BY id FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3466
SELECT id FROM data WHERE active = true ORDER BY id OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3467
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3468
SELECT id FROM data FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3469
SELECT category, id FROM data ORDER BY category ASC, id DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3470
SELECT o.id, c.name, o.amount FROM orders o JOIN customers c ON o.customer_id = c.id ORDER BY o.amount DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3471
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY total DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3472
SELECT category, SUM(value) as total FROM data GROUP BY category HAVING SUM(value) > 10 ORDER BY total OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3473
SELECT * FROM ( SELECT id, value FROM data ORDER BY value DESC FETCH FIRST 3 ROWS ONLY ) AS top3 ORDER BY id;
-- Tag: cte_cte_test_select_3474
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3475
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3476
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3477
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3478
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3479
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3480
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3481
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3482
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3483
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3484
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3485
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, active BOOL);
INSERT INTO data VALUES (1, true), (2, false), (3, true), (4, true), (5, false), (6, true);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 90), (2, 95), (3, 85), (4, 100), (5, 88);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (5), (2), (8), (1), (9);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64);
INSERT INTO data VALUES ('A', 3), ('B', 1), ('A', 1), ('B', 2), ('A', 2);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0), (3, 1, 150.0), (4, 3, 300.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('C', 300), ('B', 250);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 5), ('C', 30), ('C', 40), ('D', 3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 100), (2, 200), (3, 150), (4, 250), (5, 180);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3486
SELECT id FROM data WHERE active = true ORDER BY id OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3487
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3488
SELECT id FROM data FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3489
SELECT category, id FROM data ORDER BY category ASC, id DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3490
SELECT o.id, c.name, o.amount FROM orders o JOIN customers c ON o.customer_id = c.id ORDER BY o.amount DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3491
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY total DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3492
SELECT category, SUM(value) as total FROM data GROUP BY category HAVING SUM(value) > 10 ORDER BY total OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3493
SELECT * FROM ( SELECT id, value FROM data ORDER BY value DESC FETCH FIRST 3 ROWS ONLY ) AS top3 ORDER BY id;
-- Tag: cte_cte_test_select_3494
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3495
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3496
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3497
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3498
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3499
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3500
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3501
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3502
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3503
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3504
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3505
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 90), (2, 95), (3, 85), (4, 100), (5, 88);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (5), (2), (8), (1), (9);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64);
INSERT INTO data VALUES ('A', 3), ('B', 1), ('A', 1), ('B', 2), ('A', 2);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0), (3, 1, 150.0), (4, 3, 300.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('C', 300), ('B', 250);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 5), ('C', 30), ('C', 40), ('D', 3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 100), (2, 200), (3, 150), (4, 250), (5, 180);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3506
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3507
SELECT id FROM data FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3508
SELECT category, id FROM data ORDER BY category ASC, id DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3509
SELECT o.id, c.name, o.amount FROM orders o JOIN customers c ON o.customer_id = c.id ORDER BY o.amount DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3510
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY total DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3511
SELECT category, SUM(value) as total FROM data GROUP BY category HAVING SUM(value) > 10 ORDER BY total OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3512
SELECT * FROM ( SELECT id, value FROM data ORDER BY value DESC FETCH FIRST 3 ROWS ONLY ) AS top3 ORDER BY id;
-- Tag: cte_cte_test_select_3513
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3514
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3515
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3516
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3517
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3518
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3519
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3520
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3521
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3522
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3523
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3524
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (5), (2), (8), (1), (9);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64);
INSERT INTO data VALUES ('A', 3), ('B', 1), ('A', 1), ('B', 2), ('A', 2);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0), (3, 1, 150.0), (4, 3, 300.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('C', 300), ('B', 250);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 5), ('C', 30), ('C', 40), ('D', 3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 100), (2, 200), (3, 150), (4, 250), (5, 180);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3525
SELECT id FROM data FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3526
SELECT category, id FROM data ORDER BY category ASC, id DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3527
SELECT o.id, c.name, o.amount FROM orders o JOIN customers c ON o.customer_id = c.id ORDER BY o.amount DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3528
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY total DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3529
SELECT category, SUM(value) as total FROM data GROUP BY category HAVING SUM(value) > 10 ORDER BY total OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3530
SELECT * FROM ( SELECT id, value FROM data ORDER BY value DESC FETCH FIRST 3 ROWS ONLY ) AS top3 ORDER BY id;
-- Tag: cte_cte_test_select_3531
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3532
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3533
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3534
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3535
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3536
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3537
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3538
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3539
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3540
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3541
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3542
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64);
INSERT INTO data VALUES ('A', 3), ('B', 1), ('A', 1), ('B', 2), ('A', 2);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0), (3, 1, 150.0), (4, 3, 300.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('C', 300), ('B', 250);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 5), ('C', 30), ('C', 40), ('D', 3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 100), (2, 200), (3, 150), (4, 250), (5, 180);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3543
SELECT category, id FROM data ORDER BY category ASC, id DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3544
SELECT o.id, c.name, o.amount FROM orders o JOIN customers c ON o.customer_id = c.id ORDER BY o.amount DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3545
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY total DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3546
SELECT category, SUM(value) as total FROM data GROUP BY category HAVING SUM(value) > 10 ORDER BY total OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3547
SELECT * FROM ( SELECT id, value FROM data ORDER BY value DESC FETCH FIRST 3 ROWS ONLY ) AS top3 ORDER BY id;
-- Tag: cte_cte_test_select_3548
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3549
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3550
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3551
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3552
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3553
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3554
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3555
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3556
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3557
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3558
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3559
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0), (3, 1, 150.0), (4, 3, 300.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('C', 300), ('B', 250);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 5), ('C', 30), ('C', 40), ('D', 3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 100), (2, 200), (3, 150), (4, 250), (5, 180);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3560
SELECT o.id, c.name, o.amount FROM orders o JOIN customers c ON o.customer_id = c.id ORDER BY o.amount DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3561
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY total DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3562
SELECT category, SUM(value) as total FROM data GROUP BY category HAVING SUM(value) > 10 ORDER BY total OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3563
SELECT * FROM ( SELECT id, value FROM data ORDER BY value DESC FETCH FIRST 3 ROWS ONLY ) AS top3 ORDER BY id;
-- Tag: cte_cte_test_select_3564
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3565
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3566
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3567
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3568
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3569
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3570
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3571
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3572
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3573
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3574
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3575
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('C', 300), ('B', 250);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 5), ('C', 30), ('C', 40), ('D', 3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 100), (2, 200), (3, 150), (4, 250), (5, 180);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3576
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY total DESC FETCH FIRST 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3577
SELECT category, SUM(value) as total FROM data GROUP BY category HAVING SUM(value) > 10 ORDER BY total OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3578
SELECT * FROM ( SELECT id, value FROM data ORDER BY value DESC FETCH FIRST 3 ROWS ONLY ) AS top3 ORDER BY id;
-- Tag: cte_cte_test_select_3579
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3580
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3581
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3582
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3583
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3584
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3585
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3586
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3587
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3588
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3589
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3590
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 5), ('C', 30), ('C', 40), ('D', 3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 100), (2, 200), (3, 150), (4, 250), (5, 180);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3591
SELECT category, SUM(value) as total FROM data GROUP BY category HAVING SUM(value) > 10 ORDER BY total OFFSET 1 ROWS FETCH NEXT 2 ROWS ONLY;
-- Tag: cte_cte_test_select_3592
SELECT * FROM ( SELECT id, value FROM data ORDER BY value DESC FETCH FIRST 3 ROWS ONLY ) AS top3 ORDER BY id;
-- Tag: cte_cte_test_select_3593
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3594
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3595
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3596
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3597
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3598
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3599
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3600
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3601
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3602
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3603
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3604
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 100), (2, 200), (3, 150), (4, 250), (5, 180);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3605
SELECT * FROM ( SELECT id, value FROM data ORDER BY value DESC FETCH FIRST 3 ROWS ONLY ) AS top3 ORDER BY id;
-- Tag: cte_cte_test_select_3606
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3607
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3608
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3609
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3610
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3611
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3612
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3613
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3614
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3615
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3616
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3617
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (name STRING, max_price FLOAT64);
INSERT INTO categories VALUES ('Electronics', 1000.0), ('Books', 50.0);
INSERT INTO products VALUES (1, 'Electronics', 500.0), (2, 'Books', 20.0), (3, 'Electronics', 800.0), (4, 'Books', 30.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

-- Tag: cte_cte_test_select_3618
SELECT p.id, p.price FROM products p WHERE p.price < (SELECT max_price FROM categories c WHERE c.name = p.category) ORDER BY p.price DESC FETCH FIRST 2 ROWS ONLY;
WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3619
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3620
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3621
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3622
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3623
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3624
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3625
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3626
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3627
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3628
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3629
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
DROP TABLE IF EXISTS empty;
CREATE TABLE empty (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, score INT64);
INSERT INTO data VALUES (1, 100), (2, 100), (3, 100), (4, 90), (5, 90);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5), (6), (7);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
DROP TABLE IF EXISTS large;
CREATE TABLE large (id INT64, value INT64);

WITH doubled AS ( SELECT id, value * 2 as double_value FROM data ) SELECT id, double_value FROM doubled ORDER BY double_value DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3630
SELECT id FROM empty FETCH FIRST 10 ROWS ONLY;
-- Tag: cte_cte_test_select_3631
SELECT id, value FROM data ORDER BY value FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3632
SELECT id, score FROM data ORDER BY score DESC FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3633
SELECT id FROM data ORDER BY id FETCH FIRST 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3634
SELECT id FROM data ORDER BY id LIMIT 3;
-- Tag: cte_cte_test_select_3635
SELECT id FROM data ORDER BY id OFFSET 2 ROWS FETCH NEXT 3 ROWS ONLY;
-- Tag: cte_cte_test_select_3636
SELECT id FROM data ORDER BY id LIMIT 3 OFFSET 2;
-- Tag: cte_cte_test_select_3637
SELECT id FROM data FETCH FIRST -1 ROWS ONLY;
-- Tag: cte_cte_test_select_3638
SELECT id FROM data OFFSET -1 ROWS;
-- Tag: cte_cte_test_select_3639
SELECT id FROM data FETCH FIRST 5 ONLY;
-- Tag: cte_cte_test_select_3640
SELECT id FROM large ORDER BY id FETCH FIRST 10 ROWS ONLY;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES (NULL, 100);
INSERT INTO sales VALUES (NULL, 200);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
INSERT INTO sales VALUES (NULL, 'Gadget', 50);
INSERT INTO sales VALUES ('West', NULL, 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales ( dim1 STRING, dim2 STRING, dim3 STRING, dim4 STRING, dim5 STRING, amount INT64 );
INSERT INTO sales VALUES ('A', 'B', 'C', 'D', 'E', 100);
DROP TABLE IF EXISTS hierarchy;
CREATE TABLE hierarchy ( l1 INT64, l2 INT64, l3 INT64, l4 INT64, l5 INT64, l6 INT64, l7 INT64, l8 INT64, l9 INT64, l10 INT64, value INT64 );
INSERT INTO hierarchy VALUES (1,1,1,1,1,1,1,1,1,1, 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0);
INSERT INTO sales VALUES ('East', 200.0);
INSERT INTO sales VALUES ('West', 50.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, customer STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Alice', 100);
INSERT INTO sales VALUES ('East', 'Alice', 50);
INSERT INTO sales VALUES ('East', 'Bob', 75);
INSERT INTO sales VALUES ('West', 'Alice', 80);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, amount FLOAT64);
INSERT INTO sales VALUES (2024, 100.5);
INSERT INTO sales VALUES (2024, 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
INSERT INTO sales VALUES ('North', 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', NULL, 100000);
INSERT INTO employees VALUES (2, 'Bob', 1, 80000);
INSERT INTO employees VALUES (3, 'Charlie', 1, 75000);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 10);
INSERT INTO sales VALUES ('West', 20);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, customer STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (a STRING, b STRING, c STRING, amount INT64);

-- Tag: cte_cte_test_select_3641
SELECT region, COUNT(*) as cnt, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3642
SELECT region, product, COUNT(*) as cnt FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3643
SELECT region, product, COUNT(*) as cnt FROM sales GROUP BY GROUPING SETS ((region), (product), ());
-- Tag: cte_cte_test_select_3644
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3645
SELECT region, SUM(amount) as total, GROUPING(region) as is_total FROM sales GROUP BY ROLLUP(region) ORDER BY GROUPING(region), region NULLS FIRST;
-- Tag: cte_cte_test_select_3646
SELECT region, product, SUM(amount) as total, GROUPING(region) as gr_region, GROUPING(product) as gr_product FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3647
SELECT dim1, dim2, dim3, dim4, dim5, SUM(amount) as total FROM sales GROUP BY CUBE(dim1, dim2, dim3, dim4, dim5);
-- Tag: cte_cte_test_select_3648
SELECT l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, COUNT(*) as cnt FROM hierarchy GROUP BY ROLLUP(l1, l2, l3, l4, l5, l6, l7, l8, l9, l10);
-- Tag: cte_cte_test_select_3649
SELECT region, COUNT(*) as cnt, SUM(amount) as total, AVG(amount) as avg_amt, MIN(amount) as min_amt, MAX(amount) as max_amt FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3650
SELECT region, COUNT(DISTINCT customer) as unique_customers, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3651
SELECT CAST(year AS STRING) as year_str, SUM(amount) as total FROM sales GROUP BY ROLLUP(year);
-- Tag: cte_cte_test_select_3652
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST LIMIT 2;
-- Tag: cte_cte_test_select_3653
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) OFFSET 2;
WITH rollup_data AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ) SELECT * FROM rollup_data WHERE total >= 100;
-- Tag: cte_cte_test_select_3654
SELECT * FROM ( SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) ) cube_result WHERE region IS NOT NULL;
-- Tag: cte_cte_test_select_3655
SELECT m.name as manager, COUNT(*) as direct_reports, SUM(e.salary) as total_salary FROM employees e JOIN employees m ON e.manager_id = m.id GROUP BY ROLLUP(m.name);
-- Tag: cte_cte_test_select_3656
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) > 1000;
-- Tag: cte_cte_test_select_3657
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) HAVING GROUPING(region) = 1 AND GROUPING(product) = 0;
-- Tag: cte_cte_test_select_3658
SELECT COALESCE(region, 'GRAND TOTAL') as region_label, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3659
SELECT region, COUNT(*) as cnt FROM sales GROUP BY ROLLUP(SUM(amount));
-- Tag: cte_cte_test_select_3660
SELECT region, product, customer, SUM(amount) FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3661
SELECT region, SUM(amount) FROM sales GROUP BY GROUPING SETS ((region), (nonexistent));
-- Tag: cte_cte_test_select_3662
SELECT a, b, c, SUM(amount) FROM sales GROUP BY ROLLUP(a), CUBE(b, c);

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES (NULL, 100);
INSERT INTO sales VALUES (NULL, 200);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
INSERT INTO sales VALUES (NULL, 'Gadget', 50);
INSERT INTO sales VALUES ('West', NULL, 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales ( dim1 STRING, dim2 STRING, dim3 STRING, dim4 STRING, dim5 STRING, amount INT64 );
INSERT INTO sales VALUES ('A', 'B', 'C', 'D', 'E', 100);
DROP TABLE IF EXISTS hierarchy;
CREATE TABLE hierarchy ( l1 INT64, l2 INT64, l3 INT64, l4 INT64, l5 INT64, l6 INT64, l7 INT64, l8 INT64, l9 INT64, l10 INT64, value INT64 );
INSERT INTO hierarchy VALUES (1,1,1,1,1,1,1,1,1,1, 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0);
INSERT INTO sales VALUES ('East', 200.0);
INSERT INTO sales VALUES ('West', 50.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, customer STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Alice', 100);
INSERT INTO sales VALUES ('East', 'Alice', 50);
INSERT INTO sales VALUES ('East', 'Bob', 75);
INSERT INTO sales VALUES ('West', 'Alice', 80);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, amount FLOAT64);
INSERT INTO sales VALUES (2024, 100.5);
INSERT INTO sales VALUES (2024, 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
INSERT INTO sales VALUES ('North', 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', NULL, 100000);
INSERT INTO employees VALUES (2, 'Bob', 1, 80000);
INSERT INTO employees VALUES (3, 'Charlie', 1, 75000);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 10);
INSERT INTO sales VALUES ('West', 20);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, customer STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (a STRING, b STRING, c STRING, amount INT64);

-- Tag: cte_cte_test_select_3663
SELECT region, product, COUNT(*) as cnt FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3664
SELECT region, product, COUNT(*) as cnt FROM sales GROUP BY GROUPING SETS ((region), (product), ());
-- Tag: cte_cte_test_select_3665
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3666
SELECT region, SUM(amount) as total, GROUPING(region) as is_total FROM sales GROUP BY ROLLUP(region) ORDER BY GROUPING(region), region NULLS FIRST;
-- Tag: cte_cte_test_select_3667
SELECT region, product, SUM(amount) as total, GROUPING(region) as gr_region, GROUPING(product) as gr_product FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3668
SELECT dim1, dim2, dim3, dim4, dim5, SUM(amount) as total FROM sales GROUP BY CUBE(dim1, dim2, dim3, dim4, dim5);
-- Tag: cte_cte_test_select_3669
SELECT l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, COUNT(*) as cnt FROM hierarchy GROUP BY ROLLUP(l1, l2, l3, l4, l5, l6, l7, l8, l9, l10);
-- Tag: cte_cte_test_select_3670
SELECT region, COUNT(*) as cnt, SUM(amount) as total, AVG(amount) as avg_amt, MIN(amount) as min_amt, MAX(amount) as max_amt FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3671
SELECT region, COUNT(DISTINCT customer) as unique_customers, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3672
SELECT CAST(year AS STRING) as year_str, SUM(amount) as total FROM sales GROUP BY ROLLUP(year);
-- Tag: cte_cte_test_select_3673
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST LIMIT 2;
-- Tag: cte_cte_test_select_3674
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) OFFSET 2;
WITH rollup_data AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ) SELECT * FROM rollup_data WHERE total >= 100;
-- Tag: cte_cte_test_select_3675
SELECT * FROM ( SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) ) cube_result WHERE region IS NOT NULL;
-- Tag: cte_cte_test_select_3676
SELECT m.name as manager, COUNT(*) as direct_reports, SUM(e.salary) as total_salary FROM employees e JOIN employees m ON e.manager_id = m.id GROUP BY ROLLUP(m.name);
-- Tag: cte_cte_test_select_3677
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) > 1000;
-- Tag: cte_cte_test_select_3678
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) HAVING GROUPING(region) = 1 AND GROUPING(product) = 0;
-- Tag: cte_cte_test_select_3679
SELECT COALESCE(region, 'GRAND TOTAL') as region_label, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3680
SELECT region, COUNT(*) as cnt FROM sales GROUP BY ROLLUP(SUM(amount));
-- Tag: cte_cte_test_select_3681
SELECT region, product, customer, SUM(amount) FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3682
SELECT region, SUM(amount) FROM sales GROUP BY GROUPING SETS ((region), (nonexistent));
-- Tag: cte_cte_test_select_3683
SELECT a, b, c, SUM(amount) FROM sales GROUP BY ROLLUP(a), CUBE(b, c);

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES (NULL, 100);
INSERT INTO sales VALUES (NULL, 200);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
INSERT INTO sales VALUES (NULL, 'Gadget', 50);
INSERT INTO sales VALUES ('West', NULL, 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales ( dim1 STRING, dim2 STRING, dim3 STRING, dim4 STRING, dim5 STRING, amount INT64 );
INSERT INTO sales VALUES ('A', 'B', 'C', 'D', 'E', 100);
DROP TABLE IF EXISTS hierarchy;
CREATE TABLE hierarchy ( l1 INT64, l2 INT64, l3 INT64, l4 INT64, l5 INT64, l6 INT64, l7 INT64, l8 INT64, l9 INT64, l10 INT64, value INT64 );
INSERT INTO hierarchy VALUES (1,1,1,1,1,1,1,1,1,1, 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0);
INSERT INTO sales VALUES ('East', 200.0);
INSERT INTO sales VALUES ('West', 50.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, customer STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Alice', 100);
INSERT INTO sales VALUES ('East', 'Alice', 50);
INSERT INTO sales VALUES ('East', 'Bob', 75);
INSERT INTO sales VALUES ('West', 'Alice', 80);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, amount FLOAT64);
INSERT INTO sales VALUES (2024, 100.5);
INSERT INTO sales VALUES (2024, 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
INSERT INTO sales VALUES ('North', 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', NULL, 100000);
INSERT INTO employees VALUES (2, 'Bob', 1, 80000);
INSERT INTO employees VALUES (3, 'Charlie', 1, 75000);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 10);
INSERT INTO sales VALUES ('West', 20);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, customer STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (a STRING, b STRING, c STRING, amount INT64);

-- Tag: cte_cte_test_select_3684
SELECT region, product, COUNT(*) as cnt FROM sales GROUP BY GROUPING SETS ((region), (product), ());
-- Tag: cte_cte_test_select_3685
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3686
SELECT region, SUM(amount) as total, GROUPING(region) as is_total FROM sales GROUP BY ROLLUP(region) ORDER BY GROUPING(region), region NULLS FIRST;
-- Tag: cte_cte_test_select_3687
SELECT region, product, SUM(amount) as total, GROUPING(region) as gr_region, GROUPING(product) as gr_product FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3688
SELECT dim1, dim2, dim3, dim4, dim5, SUM(amount) as total FROM sales GROUP BY CUBE(dim1, dim2, dim3, dim4, dim5);
-- Tag: cte_cte_test_select_3689
SELECT l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, COUNT(*) as cnt FROM hierarchy GROUP BY ROLLUP(l1, l2, l3, l4, l5, l6, l7, l8, l9, l10);
-- Tag: cte_cte_test_select_3690
SELECT region, COUNT(*) as cnt, SUM(amount) as total, AVG(amount) as avg_amt, MIN(amount) as min_amt, MAX(amount) as max_amt FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3691
SELECT region, COUNT(DISTINCT customer) as unique_customers, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3692
SELECT CAST(year AS STRING) as year_str, SUM(amount) as total FROM sales GROUP BY ROLLUP(year);
-- Tag: cte_cte_test_select_3693
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST LIMIT 2;
-- Tag: cte_cte_test_select_3694
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) OFFSET 2;
WITH rollup_data AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ) SELECT * FROM rollup_data WHERE total >= 100;
-- Tag: cte_cte_test_select_3695
SELECT * FROM ( SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) ) cube_result WHERE region IS NOT NULL;
-- Tag: cte_cte_test_select_3696
SELECT m.name as manager, COUNT(*) as direct_reports, SUM(e.salary) as total_salary FROM employees e JOIN employees m ON e.manager_id = m.id GROUP BY ROLLUP(m.name);
-- Tag: cte_cte_test_select_3697
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) > 1000;
-- Tag: cte_cte_test_select_3698
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) HAVING GROUPING(region) = 1 AND GROUPING(product) = 0;
-- Tag: cte_cte_test_select_3699
SELECT COALESCE(region, 'GRAND TOTAL') as region_label, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3700
SELECT region, COUNT(*) as cnt FROM sales GROUP BY ROLLUP(SUM(amount));
-- Tag: cte_cte_test_select_3701
SELECT region, product, customer, SUM(amount) FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3702
SELECT region, SUM(amount) FROM sales GROUP BY GROUPING SETS ((region), (nonexistent));
-- Tag: cte_cte_test_select_3703
SELECT a, b, c, SUM(amount) FROM sales GROUP BY ROLLUP(a), CUBE(b, c);

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES (NULL, 100);
INSERT INTO sales VALUES (NULL, 200);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
INSERT INTO sales VALUES (NULL, 'Gadget', 50);
INSERT INTO sales VALUES ('West', NULL, 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales ( dim1 STRING, dim2 STRING, dim3 STRING, dim4 STRING, dim5 STRING, amount INT64 );
INSERT INTO sales VALUES ('A', 'B', 'C', 'D', 'E', 100);
DROP TABLE IF EXISTS hierarchy;
CREATE TABLE hierarchy ( l1 INT64, l2 INT64, l3 INT64, l4 INT64, l5 INT64, l6 INT64, l7 INT64, l8 INT64, l9 INT64, l10 INT64, value INT64 );
INSERT INTO hierarchy VALUES (1,1,1,1,1,1,1,1,1,1, 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0);
INSERT INTO sales VALUES ('East', 200.0);
INSERT INTO sales VALUES ('West', 50.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, customer STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Alice', 100);
INSERT INTO sales VALUES ('East', 'Alice', 50);
INSERT INTO sales VALUES ('East', 'Bob', 75);
INSERT INTO sales VALUES ('West', 'Alice', 80);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, amount FLOAT64);
INSERT INTO sales VALUES (2024, 100.5);
INSERT INTO sales VALUES (2024, 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
INSERT INTO sales VALUES ('North', 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', NULL, 100000);
INSERT INTO employees VALUES (2, 'Bob', 1, 80000);
INSERT INTO employees VALUES (3, 'Charlie', 1, 75000);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 10);
INSERT INTO sales VALUES ('West', 20);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, customer STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (a STRING, b STRING, c STRING, amount INT64);

-- Tag: cte_cte_test_select_3704
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3705
SELECT region, SUM(amount) as total, GROUPING(region) as is_total FROM sales GROUP BY ROLLUP(region) ORDER BY GROUPING(region), region NULLS FIRST;
-- Tag: cte_cte_test_select_3706
SELECT region, product, SUM(amount) as total, GROUPING(region) as gr_region, GROUPING(product) as gr_product FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3707
SELECT dim1, dim2, dim3, dim4, dim5, SUM(amount) as total FROM sales GROUP BY CUBE(dim1, dim2, dim3, dim4, dim5);
-- Tag: cte_cte_test_select_3708
SELECT l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, COUNT(*) as cnt FROM hierarchy GROUP BY ROLLUP(l1, l2, l3, l4, l5, l6, l7, l8, l9, l10);
-- Tag: cte_cte_test_select_3709
SELECT region, COUNT(*) as cnt, SUM(amount) as total, AVG(amount) as avg_amt, MIN(amount) as min_amt, MAX(amount) as max_amt FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3710
SELECT region, COUNT(DISTINCT customer) as unique_customers, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3711
SELECT CAST(year AS STRING) as year_str, SUM(amount) as total FROM sales GROUP BY ROLLUP(year);
-- Tag: cte_cte_test_select_3712
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST LIMIT 2;
-- Tag: cte_cte_test_select_3713
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) OFFSET 2;
WITH rollup_data AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ) SELECT * FROM rollup_data WHERE total >= 100;
-- Tag: cte_cte_test_select_3714
SELECT * FROM ( SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) ) cube_result WHERE region IS NOT NULL;
-- Tag: cte_cte_test_select_3715
SELECT m.name as manager, COUNT(*) as direct_reports, SUM(e.salary) as total_salary FROM employees e JOIN employees m ON e.manager_id = m.id GROUP BY ROLLUP(m.name);
-- Tag: cte_cte_test_select_3716
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) > 1000;
-- Tag: cte_cte_test_select_3717
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) HAVING GROUPING(region) = 1 AND GROUPING(product) = 0;
-- Tag: cte_cte_test_select_3718
SELECT COALESCE(region, 'GRAND TOTAL') as region_label, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3719
SELECT region, COUNT(*) as cnt FROM sales GROUP BY ROLLUP(SUM(amount));
-- Tag: cte_cte_test_select_3720
SELECT region, product, customer, SUM(amount) FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3721
SELECT region, SUM(amount) FROM sales GROUP BY GROUPING SETS ((region), (nonexistent));
-- Tag: cte_cte_test_select_3722
SELECT a, b, c, SUM(amount) FROM sales GROUP BY ROLLUP(a), CUBE(b, c);

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES (NULL, 100);
INSERT INTO sales VALUES (NULL, 200);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
INSERT INTO sales VALUES (NULL, 'Gadget', 50);
INSERT INTO sales VALUES ('West', NULL, 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales ( dim1 STRING, dim2 STRING, dim3 STRING, dim4 STRING, dim5 STRING, amount INT64 );
INSERT INTO sales VALUES ('A', 'B', 'C', 'D', 'E', 100);
DROP TABLE IF EXISTS hierarchy;
CREATE TABLE hierarchy ( l1 INT64, l2 INT64, l3 INT64, l4 INT64, l5 INT64, l6 INT64, l7 INT64, l8 INT64, l9 INT64, l10 INT64, value INT64 );
INSERT INTO hierarchy VALUES (1,1,1,1,1,1,1,1,1,1, 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0);
INSERT INTO sales VALUES ('East', 200.0);
INSERT INTO sales VALUES ('West', 50.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, customer STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Alice', 100);
INSERT INTO sales VALUES ('East', 'Alice', 50);
INSERT INTO sales VALUES ('East', 'Bob', 75);
INSERT INTO sales VALUES ('West', 'Alice', 80);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, amount FLOAT64);
INSERT INTO sales VALUES (2024, 100.5);
INSERT INTO sales VALUES (2024, 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
INSERT INTO sales VALUES ('North', 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', NULL, 100000);
INSERT INTO employees VALUES (2, 'Bob', 1, 80000);
INSERT INTO employees VALUES (3, 'Charlie', 1, 75000);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 10);
INSERT INTO sales VALUES ('West', 20);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, customer STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (a STRING, b STRING, c STRING, amount INT64);

-- Tag: cte_cte_test_select_3723
SELECT region, SUM(amount) as total, GROUPING(region) as is_total FROM sales GROUP BY ROLLUP(region) ORDER BY GROUPING(region), region NULLS FIRST;
-- Tag: cte_cte_test_select_3724
SELECT region, product, SUM(amount) as total, GROUPING(region) as gr_region, GROUPING(product) as gr_product FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3725
SELECT dim1, dim2, dim3, dim4, dim5, SUM(amount) as total FROM sales GROUP BY CUBE(dim1, dim2, dim3, dim4, dim5);
-- Tag: cte_cte_test_select_3726
SELECT l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, COUNT(*) as cnt FROM hierarchy GROUP BY ROLLUP(l1, l2, l3, l4, l5, l6, l7, l8, l9, l10);
-- Tag: cte_cte_test_select_3727
SELECT region, COUNT(*) as cnt, SUM(amount) as total, AVG(amount) as avg_amt, MIN(amount) as min_amt, MAX(amount) as max_amt FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3728
SELECT region, COUNT(DISTINCT customer) as unique_customers, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3729
SELECT CAST(year AS STRING) as year_str, SUM(amount) as total FROM sales GROUP BY ROLLUP(year);
-- Tag: cte_cte_test_select_3730
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST LIMIT 2;
-- Tag: cte_cte_test_select_3731
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) OFFSET 2;
WITH rollup_data AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ) SELECT * FROM rollup_data WHERE total >= 100;
-- Tag: cte_cte_test_select_3732
SELECT * FROM ( SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) ) cube_result WHERE region IS NOT NULL;
-- Tag: cte_cte_test_select_3733
SELECT m.name as manager, COUNT(*) as direct_reports, SUM(e.salary) as total_salary FROM employees e JOIN employees m ON e.manager_id = m.id GROUP BY ROLLUP(m.name);
-- Tag: cte_cte_test_select_3734
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) > 1000;
-- Tag: cte_cte_test_select_3735
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) HAVING GROUPING(region) = 1 AND GROUPING(product) = 0;
-- Tag: cte_cte_test_select_3736
SELECT COALESCE(region, 'GRAND TOTAL') as region_label, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3737
SELECT region, COUNT(*) as cnt FROM sales GROUP BY ROLLUP(SUM(amount));
-- Tag: cte_cte_test_select_3738
SELECT region, product, customer, SUM(amount) FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3739
SELECT region, SUM(amount) FROM sales GROUP BY GROUPING SETS ((region), (nonexistent));
-- Tag: cte_cte_test_select_3740
SELECT a, b, c, SUM(amount) FROM sales GROUP BY ROLLUP(a), CUBE(b, c);

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
INSERT INTO sales VALUES (NULL, 'Gadget', 50);
INSERT INTO sales VALUES ('West', NULL, 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales ( dim1 STRING, dim2 STRING, dim3 STRING, dim4 STRING, dim5 STRING, amount INT64 );
INSERT INTO sales VALUES ('A', 'B', 'C', 'D', 'E', 100);
DROP TABLE IF EXISTS hierarchy;
CREATE TABLE hierarchy ( l1 INT64, l2 INT64, l3 INT64, l4 INT64, l5 INT64, l6 INT64, l7 INT64, l8 INT64, l9 INT64, l10 INT64, value INT64 );
INSERT INTO hierarchy VALUES (1,1,1,1,1,1,1,1,1,1, 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0);
INSERT INTO sales VALUES ('East', 200.0);
INSERT INTO sales VALUES ('West', 50.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, customer STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Alice', 100);
INSERT INTO sales VALUES ('East', 'Alice', 50);
INSERT INTO sales VALUES ('East', 'Bob', 75);
INSERT INTO sales VALUES ('West', 'Alice', 80);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, amount FLOAT64);
INSERT INTO sales VALUES (2024, 100.5);
INSERT INTO sales VALUES (2024, 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
INSERT INTO sales VALUES ('North', 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', NULL, 100000);
INSERT INTO employees VALUES (2, 'Bob', 1, 80000);
INSERT INTO employees VALUES (3, 'Charlie', 1, 75000);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 10);
INSERT INTO sales VALUES ('West', 20);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, customer STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (a STRING, b STRING, c STRING, amount INT64);

-- Tag: cte_cte_test_select_3741
SELECT region, product, SUM(amount) as total, GROUPING(region) as gr_region, GROUPING(product) as gr_product FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3742
SELECT dim1, dim2, dim3, dim4, dim5, SUM(amount) as total FROM sales GROUP BY CUBE(dim1, dim2, dim3, dim4, dim5);
-- Tag: cte_cte_test_select_3743
SELECT l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, COUNT(*) as cnt FROM hierarchy GROUP BY ROLLUP(l1, l2, l3, l4, l5, l6, l7, l8, l9, l10);
-- Tag: cte_cte_test_select_3744
SELECT region, COUNT(*) as cnt, SUM(amount) as total, AVG(amount) as avg_amt, MIN(amount) as min_amt, MAX(amount) as max_amt FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3745
SELECT region, COUNT(DISTINCT customer) as unique_customers, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3746
SELECT CAST(year AS STRING) as year_str, SUM(amount) as total FROM sales GROUP BY ROLLUP(year);
-- Tag: cte_cte_test_select_3747
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST LIMIT 2;
-- Tag: cte_cte_test_select_3748
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) OFFSET 2;
WITH rollup_data AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ) SELECT * FROM rollup_data WHERE total >= 100;
-- Tag: cte_cte_test_select_3749
SELECT * FROM ( SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) ) cube_result WHERE region IS NOT NULL;
-- Tag: cte_cte_test_select_3750
SELECT m.name as manager, COUNT(*) as direct_reports, SUM(e.salary) as total_salary FROM employees e JOIN employees m ON e.manager_id = m.id GROUP BY ROLLUP(m.name);
-- Tag: cte_cte_test_select_3751
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) > 1000;
-- Tag: cte_cte_test_select_3752
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) HAVING GROUPING(region) = 1 AND GROUPING(product) = 0;
-- Tag: cte_cte_test_select_3753
SELECT COALESCE(region, 'GRAND TOTAL') as region_label, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3754
SELECT region, COUNT(*) as cnt FROM sales GROUP BY ROLLUP(SUM(amount));
-- Tag: cte_cte_test_select_3755
SELECT region, product, customer, SUM(amount) FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3756
SELECT region, SUM(amount) FROM sales GROUP BY GROUPING SETS ((region), (nonexistent));
-- Tag: cte_cte_test_select_3757
SELECT a, b, c, SUM(amount) FROM sales GROUP BY ROLLUP(a), CUBE(b, c);

DROP TABLE IF EXISTS sales;
CREATE TABLE sales ( dim1 STRING, dim2 STRING, dim3 STRING, dim4 STRING, dim5 STRING, amount INT64 );
INSERT INTO sales VALUES ('A', 'B', 'C', 'D', 'E', 100);
DROP TABLE IF EXISTS hierarchy;
CREATE TABLE hierarchy ( l1 INT64, l2 INT64, l3 INT64, l4 INT64, l5 INT64, l6 INT64, l7 INT64, l8 INT64, l9 INT64, l10 INT64, value INT64 );
INSERT INTO hierarchy VALUES (1,1,1,1,1,1,1,1,1,1, 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0);
INSERT INTO sales VALUES ('East', 200.0);
INSERT INTO sales VALUES ('West', 50.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, customer STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Alice', 100);
INSERT INTO sales VALUES ('East', 'Alice', 50);
INSERT INTO sales VALUES ('East', 'Bob', 75);
INSERT INTO sales VALUES ('West', 'Alice', 80);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, amount FLOAT64);
INSERT INTO sales VALUES (2024, 100.5);
INSERT INTO sales VALUES (2024, 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
INSERT INTO sales VALUES ('North', 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', NULL, 100000);
INSERT INTO employees VALUES (2, 'Bob', 1, 80000);
INSERT INTO employees VALUES (3, 'Charlie', 1, 75000);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 10);
INSERT INTO sales VALUES ('West', 20);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, customer STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (a STRING, b STRING, c STRING, amount INT64);

-- Tag: cte_cte_test_select_3758
SELECT dim1, dim2, dim3, dim4, dim5, SUM(amount) as total FROM sales GROUP BY CUBE(dim1, dim2, dim3, dim4, dim5);
-- Tag: cte_cte_test_select_3759
SELECT l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, COUNT(*) as cnt FROM hierarchy GROUP BY ROLLUP(l1, l2, l3, l4, l5, l6, l7, l8, l9, l10);
-- Tag: cte_cte_test_select_3760
SELECT region, COUNT(*) as cnt, SUM(amount) as total, AVG(amount) as avg_amt, MIN(amount) as min_amt, MAX(amount) as max_amt FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3761
SELECT region, COUNT(DISTINCT customer) as unique_customers, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3762
SELECT CAST(year AS STRING) as year_str, SUM(amount) as total FROM sales GROUP BY ROLLUP(year);
-- Tag: cte_cte_test_select_3763
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST LIMIT 2;
-- Tag: cte_cte_test_select_3764
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) OFFSET 2;
WITH rollup_data AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ) SELECT * FROM rollup_data WHERE total >= 100;
-- Tag: cte_cte_test_select_3765
SELECT * FROM ( SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) ) cube_result WHERE region IS NOT NULL;
-- Tag: cte_cte_test_select_3766
SELECT m.name as manager, COUNT(*) as direct_reports, SUM(e.salary) as total_salary FROM employees e JOIN employees m ON e.manager_id = m.id GROUP BY ROLLUP(m.name);
-- Tag: cte_cte_test_select_3767
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) > 1000;
-- Tag: cte_cte_test_select_3768
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) HAVING GROUPING(region) = 1 AND GROUPING(product) = 0;
-- Tag: cte_cte_test_select_3769
SELECT COALESCE(region, 'GRAND TOTAL') as region_label, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3770
SELECT region, COUNT(*) as cnt FROM sales GROUP BY ROLLUP(SUM(amount));
-- Tag: cte_cte_test_select_3771
SELECT region, product, customer, SUM(amount) FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3772
SELECT region, SUM(amount) FROM sales GROUP BY GROUPING SETS ((region), (nonexistent));
-- Tag: cte_cte_test_select_3773
SELECT a, b, c, SUM(amount) FROM sales GROUP BY ROLLUP(a), CUBE(b, c);

DROP TABLE IF EXISTS hierarchy;
CREATE TABLE hierarchy ( l1 INT64, l2 INT64, l3 INT64, l4 INT64, l5 INT64, l6 INT64, l7 INT64, l8 INT64, l9 INT64, l10 INT64, value INT64 );
INSERT INTO hierarchy VALUES (1,1,1,1,1,1,1,1,1,1, 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0);
INSERT INTO sales VALUES ('East', 200.0);
INSERT INTO sales VALUES ('West', 50.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, customer STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Alice', 100);
INSERT INTO sales VALUES ('East', 'Alice', 50);
INSERT INTO sales VALUES ('East', 'Bob', 75);
INSERT INTO sales VALUES ('West', 'Alice', 80);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, amount FLOAT64);
INSERT INTO sales VALUES (2024, 100.5);
INSERT INTO sales VALUES (2024, 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
INSERT INTO sales VALUES ('North', 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', NULL, 100000);
INSERT INTO employees VALUES (2, 'Bob', 1, 80000);
INSERT INTO employees VALUES (3, 'Charlie', 1, 75000);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 10);
INSERT INTO sales VALUES ('West', 20);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, customer STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (a STRING, b STRING, c STRING, amount INT64);

-- Tag: cte_cte_test_select_3774
SELECT l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, COUNT(*) as cnt FROM hierarchy GROUP BY ROLLUP(l1, l2, l3, l4, l5, l6, l7, l8, l9, l10);
-- Tag: cte_cte_test_select_3775
SELECT region, COUNT(*) as cnt, SUM(amount) as total, AVG(amount) as avg_amt, MIN(amount) as min_amt, MAX(amount) as max_amt FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3776
SELECT region, COUNT(DISTINCT customer) as unique_customers, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3777
SELECT CAST(year AS STRING) as year_str, SUM(amount) as total FROM sales GROUP BY ROLLUP(year);
-- Tag: cte_cte_test_select_3778
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST LIMIT 2;
-- Tag: cte_cte_test_select_3779
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) OFFSET 2;
WITH rollup_data AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ) SELECT * FROM rollup_data WHERE total >= 100;
-- Tag: cte_cte_test_select_3780
SELECT * FROM ( SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) ) cube_result WHERE region IS NOT NULL;
-- Tag: cte_cte_test_select_3781
SELECT m.name as manager, COUNT(*) as direct_reports, SUM(e.salary) as total_salary FROM employees e JOIN employees m ON e.manager_id = m.id GROUP BY ROLLUP(m.name);
-- Tag: cte_cte_test_select_3782
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) > 1000;
-- Tag: cte_cte_test_select_3783
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) HAVING GROUPING(region) = 1 AND GROUPING(product) = 0;
-- Tag: cte_cte_test_select_3784
SELECT COALESCE(region, 'GRAND TOTAL') as region_label, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3785
SELECT region, COUNT(*) as cnt FROM sales GROUP BY ROLLUP(SUM(amount));
-- Tag: cte_cte_test_select_3786
SELECT region, product, customer, SUM(amount) FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3787
SELECT region, SUM(amount) FROM sales GROUP BY GROUPING SETS ((region), (nonexistent));
-- Tag: cte_cte_test_select_3788
SELECT a, b, c, SUM(amount) FROM sales GROUP BY ROLLUP(a), CUBE(b, c);

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0);
INSERT INTO sales VALUES ('East', 200.0);
INSERT INTO sales VALUES ('West', 50.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, customer STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Alice', 100);
INSERT INTO sales VALUES ('East', 'Alice', 50);
INSERT INTO sales VALUES ('East', 'Bob', 75);
INSERT INTO sales VALUES ('West', 'Alice', 80);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, amount FLOAT64);
INSERT INTO sales VALUES (2024, 100.5);
INSERT INTO sales VALUES (2024, 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
INSERT INTO sales VALUES ('North', 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', NULL, 100000);
INSERT INTO employees VALUES (2, 'Bob', 1, 80000);
INSERT INTO employees VALUES (3, 'Charlie', 1, 75000);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 10);
INSERT INTO sales VALUES ('West', 20);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, customer STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (a STRING, b STRING, c STRING, amount INT64);

-- Tag: cte_cte_test_select_3789
SELECT region, COUNT(*) as cnt, SUM(amount) as total, AVG(amount) as avg_amt, MIN(amount) as min_amt, MAX(amount) as max_amt FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3790
SELECT region, COUNT(DISTINCT customer) as unique_customers, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3791
SELECT CAST(year AS STRING) as year_str, SUM(amount) as total FROM sales GROUP BY ROLLUP(year);
-- Tag: cte_cte_test_select_3792
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST LIMIT 2;
-- Tag: cte_cte_test_select_3793
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) OFFSET 2;
WITH rollup_data AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ) SELECT * FROM rollup_data WHERE total >= 100;
-- Tag: cte_cte_test_select_3794
SELECT * FROM ( SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) ) cube_result WHERE region IS NOT NULL;
-- Tag: cte_cte_test_select_3795
SELECT m.name as manager, COUNT(*) as direct_reports, SUM(e.salary) as total_salary FROM employees e JOIN employees m ON e.manager_id = m.id GROUP BY ROLLUP(m.name);
-- Tag: cte_cte_test_select_3796
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) > 1000;
-- Tag: cte_cte_test_select_3797
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) HAVING GROUPING(region) = 1 AND GROUPING(product) = 0;
-- Tag: cte_cte_test_select_3798
SELECT COALESCE(region, 'GRAND TOTAL') as region_label, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3799
SELECT region, COUNT(*) as cnt FROM sales GROUP BY ROLLUP(SUM(amount));
-- Tag: cte_cte_test_select_3800
SELECT region, product, customer, SUM(amount) FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3801
SELECT region, SUM(amount) FROM sales GROUP BY GROUPING SETS ((region), (nonexistent));
-- Tag: cte_cte_test_select_3802
SELECT a, b, c, SUM(amount) FROM sales GROUP BY ROLLUP(a), CUBE(b, c);

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, customer STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Alice', 100);
INSERT INTO sales VALUES ('East', 'Alice', 50);
INSERT INTO sales VALUES ('East', 'Bob', 75);
INSERT INTO sales VALUES ('West', 'Alice', 80);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, amount FLOAT64);
INSERT INTO sales VALUES (2024, 100.5);
INSERT INTO sales VALUES (2024, 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
INSERT INTO sales VALUES ('North', 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', NULL, 100000);
INSERT INTO employees VALUES (2, 'Bob', 1, 80000);
INSERT INTO employees VALUES (3, 'Charlie', 1, 75000);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 10);
INSERT INTO sales VALUES ('West', 20);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, customer STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (a STRING, b STRING, c STRING, amount INT64);

-- Tag: cte_cte_test_select_3803
SELECT region, COUNT(DISTINCT customer) as unique_customers, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3804
SELECT CAST(year AS STRING) as year_str, SUM(amount) as total FROM sales GROUP BY ROLLUP(year);
-- Tag: cte_cte_test_select_3805
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST LIMIT 2;
-- Tag: cte_cte_test_select_3806
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) OFFSET 2;
WITH rollup_data AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ) SELECT * FROM rollup_data WHERE total >= 100;
-- Tag: cte_cte_test_select_3807
SELECT * FROM ( SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) ) cube_result WHERE region IS NOT NULL;
-- Tag: cte_cte_test_select_3808
SELECT m.name as manager, COUNT(*) as direct_reports, SUM(e.salary) as total_salary FROM employees e JOIN employees m ON e.manager_id = m.id GROUP BY ROLLUP(m.name);
-- Tag: cte_cte_test_select_3809
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) > 1000;
-- Tag: cte_cte_test_select_3810
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) HAVING GROUPING(region) = 1 AND GROUPING(product) = 0;
-- Tag: cte_cte_test_select_3811
SELECT COALESCE(region, 'GRAND TOTAL') as region_label, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3812
SELECT region, COUNT(*) as cnt FROM sales GROUP BY ROLLUP(SUM(amount));
-- Tag: cte_cte_test_select_3813
SELECT region, product, customer, SUM(amount) FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3814
SELECT region, SUM(amount) FROM sales GROUP BY GROUPING SETS ((region), (nonexistent));
-- Tag: cte_cte_test_select_3815
SELECT a, b, c, SUM(amount) FROM sales GROUP BY ROLLUP(a), CUBE(b, c);

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, amount FLOAT64);
INSERT INTO sales VALUES (2024, 100.5);
INSERT INTO sales VALUES (2024, 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
INSERT INTO sales VALUES ('North', 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', NULL, 100000);
INSERT INTO employees VALUES (2, 'Bob', 1, 80000);
INSERT INTO employees VALUES (3, 'Charlie', 1, 75000);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 10);
INSERT INTO sales VALUES ('West', 20);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, customer STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (a STRING, b STRING, c STRING, amount INT64);

-- Tag: cte_cte_test_select_3816
SELECT CAST(year AS STRING) as year_str, SUM(amount) as total FROM sales GROUP BY ROLLUP(year);
-- Tag: cte_cte_test_select_3817
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST LIMIT 2;
-- Tag: cte_cte_test_select_3818
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) OFFSET 2;
WITH rollup_data AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ) SELECT * FROM rollup_data WHERE total >= 100;
-- Tag: cte_cte_test_select_3819
SELECT * FROM ( SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) ) cube_result WHERE region IS NOT NULL;
-- Tag: cte_cte_test_select_3820
SELECT m.name as manager, COUNT(*) as direct_reports, SUM(e.salary) as total_salary FROM employees e JOIN employees m ON e.manager_id = m.id GROUP BY ROLLUP(m.name);
-- Tag: cte_cte_test_select_3821
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) > 1000;
-- Tag: cte_cte_test_select_3822
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) HAVING GROUPING(region) = 1 AND GROUPING(product) = 0;
-- Tag: cte_cte_test_select_3823
SELECT COALESCE(region, 'GRAND TOTAL') as region_label, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3824
SELECT region, COUNT(*) as cnt FROM sales GROUP BY ROLLUP(SUM(amount));
-- Tag: cte_cte_test_select_3825
SELECT region, product, customer, SUM(amount) FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3826
SELECT region, SUM(amount) FROM sales GROUP BY GROUPING SETS ((region), (nonexistent));
-- Tag: cte_cte_test_select_3827
SELECT a, b, c, SUM(amount) FROM sales GROUP BY ROLLUP(a), CUBE(b, c);

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
INSERT INTO sales VALUES ('North', 75);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', NULL, 100000);
INSERT INTO employees VALUES (2, 'Bob', 1, 80000);
INSERT INTO employees VALUES (3, 'Charlie', 1, 75000);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 10);
INSERT INTO sales VALUES ('West', 20);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, customer STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (a STRING, b STRING, c STRING, amount INT64);

-- Tag: cte_cte_test_select_3828
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST LIMIT 2;
-- Tag: cte_cte_test_select_3829
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) OFFSET 2;
WITH rollup_data AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ) SELECT * FROM rollup_data WHERE total >= 100;
-- Tag: cte_cte_test_select_3830
SELECT * FROM ( SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) ) cube_result WHERE region IS NOT NULL;
-- Tag: cte_cte_test_select_3831
SELECT m.name as manager, COUNT(*) as direct_reports, SUM(e.salary) as total_salary FROM employees e JOIN employees m ON e.manager_id = m.id GROUP BY ROLLUP(m.name);
-- Tag: cte_cte_test_select_3832
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) > 1000;
-- Tag: cte_cte_test_select_3833
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) HAVING GROUPING(region) = 1 AND GROUPING(product) = 0;
-- Tag: cte_cte_test_select_3834
SELECT COALESCE(region, 'GRAND TOTAL') as region_label, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3835
SELECT region, COUNT(*) as cnt FROM sales GROUP BY ROLLUP(SUM(amount));
-- Tag: cte_cte_test_select_3836
SELECT region, product, customer, SUM(amount) FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3837
SELECT region, SUM(amount) FROM sales GROUP BY GROUPING SETS ((region), (nonexistent));
-- Tag: cte_cte_test_select_3838
SELECT a, b, c, SUM(amount) FROM sales GROUP BY ROLLUP(a), CUBE(b, c);

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', NULL, 100000);
INSERT INTO employees VALUES (2, 'Bob', 1, 80000);
INSERT INTO employees VALUES (3, 'Charlie', 1, 75000);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 10);
INSERT INTO sales VALUES ('West', 20);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, customer STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (a STRING, b STRING, c STRING, amount INT64);

-- Tag: cte_cte_test_select_3839
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) OFFSET 2;
WITH rollup_data AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ) SELECT * FROM rollup_data WHERE total >= 100;
-- Tag: cte_cte_test_select_3840
SELECT * FROM ( SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) ) cube_result WHERE region IS NOT NULL;
-- Tag: cte_cte_test_select_3841
SELECT m.name as manager, COUNT(*) as direct_reports, SUM(e.salary) as total_salary FROM employees e JOIN employees m ON e.manager_id = m.id GROUP BY ROLLUP(m.name);
-- Tag: cte_cte_test_select_3842
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) > 1000;
-- Tag: cte_cte_test_select_3843
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) HAVING GROUPING(region) = 1 AND GROUPING(product) = 0;
-- Tag: cte_cte_test_select_3844
SELECT COALESCE(region, 'GRAND TOTAL') as region_label, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3845
SELECT region, COUNT(*) as cnt FROM sales GROUP BY ROLLUP(SUM(amount));
-- Tag: cte_cte_test_select_3846
SELECT region, product, customer, SUM(amount) FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3847
SELECT region, SUM(amount) FROM sales GROUP BY GROUPING SETS ((region), (nonexistent));
-- Tag: cte_cte_test_select_3848
SELECT a, b, c, SUM(amount) FROM sales GROUP BY ROLLUP(a), CUBE(b, c);

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'Alice', NULL, 100000);
INSERT INTO employees VALUES (2, 'Bob', 1, 80000);
INSERT INTO employees VALUES (3, 'Charlie', 1, 75000);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 10);
INSERT INTO sales VALUES ('West', 20);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'Widget', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100);
INSERT INTO sales VALUES ('West', 50);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, customer STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (a STRING, b STRING, c STRING, amount INT64);

WITH rollup_data AS ( SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ) SELECT * FROM rollup_data WHERE total >= 100;
-- Tag: cte_cte_test_select_3849
SELECT * FROM ( SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) ) cube_result WHERE region IS NOT NULL;
-- Tag: cte_cte_test_select_3850
SELECT m.name as manager, COUNT(*) as direct_reports, SUM(e.salary) as total_salary FROM employees e JOIN employees m ON e.manager_id = m.id GROUP BY ROLLUP(m.name);
-- Tag: cte_cte_test_select_3851
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) > 1000;
-- Tag: cte_cte_test_select_3852
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product) HAVING GROUPING(region) = 1 AND GROUPING(product) = 0;
-- Tag: cte_cte_test_select_3853
SELECT COALESCE(region, 'GRAND TOTAL') as region_label, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3854
SELECT region, COUNT(*) as cnt FROM sales GROUP BY ROLLUP(SUM(amount));
-- Tag: cte_cte_test_select_3855
SELECT region, product, customer, SUM(amount) FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3856
SELECT region, SUM(amount) FROM sales GROUP BY GROUPING SETS ((region), (nonexistent));
-- Tag: cte_cte_test_select_3857
SELECT a, b, c, SUM(amount) FROM sales GROUP BY ROLLUP(a), CUBE(b, c);

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, tax_rate FLOAT64);
INSERT INTO sales VALUES (1, 100.0, 0.1), (2, 200.0, 0.1), (3, 150.0, 0.2), (4, 180.0, 0.2);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, count INT64);
INSERT INTO users VALUES (1, 'Alice', 10), (2, 'alice', 20), (3, 'Bob', 15), (4, 'bob', 25);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 50.0), (2, 150.0), (3, 75.0), (4, 300.0), (5, 25.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (year INT64, month INT64, value FLOAT64);
INSERT INTO data VALUES (2023, 1, 100.0), (2023, 1, 150.0), (2023, 2, 200.0), (2024, 1, 120.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, NULL, 20), (3, 'A', 30), (4, NULL, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('A', 30), ('B', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (year INT64, month INT64, value FLOAT64);
INSERT INTO data VALUES (2023, 1, 100.0), (2023, 1, 150.0), (2023, 2, 200.0), (2024, 1, 120.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING, value INT64);
INSERT INTO data VALUES ('alice', 10), ('ALICE', 20), ('bob', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0), (2024, 1, 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20), (1, 2, 1, 30), (2, 1, 1, 40);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, NULL, 10), (NULL, 2, 20), (1, 2, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, 1, 10), (1, 2, 20), (2, 1, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_3858
SELECT tax_rate, SUM(amount) as total FROM sales GROUP BY tax_rate ORDER BY tax_rate;
-- Tag: cte_cte_test_select_3859
SELECT UPPER(name) as upper_name, SUM(count) as total FROM users GROUP BY UPPER(name) ORDER BY upper_name;
-- Tag: cte_cte_test_select_3860
SELECT CASE WHEN amount < 100 THEN 'Small' WHEN amount < 200 THEN 'Medium' ELSE 'Large' END as size, COUNT(*) as count FROM orders GROUP BY CASE WHEN amount < 100 THEN 'Small' WHEN amount < 200 THEN 'Medium' ELSE 'Large' END ORDER BY size;
-- Tag: cte_cte_test_select_3861
SELECT year, month, SUM(value) as total FROM data GROUP BY year, month ORDER BY year, month;
-- Tag: cte_cte_test_select_3862
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category NULLS LAST;
-- Tag: cte_cte_test_select_3863
SELECT category, SUM(value) as total FROM data GROUP BY 1 ORDER BY 1;
-- Tag: cte_cte_test_select_3864
SELECT year, month, SUM(value) as total FROM data GROUP BY 1, 2 ORDER BY 1, 2;
-- Tag: cte_cte_test_select_3865
SELECT UPPER(name) as upper_name, SUM(value) as total FROM data GROUP BY 1 ORDER BY 1;
-- Tag: cte_cte_test_select_3866
SELECT year, month, SUM(amount) as total FROM sales GROUP BY ROLLUP(year, month) ORDER BY year NULLS LAST, month NULLS LAST;
-- Tag: cte_cte_test_select_3867
SELECT category, SUM(value) as total FROM sales GROUP BY ROLLUP(category) ORDER BY category NULLS LAST;
-- Tag: cte_cte_test_select_3868
SELECT a, b, c, SUM(value) as total FROM data GROUP BY ROLLUP(a, b, c);
-- Tag: cte_cte_test_select_3869
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3870
SELECT a, b, c, SUM(value) as total FROM data GROUP BY CUBE(a, b, c);
-- Tag: cte_cte_test_select_3871
SELECT a, b, SUM(value) as total FROM data GROUP BY CUBE(a, b);
-- Tag: cte_cte_test_select_3872
SELECT region, product, SUM(amount) as total FROM sales GROUP BY GROUPING SETS ((region), (product));
-- Tag: cte_cte_test_select_3873
SELECT category, SUM(value) as total FROM data GROUP BY GROUPING SETS ((category), ());
-- Tag: cte_cte_test_select_3874
SELECT a, b, SUM(value) as total FROM data GROUP BY GROUPING SETS ((a, b), (a), (b), ());
-- Tag: cte_cte_test_select_3875
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3876
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_3877
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_3878
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_3879
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_3880
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_3881
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_3882
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_3883
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_3884
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_3885
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3886
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_3887
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_3888
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_3889
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_3890
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_3891
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_3892
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_3893
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_3894
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3895
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, count INT64);
INSERT INTO users VALUES (1, 'Alice', 10), (2, 'alice', 20), (3, 'Bob', 15), (4, 'bob', 25);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 50.0), (2, 150.0), (3, 75.0), (4, 300.0), (5, 25.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (year INT64, month INT64, value FLOAT64);
INSERT INTO data VALUES (2023, 1, 100.0), (2023, 1, 150.0), (2023, 2, 200.0), (2024, 1, 120.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, NULL, 20), (3, 'A', 30), (4, NULL, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('A', 30), ('B', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (year INT64, month INT64, value FLOAT64);
INSERT INTO data VALUES (2023, 1, 100.0), (2023, 1, 150.0), (2023, 2, 200.0), (2024, 1, 120.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING, value INT64);
INSERT INTO data VALUES ('alice', 10), ('ALICE', 20), ('bob', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0), (2024, 1, 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20), (1, 2, 1, 30), (2, 1, 1, 40);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, NULL, 10), (NULL, 2, 20), (1, 2, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, 1, 10), (1, 2, 20), (2, 1, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_3896
SELECT UPPER(name) as upper_name, SUM(count) as total FROM users GROUP BY UPPER(name) ORDER BY upper_name;
-- Tag: cte_cte_test_select_3897
SELECT CASE WHEN amount < 100 THEN 'Small' WHEN amount < 200 THEN 'Medium' ELSE 'Large' END as size, COUNT(*) as count FROM orders GROUP BY CASE WHEN amount < 100 THEN 'Small' WHEN amount < 200 THEN 'Medium' ELSE 'Large' END ORDER BY size;
-- Tag: cte_cte_test_select_3898
SELECT year, month, SUM(value) as total FROM data GROUP BY year, month ORDER BY year, month;
-- Tag: cte_cte_test_select_3899
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category NULLS LAST;
-- Tag: cte_cte_test_select_3900
SELECT category, SUM(value) as total FROM data GROUP BY 1 ORDER BY 1;
-- Tag: cte_cte_test_select_3901
SELECT year, month, SUM(value) as total FROM data GROUP BY 1, 2 ORDER BY 1, 2;
-- Tag: cte_cte_test_select_3902
SELECT UPPER(name) as upper_name, SUM(value) as total FROM data GROUP BY 1 ORDER BY 1;
-- Tag: cte_cte_test_select_3903
SELECT year, month, SUM(amount) as total FROM sales GROUP BY ROLLUP(year, month) ORDER BY year NULLS LAST, month NULLS LAST;
-- Tag: cte_cte_test_select_3904
SELECT category, SUM(value) as total FROM sales GROUP BY ROLLUP(category) ORDER BY category NULLS LAST;
-- Tag: cte_cte_test_select_3905
SELECT a, b, c, SUM(value) as total FROM data GROUP BY ROLLUP(a, b, c);
-- Tag: cte_cte_test_select_3906
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3907
SELECT a, b, c, SUM(value) as total FROM data GROUP BY CUBE(a, b, c);
-- Tag: cte_cte_test_select_3908
SELECT a, b, SUM(value) as total FROM data GROUP BY CUBE(a, b);
-- Tag: cte_cte_test_select_3909
SELECT region, product, SUM(amount) as total FROM sales GROUP BY GROUPING SETS ((region), (product));
-- Tag: cte_cte_test_select_3910
SELECT category, SUM(value) as total FROM data GROUP BY GROUPING SETS ((category), ());
-- Tag: cte_cte_test_select_3911
SELECT a, b, SUM(value) as total FROM data GROUP BY GROUPING SETS ((a, b), (a), (b), ());
-- Tag: cte_cte_test_select_3912
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3913
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_3914
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_3915
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_3916
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_3917
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_3918
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_3919
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_3920
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_3921
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_3922
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3923
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_3924
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_3925
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_3926
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_3927
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_3928
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_3929
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_3930
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_3931
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3932
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 50.0), (2, 150.0), (3, 75.0), (4, 300.0), (5, 25.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (year INT64, month INT64, value FLOAT64);
INSERT INTO data VALUES (2023, 1, 100.0), (2023, 1, 150.0), (2023, 2, 200.0), (2024, 1, 120.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, NULL, 20), (3, 'A', 30), (4, NULL, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('A', 30), ('B', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (year INT64, month INT64, value FLOAT64);
INSERT INTO data VALUES (2023, 1, 100.0), (2023, 1, 150.0), (2023, 2, 200.0), (2024, 1, 120.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING, value INT64);
INSERT INTO data VALUES ('alice', 10), ('ALICE', 20), ('bob', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0), (2024, 1, 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20), (1, 2, 1, 30), (2, 1, 1, 40);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, NULL, 10), (NULL, 2, 20), (1, 2, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, 1, 10), (1, 2, 20), (2, 1, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_3933
SELECT CASE WHEN amount < 100 THEN 'Small' WHEN amount < 200 THEN 'Medium' ELSE 'Large' END as size, COUNT(*) as count FROM orders GROUP BY CASE WHEN amount < 100 THEN 'Small' WHEN amount < 200 THEN 'Medium' ELSE 'Large' END ORDER BY size;
-- Tag: cte_cte_test_select_3934
SELECT year, month, SUM(value) as total FROM data GROUP BY year, month ORDER BY year, month;
-- Tag: cte_cte_test_select_3935
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category NULLS LAST;
-- Tag: cte_cte_test_select_3936
SELECT category, SUM(value) as total FROM data GROUP BY 1 ORDER BY 1;
-- Tag: cte_cte_test_select_3937
SELECT year, month, SUM(value) as total FROM data GROUP BY 1, 2 ORDER BY 1, 2;
-- Tag: cte_cte_test_select_3938
SELECT UPPER(name) as upper_name, SUM(value) as total FROM data GROUP BY 1 ORDER BY 1;
-- Tag: cte_cte_test_select_3939
SELECT year, month, SUM(amount) as total FROM sales GROUP BY ROLLUP(year, month) ORDER BY year NULLS LAST, month NULLS LAST;
-- Tag: cte_cte_test_select_3940
SELECT category, SUM(value) as total FROM sales GROUP BY ROLLUP(category) ORDER BY category NULLS LAST;
-- Tag: cte_cte_test_select_3941
SELECT a, b, c, SUM(value) as total FROM data GROUP BY ROLLUP(a, b, c);
-- Tag: cte_cte_test_select_3942
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3943
SELECT a, b, c, SUM(value) as total FROM data GROUP BY CUBE(a, b, c);
-- Tag: cte_cte_test_select_3944
SELECT a, b, SUM(value) as total FROM data GROUP BY CUBE(a, b);
-- Tag: cte_cte_test_select_3945
SELECT region, product, SUM(amount) as total FROM sales GROUP BY GROUPING SETS ((region), (product));
-- Tag: cte_cte_test_select_3946
SELECT category, SUM(value) as total FROM data GROUP BY GROUPING SETS ((category), ());
-- Tag: cte_cte_test_select_3947
SELECT a, b, SUM(value) as total FROM data GROUP BY GROUPING SETS ((a, b), (a), (b), ());
-- Tag: cte_cte_test_select_3948
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3949
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_3950
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_3951
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_3952
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_3953
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_3954
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_3955
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_3956
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_3957
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_3958
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3959
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_3960
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_3961
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_3962
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_3963
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_3964
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_3965
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_3966
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_3967
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_3968
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (year INT64, month INT64, value FLOAT64);
INSERT INTO data VALUES (2023, 1, 100.0), (2023, 1, 150.0), (2023, 2, 200.0), (2024, 1, 120.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, NULL, 20), (3, 'A', 30), (4, NULL, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('A', 30), ('B', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (year INT64, month INT64, value FLOAT64);
INSERT INTO data VALUES (2023, 1, 100.0), (2023, 1, 150.0), (2023, 2, 200.0), (2024, 1, 120.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING, value INT64);
INSERT INTO data VALUES ('alice', 10), ('ALICE', 20), ('bob', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0), (2024, 1, 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20), (1, 2, 1, 30), (2, 1, 1, 40);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, NULL, 10), (NULL, 2, 20), (1, 2, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, 1, 10), (1, 2, 20), (2, 1, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_3969
SELECT year, month, SUM(value) as total FROM data GROUP BY year, month ORDER BY year, month;
-- Tag: cte_cte_test_select_3970
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category NULLS LAST;
-- Tag: cte_cte_test_select_3971
SELECT category, SUM(value) as total FROM data GROUP BY 1 ORDER BY 1;
-- Tag: cte_cte_test_select_3972
SELECT year, month, SUM(value) as total FROM data GROUP BY 1, 2 ORDER BY 1, 2;
-- Tag: cte_cte_test_select_3973
SELECT UPPER(name) as upper_name, SUM(value) as total FROM data GROUP BY 1 ORDER BY 1;
-- Tag: cte_cte_test_select_3974
SELECT year, month, SUM(amount) as total FROM sales GROUP BY ROLLUP(year, month) ORDER BY year NULLS LAST, month NULLS LAST;
-- Tag: cte_cte_test_select_3975
SELECT category, SUM(value) as total FROM sales GROUP BY ROLLUP(category) ORDER BY category NULLS LAST;
-- Tag: cte_cte_test_select_3976
SELECT a, b, c, SUM(value) as total FROM data GROUP BY ROLLUP(a, b, c);
-- Tag: cte_cte_test_select_3977
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_3978
SELECT a, b, c, SUM(value) as total FROM data GROUP BY CUBE(a, b, c);
-- Tag: cte_cte_test_select_3979
SELECT a, b, SUM(value) as total FROM data GROUP BY CUBE(a, b);
-- Tag: cte_cte_test_select_3980
SELECT region, product, SUM(amount) as total FROM sales GROUP BY GROUPING SETS ((region), (product));
-- Tag: cte_cte_test_select_3981
SELECT category, SUM(value) as total FROM data GROUP BY GROUPING SETS ((category), ());
-- Tag: cte_cte_test_select_3982
SELECT a, b, SUM(value) as total FROM data GROUP BY GROUPING SETS ((a, b), (a), (b), ());
-- Tag: cte_cte_test_select_3983
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_3984
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_3985
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_3986
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_3987
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_3988
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_3989
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_3990
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_3991
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_3992
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_3993
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_3994
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_3995
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_3996
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_3997
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_3998
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_3999
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4000
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4001
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4002
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4003
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, NULL, 20), (3, 'A', 30), (4, NULL, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('A', 30), ('B', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (year INT64, month INT64, value FLOAT64);
INSERT INTO data VALUES (2023, 1, 100.0), (2023, 1, 150.0), (2023, 2, 200.0), (2024, 1, 120.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING, value INT64);
INSERT INTO data VALUES ('alice', 10), ('ALICE', 20), ('bob', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0), (2024, 1, 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20), (1, 2, 1, 30), (2, 1, 1, 40);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, NULL, 10), (NULL, 2, 20), (1, 2, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, 1, 10), (1, 2, 20), (2, 1, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4004
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category NULLS LAST;
-- Tag: cte_cte_test_select_4005
SELECT category, SUM(value) as total FROM data GROUP BY 1 ORDER BY 1;
-- Tag: cte_cte_test_select_4006
SELECT year, month, SUM(value) as total FROM data GROUP BY 1, 2 ORDER BY 1, 2;
-- Tag: cte_cte_test_select_4007
SELECT UPPER(name) as upper_name, SUM(value) as total FROM data GROUP BY 1 ORDER BY 1;
-- Tag: cte_cte_test_select_4008
SELECT year, month, SUM(amount) as total FROM sales GROUP BY ROLLUP(year, month) ORDER BY year NULLS LAST, month NULLS LAST;
-- Tag: cte_cte_test_select_4009
SELECT category, SUM(value) as total FROM sales GROUP BY ROLLUP(category) ORDER BY category NULLS LAST;
-- Tag: cte_cte_test_select_4010
SELECT a, b, c, SUM(value) as total FROM data GROUP BY ROLLUP(a, b, c);
-- Tag: cte_cte_test_select_4011
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_4012
SELECT a, b, c, SUM(value) as total FROM data GROUP BY CUBE(a, b, c);
-- Tag: cte_cte_test_select_4013
SELECT a, b, SUM(value) as total FROM data GROUP BY CUBE(a, b);
-- Tag: cte_cte_test_select_4014
SELECT region, product, SUM(amount) as total FROM sales GROUP BY GROUPING SETS ((region), (product));
-- Tag: cte_cte_test_select_4015
SELECT category, SUM(value) as total FROM data GROUP BY GROUPING SETS ((category), ());
-- Tag: cte_cte_test_select_4016
SELECT a, b, SUM(value) as total FROM data GROUP BY GROUPING SETS ((a, b), (a), (b), ());
-- Tag: cte_cte_test_select_4017
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_4018
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_4019
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_4020
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_4021
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4022
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4023
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4024
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4025
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4026
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4027
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4028
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4029
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4030
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4031
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4032
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4033
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4034
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4035
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4036
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4037
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('A', 30), ('B', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (year INT64, month INT64, value FLOAT64);
INSERT INTO data VALUES (2023, 1, 100.0), (2023, 1, 150.0), (2023, 2, 200.0), (2024, 1, 120.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING, value INT64);
INSERT INTO data VALUES ('alice', 10), ('ALICE', 20), ('bob', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0), (2024, 1, 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20), (1, 2, 1, 30), (2, 1, 1, 40);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, NULL, 10), (NULL, 2, 20), (1, 2, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, 1, 10), (1, 2, 20), (2, 1, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4038
SELECT category, SUM(value) as total FROM data GROUP BY 1 ORDER BY 1;
-- Tag: cte_cte_test_select_4039
SELECT year, month, SUM(value) as total FROM data GROUP BY 1, 2 ORDER BY 1, 2;
-- Tag: cte_cte_test_select_4040
SELECT UPPER(name) as upper_name, SUM(value) as total FROM data GROUP BY 1 ORDER BY 1;
-- Tag: cte_cte_test_select_4041
SELECT year, month, SUM(amount) as total FROM sales GROUP BY ROLLUP(year, month) ORDER BY year NULLS LAST, month NULLS LAST;
-- Tag: cte_cte_test_select_4042
SELECT category, SUM(value) as total FROM sales GROUP BY ROLLUP(category) ORDER BY category NULLS LAST;
-- Tag: cte_cte_test_select_4043
SELECT a, b, c, SUM(value) as total FROM data GROUP BY ROLLUP(a, b, c);
-- Tag: cte_cte_test_select_4044
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_4045
SELECT a, b, c, SUM(value) as total FROM data GROUP BY CUBE(a, b, c);
-- Tag: cte_cte_test_select_4046
SELECT a, b, SUM(value) as total FROM data GROUP BY CUBE(a, b);
-- Tag: cte_cte_test_select_4047
SELECT region, product, SUM(amount) as total FROM sales GROUP BY GROUPING SETS ((region), (product));
-- Tag: cte_cte_test_select_4048
SELECT category, SUM(value) as total FROM data GROUP BY GROUPING SETS ((category), ());
-- Tag: cte_cte_test_select_4049
SELECT a, b, SUM(value) as total FROM data GROUP BY GROUPING SETS ((a, b), (a), (b), ());
-- Tag: cte_cte_test_select_4050
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_4051
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_4052
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_4053
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_4054
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4055
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4056
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4057
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4058
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4059
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4060
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4061
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4062
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4063
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4064
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4065
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4066
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4067
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4068
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4069
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4070
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (year INT64, month INT64, value FLOAT64);
INSERT INTO data VALUES (2023, 1, 100.0), (2023, 1, 150.0), (2023, 2, 200.0), (2024, 1, 120.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING, value INT64);
INSERT INTO data VALUES ('alice', 10), ('ALICE', 20), ('bob', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0), (2024, 1, 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20), (1, 2, 1, 30), (2, 1, 1, 40);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, NULL, 10), (NULL, 2, 20), (1, 2, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, 1, 10), (1, 2, 20), (2, 1, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4071
SELECT year, month, SUM(value) as total FROM data GROUP BY 1, 2 ORDER BY 1, 2;
-- Tag: cte_cte_test_select_4072
SELECT UPPER(name) as upper_name, SUM(value) as total FROM data GROUP BY 1 ORDER BY 1;
-- Tag: cte_cte_test_select_4073
SELECT year, month, SUM(amount) as total FROM sales GROUP BY ROLLUP(year, month) ORDER BY year NULLS LAST, month NULLS LAST;
-- Tag: cte_cte_test_select_4074
SELECT category, SUM(value) as total FROM sales GROUP BY ROLLUP(category) ORDER BY category NULLS LAST;
-- Tag: cte_cte_test_select_4075
SELECT a, b, c, SUM(value) as total FROM data GROUP BY ROLLUP(a, b, c);
-- Tag: cte_cte_test_select_4076
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_4077
SELECT a, b, c, SUM(value) as total FROM data GROUP BY CUBE(a, b, c);
-- Tag: cte_cte_test_select_4078
SELECT a, b, SUM(value) as total FROM data GROUP BY CUBE(a, b);
-- Tag: cte_cte_test_select_4079
SELECT region, product, SUM(amount) as total FROM sales GROUP BY GROUPING SETS ((region), (product));
-- Tag: cte_cte_test_select_4080
SELECT category, SUM(value) as total FROM data GROUP BY GROUPING SETS ((category), ());
-- Tag: cte_cte_test_select_4081
SELECT a, b, SUM(value) as total FROM data GROUP BY GROUPING SETS ((a, b), (a), (b), ());
-- Tag: cte_cte_test_select_4082
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_4083
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_4084
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_4085
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_4086
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4087
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4088
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4089
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4090
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4091
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4092
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4093
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4094
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4095
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4096
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4097
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4098
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4099
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4100
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4101
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4102
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (name STRING, value INT64);
INSERT INTO data VALUES ('alice', 10), ('ALICE', 20), ('bob', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0), (2024, 1, 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20), (1, 2, 1, 30), (2, 1, 1, 40);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, NULL, 10), (NULL, 2, 20), (1, 2, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, 1, 10), (1, 2, 20), (2, 1, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4103
SELECT UPPER(name) as upper_name, SUM(value) as total FROM data GROUP BY 1 ORDER BY 1;
-- Tag: cte_cte_test_select_4104
SELECT year, month, SUM(amount) as total FROM sales GROUP BY ROLLUP(year, month) ORDER BY year NULLS LAST, month NULLS LAST;
-- Tag: cte_cte_test_select_4105
SELECT category, SUM(value) as total FROM sales GROUP BY ROLLUP(category) ORDER BY category NULLS LAST;
-- Tag: cte_cte_test_select_4106
SELECT a, b, c, SUM(value) as total FROM data GROUP BY ROLLUP(a, b, c);
-- Tag: cte_cte_test_select_4107
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_4108
SELECT a, b, c, SUM(value) as total FROM data GROUP BY CUBE(a, b, c);
-- Tag: cte_cte_test_select_4109
SELECT a, b, SUM(value) as total FROM data GROUP BY CUBE(a, b);
-- Tag: cte_cte_test_select_4110
SELECT region, product, SUM(amount) as total FROM sales GROUP BY GROUPING SETS ((region), (product));
-- Tag: cte_cte_test_select_4111
SELECT category, SUM(value) as total FROM data GROUP BY GROUPING SETS ((category), ());
-- Tag: cte_cte_test_select_4112
SELECT a, b, SUM(value) as total FROM data GROUP BY GROUPING SETS ((a, b), (a), (b), ());
-- Tag: cte_cte_test_select_4113
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_4114
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_4115
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_4116
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_4117
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4118
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4119
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4120
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4121
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4122
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4123
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4124
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4125
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4126
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4127
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4128
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4129
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4130
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4131
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4132
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4133
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0), (2024, 1, 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20), (1, 2, 1, 30), (2, 1, 1, 40);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, NULL, 10), (NULL, 2, 20), (1, 2, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, 1, 10), (1, 2, 20), (2, 1, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4134
SELECT year, month, SUM(amount) as total FROM sales GROUP BY ROLLUP(year, month) ORDER BY year NULLS LAST, month NULLS LAST;
-- Tag: cte_cte_test_select_4135
SELECT category, SUM(value) as total FROM sales GROUP BY ROLLUP(category) ORDER BY category NULLS LAST;
-- Tag: cte_cte_test_select_4136
SELECT a, b, c, SUM(value) as total FROM data GROUP BY ROLLUP(a, b, c);
-- Tag: cte_cte_test_select_4137
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_4138
SELECT a, b, c, SUM(value) as total FROM data GROUP BY CUBE(a, b, c);
-- Tag: cte_cte_test_select_4139
SELECT a, b, SUM(value) as total FROM data GROUP BY CUBE(a, b);
-- Tag: cte_cte_test_select_4140
SELECT region, product, SUM(amount) as total FROM sales GROUP BY GROUPING SETS ((region), (product));
-- Tag: cte_cte_test_select_4141
SELECT category, SUM(value) as total FROM data GROUP BY GROUPING SETS ((category), ());
-- Tag: cte_cte_test_select_4142
SELECT a, b, SUM(value) as total FROM data GROUP BY GROUPING SETS ((a, b), (a), (b), ());
-- Tag: cte_cte_test_select_4143
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_4144
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_4145
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_4146
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_4147
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4148
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4149
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4150
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4151
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4152
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4153
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4154
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4155
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4156
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4157
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4158
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4159
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4160
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4161
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4162
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4163
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20), (1, 2, 1, 30), (2, 1, 1, 40);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, NULL, 10), (NULL, 2, 20), (1, 2, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, 1, 10), (1, 2, 20), (2, 1, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4164
SELECT category, SUM(value) as total FROM sales GROUP BY ROLLUP(category) ORDER BY category NULLS LAST;
-- Tag: cte_cte_test_select_4165
SELECT a, b, c, SUM(value) as total FROM data GROUP BY ROLLUP(a, b, c);
-- Tag: cte_cte_test_select_4166
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_4167
SELECT a, b, c, SUM(value) as total FROM data GROUP BY CUBE(a, b, c);
-- Tag: cte_cte_test_select_4168
SELECT a, b, SUM(value) as total FROM data GROUP BY CUBE(a, b);
-- Tag: cte_cte_test_select_4169
SELECT region, product, SUM(amount) as total FROM sales GROUP BY GROUPING SETS ((region), (product));
-- Tag: cte_cte_test_select_4170
SELECT category, SUM(value) as total FROM data GROUP BY GROUPING SETS ((category), ());
-- Tag: cte_cte_test_select_4171
SELECT a, b, SUM(value) as total FROM data GROUP BY GROUPING SETS ((a, b), (a), (b), ());
-- Tag: cte_cte_test_select_4172
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_4173
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_4174
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_4175
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_4176
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4177
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4178
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4179
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4180
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4181
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4182
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4183
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4184
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4185
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4186
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4187
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4188
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4189
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4190
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4191
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4192
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20), (1, 2, 1, 30), (2, 1, 1, 40);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, NULL, 10), (NULL, 2, 20), (1, 2, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, 1, 10), (1, 2, 20), (2, 1, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4193
SELECT a, b, c, SUM(value) as total FROM data GROUP BY ROLLUP(a, b, c);
-- Tag: cte_cte_test_select_4194
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_4195
SELECT a, b, c, SUM(value) as total FROM data GROUP BY CUBE(a, b, c);
-- Tag: cte_cte_test_select_4196
SELECT a, b, SUM(value) as total FROM data GROUP BY CUBE(a, b);
-- Tag: cte_cte_test_select_4197
SELECT region, product, SUM(amount) as total FROM sales GROUP BY GROUPING SETS ((region), (product));
-- Tag: cte_cte_test_select_4198
SELECT category, SUM(value) as total FROM data GROUP BY GROUPING SETS ((category), ());
-- Tag: cte_cte_test_select_4199
SELECT a, b, SUM(value) as total FROM data GROUP BY GROUPING SETS ((a, b), (a), (b), ());
-- Tag: cte_cte_test_select_4200
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_4201
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_4202
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_4203
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_4204
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4205
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4206
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4207
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4208
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4209
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4210
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4211
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4212
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4213
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4214
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4215
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4216
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4217
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4218
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4219
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4220
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, NULL, 10), (NULL, 2, 20), (1, 2, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, 1, 10), (1, 2, 20), (2, 1, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4221
SELECT region, product, SUM(amount) as total FROM sales GROUP BY CUBE(region, product);
-- Tag: cte_cte_test_select_4222
SELECT a, b, c, SUM(value) as total FROM data GROUP BY CUBE(a, b, c);
-- Tag: cte_cte_test_select_4223
SELECT a, b, SUM(value) as total FROM data GROUP BY CUBE(a, b);
-- Tag: cte_cte_test_select_4224
SELECT region, product, SUM(amount) as total FROM sales GROUP BY GROUPING SETS ((region), (product));
-- Tag: cte_cte_test_select_4225
SELECT category, SUM(value) as total FROM data GROUP BY GROUPING SETS ((category), ());
-- Tag: cte_cte_test_select_4226
SELECT a, b, SUM(value) as total FROM data GROUP BY GROUPING SETS ((a, b), (a), (b), ());
-- Tag: cte_cte_test_select_4227
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_4228
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_4229
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_4230
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_4231
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4232
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4233
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4234
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4235
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4236
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4237
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4238
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4239
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4240
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4241
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4242
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4243
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4244
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4245
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4246
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4247
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, c INT64, value INT64);
INSERT INTO data VALUES (1, 1, 1, 10), (1, 1, 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, NULL, 10), (NULL, 2, 20), (1, 2, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, 1, 10), (1, 2, 20), (2, 1, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4248
SELECT a, b, c, SUM(value) as total FROM data GROUP BY CUBE(a, b, c);
-- Tag: cte_cte_test_select_4249
SELECT a, b, SUM(value) as total FROM data GROUP BY CUBE(a, b);
-- Tag: cte_cte_test_select_4250
SELECT region, product, SUM(amount) as total FROM sales GROUP BY GROUPING SETS ((region), (product));
-- Tag: cte_cte_test_select_4251
SELECT category, SUM(value) as total FROM data GROUP BY GROUPING SETS ((category), ());
-- Tag: cte_cte_test_select_4252
SELECT a, b, SUM(value) as total FROM data GROUP BY GROUPING SETS ((a, b), (a), (b), ());
-- Tag: cte_cte_test_select_4253
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_4254
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_4255
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_4256
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_4257
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4258
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4259
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4260
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4261
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4262
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4263
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4264
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4265
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4266
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4267
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4268
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4269
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4270
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4271
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4272
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4273
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, NULL, 10), (NULL, 2, 20), (1, 2, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, 1, 10), (1, 2, 20), (2, 1, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4274
SELECT a, b, SUM(value) as total FROM data GROUP BY CUBE(a, b);
-- Tag: cte_cte_test_select_4275
SELECT region, product, SUM(amount) as total FROM sales GROUP BY GROUPING SETS ((region), (product));
-- Tag: cte_cte_test_select_4276
SELECT category, SUM(value) as total FROM data GROUP BY GROUPING SETS ((category), ());
-- Tag: cte_cte_test_select_4277
SELECT a, b, SUM(value) as total FROM data GROUP BY GROUPING SETS ((a, b), (a), (b), ());
-- Tag: cte_cte_test_select_4278
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_4279
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_4280
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_4281
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_4282
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4283
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4284
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4285
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4286
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4287
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4288
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4289
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4290
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4291
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4292
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4293
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4294
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4295
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4296
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4297
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4298
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('East', 'Gadget', 150.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, 1, 10), (1, 2, 20), (2, 1, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4299
SELECT region, product, SUM(amount) as total FROM sales GROUP BY GROUPING SETS ((region), (product));
-- Tag: cte_cte_test_select_4300
SELECT category, SUM(value) as total FROM data GROUP BY GROUPING SETS ((category), ());
-- Tag: cte_cte_test_select_4301
SELECT a, b, SUM(value) as total FROM data GROUP BY GROUPING SETS ((a, b), (a), (b), ());
-- Tag: cte_cte_test_select_4302
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_4303
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_4304
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_4305
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_4306
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4307
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4308
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4309
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4310
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4311
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4312
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4313
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4314
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4315
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4316
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4317
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4318
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4319
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4320
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4321
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4322
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, 1, 10), (1, 2, 20), (2, 1, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4323
SELECT category, SUM(value) as total FROM data GROUP BY GROUPING SETS ((category), ());
-- Tag: cte_cte_test_select_4324
SELECT a, b, SUM(value) as total FROM data GROUP BY GROUPING SETS ((a, b), (a), (b), ());
-- Tag: cte_cte_test_select_4325
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_4326
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_4327
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_4328
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_4329
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4330
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4331
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4332
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4333
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4334
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4335
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4336
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4337
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4338
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4339
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4340
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4341
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4342
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4343
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4344
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4345
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64, value INT64);
INSERT INTO data VALUES (1, 1, 10), (1, 2, 20), (2, 1, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4346
SELECT a, b, SUM(value) as total FROM data GROUP BY GROUPING SETS ((a, b), (a), (b), ());
-- Tag: cte_cte_test_select_4347
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_4348
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_4349
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_4350
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_4351
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4352
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4353
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4354
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4355
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4356
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4357
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4358
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4359
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4360
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4361
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4362
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4363
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4364
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4365
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4366
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4367
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 200.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4368
SELECT region, SUM(amount) as total, GROUPING(region) as is_subtotal FROM sales GROUP BY ROLLUP(region) ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_4369
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_4370
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_4371
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_4372
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4373
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4374
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4375
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4376
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4377
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4378
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4379
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4380
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4381
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4382
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4383
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4384
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4385
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4386
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4387
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4388
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (year INT64, month INT64, amount FLOAT64);
INSERT INTO sales VALUES (2023, 1, 100.0), (2023, 2, 150.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4389
SELECT year, month, SUM(amount) as total, GROUPING(year) as year_grouped, GROUPING(month) as month_grouped FROM sales GROUP BY ROLLUP(year, month);
-- Tag: cte_cte_test_select_4390
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_4391
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_4392
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4393
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4394
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4395
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4396
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4397
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4398
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4399
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4400
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4401
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4402
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4403
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4404
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4405
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4406
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4407
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4408
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4409
SELECT category, SUM(value) as total FROM data GROUP BY ROLLUP(category) HAVING GROUPING(category) = 1;
-- Tag: cte_cte_test_select_4410
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_4411
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4412
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4413
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4414
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4415
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4416
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4417
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4418
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4419
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4420
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4421
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4422
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4423
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4424
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4425
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4426
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4427
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4428
SELECT category, SUM(value) as total, GROUPING(category) as grp FROM data GROUP BY ROLLUP(category) ORDER BY GROUPING(category) DESC, category;
-- Tag: cte_cte_test_select_4429
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4430
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4431
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4432
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4433
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4434
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4435
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4436
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4437
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4438
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4439
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4440
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4441
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4442
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4443
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4444
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4445
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4446
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4447
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4448
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4449
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4450
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4451
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4452
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4453
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4454
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4455
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4456
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4457
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4458
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4459
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4460
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4461
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4462
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('A', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4463
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4464
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4465
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4466
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4467
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4468
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4469
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4470
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4471
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4472
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4473
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4474
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4475
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4476
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4477
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4478
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4479
SELECT id, SUM(value) as total FROM data GROUP BY id;
-- Tag: cte_cte_test_select_4480
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4481
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4482
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4483
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4484
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4485
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4486
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4487
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4488
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4489
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4490
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4491
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4492
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4493
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES (NULL, 10), (NULL, 20), (NULL, 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4494
SELECT category, SUM(value) as total FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4495
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4496
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4497
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4498
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4499
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4500
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4501
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4502
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4503
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4504
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4505
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4506
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4507
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 150.0), ('B', 50.0), ('C', 200.0), ('C', 250.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4508
SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) > 200 ORDER BY product;
-- Tag: cte_cte_test_select_4509
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4510
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4511
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4512
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4513
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4514
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4515
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4516
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4517
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4518
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4519
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4520
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 30), ('C', 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4521
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY SUM(value) DESC;
-- Tag: cte_cte_test_select_4522
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4523
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4524
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4525
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4526
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4527
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4528
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4529
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4530
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4531
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4532
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('B', 20), ('C', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4533
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category LIMIT 2;
-- Tag: cte_cte_test_select_4534
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4535
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4536
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4537
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4538
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4539
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4540
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4541
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4542
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4543
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 100.0), ('West', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4544
SELECT region, SUM(amount) as total FROM sales GROUP BY ROLLUP(region) HAVING SUM(amount) >= 100;
-- Tag: cte_cte_test_select_4545
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4546
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4547
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4548
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4549
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4550
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4551
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4552
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4553
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4554
SELECT category, SUM(value) FROM data GROUP BY 0;
-- Tag: cte_cte_test_select_4555
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4556
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4557
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4558
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4559
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4560
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4561
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4562
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4563
SELECT category, SUM(value) FROM data GROUP BY 5;
-- Tag: cte_cte_test_select_4564
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4565
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4566
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4567
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4568
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4569
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4570
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4571
SELECT category, SUM(value) FROM data GROUP BY undefined_col;
-- Tag: cte_cte_test_select_4572
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4573
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4574
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4575
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4576
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4577
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, id INT64, value INT64);
INSERT INTO data VALUES ('A', 1, 10), ('A', 2, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4578
SELECT category, id, SUM(value) FROM data GROUP BY category;
-- Tag: cte_cte_test_select_4579
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4580
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4581
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4582
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4583
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4584
SELECT category FROM data GROUP BY SUM(value);
-- Tag: cte_cte_test_select_4585
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4586
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4587
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4588
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_4589
SELECT * FROM ( SELECT category, SUM(value) as total FROM data GROUP BY category ) AS sub WHERE total > 15 ORDER BY category;
WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4590
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4591
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4592
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount FLOAT64);
INSERT INTO sales VALUES ('East', 'Widget', 100.0), ('West', 'Widget', 200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

WITH aggregated AS ( SELECT category, SUM(value) as total FROM data GROUP BY category ) SELECT category FROM aggregated WHERE total > 15;
-- Tag: cte_cte_test_select_4593
SELECT region, product, SUM(amount) as total, GROUPING(region) + GROUPING(product) as grouping_level FROM sales GROUP BY CUBE(region, product) ORDER BY grouping_level DESC, region, product;
-- Tag: cte_cte_test_select_4594
SELECT category, SUM(value) as total FROM data GROUP BY category ORDER BY category;
-- Tag: cte_cte_test_select_4595
SELECT id, SUM(value) as total FROM data GROUP BY id;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES ('East', 100), ('West', 200);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('East', 'A', 100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data ( a STRING, b STRING, c STRING, d STRING, value INT64 );
INSERT INTO data VALUES ('a1', 'b1', 'c1', 'd1', 100);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);

WITH regional_summary AS ( SELECT region, SUM(amount) AS total FROM sales GROUP BY GROUPING SETS ((region), ()) ) SELECT * FROM regional_summary ORDER BY region NULLS LAST;
-- Tag: cte_cte_test_select_4596
SELECT region, SUM(amount), GROUPING(product) FROM sales GROUP BY region;
-- Tag: cte_cte_test_select_4597
SELECT SUM(value) FROM data GROUP BY GROUPING SETS ();
-- Tag: cte_cte_test_select_4598
SELECT a, b, c, d, SUM(value) FROM data GROUP BY CUBE(a, b, c, d);
-- Tag: cte_cte_test_select_4599
SELECT region, product, SUM(amount) AS total FROM sales GROUP BY ROLLUP(region, product);

DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, level STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, points INT64);
INSERT INTO users VALUES (1, 'beginner'), (2, 'beginner');
INSERT INTO scores VALUES (1, 1000), (2, 500);
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

WITH high_scorers AS ( \ SELECT user_id FROM scores WHERE points >= 1000 \ ) \ UPDATE users \ SET level = 'advanced' \ FROM high_scorers \ WHERE users.id = high_scorers.user_id;
-- Tag: cte_cte_test_select_4600
SELECT level FROM users WHERE id = 1;
WITH inactive AS ( \ SELECT user_id FROM activity WHERE last_active > 60 \ ) \ DELETE FROM sessions \ USING inactive \ WHERE sessions.user_id = inactive.user_id;
-- Tag: cte_cte_test_select_4601
SELECT COUNT(*) FROM sessions;
UPDATE t1 \ SET value = t2.value \ FROM t2 \ WHERE id = t2.id;
DELETE FROM users \ USING filter \ WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \ SET value = n2.value + 1 \ FROM nums n2 \ WHERE n1.id = n2.id;
-- Tag: cte_cte_test_select_4602
SELECT value FROM nums WHERE id = 1;
UPDATE items \ SET price = items.price * price_changes.multiplier \ FROM price_changes \ WHERE items.id = price_changes.item_id;
-- Tag: cte_cte_test_select_4603
SELECT price FROM items WHERE id = 1;
-- Tag: cte_cte_test_select_4604
SELECT price FROM items WHERE id = 100;
DELETE FROM records \ USING to_remove \ WHERE records.id = to_remove.record_id;
-- Tag: cte_cte_test_select_4605
SELECT COUNT(*) FROM records;

DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

WITH inactive AS ( \ SELECT user_id FROM activity WHERE last_active > 60 \ ) \ DELETE FROM sessions \ USING inactive \ WHERE sessions.user_id = inactive.user_id;
-- Tag: cte_cte_test_select_4606
SELECT COUNT(*) FROM sessions;
UPDATE t1 \ SET value = t2.value \ FROM t2 \ WHERE id = t2.id;
DELETE FROM users \ USING filter \ WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \ SET value = n2.value + 1 \ FROM nums n2 \ WHERE n1.id = n2.id;
-- Tag: cte_cte_test_select_4607
SELECT value FROM nums WHERE id = 1;
UPDATE items \ SET price = items.price * price_changes.multiplier \ FROM price_changes \ WHERE items.id = price_changes.item_id;
-- Tag: cte_cte_test_select_4608
SELECT price FROM items WHERE id = 1;
-- Tag: cte_cte_test_select_4609
SELECT price FROM items WHERE id = 100;
DELETE FROM records \ USING to_remove \ WHERE records.id = to_remove.record_id;
-- Tag: cte_cte_test_select_4610
SELECT COUNT(*) FROM records;

DROP TABLE IF EXISTS tree;
CREATE TABLE tree (id INT64, data JSON);
DROP TABLE IF EXISTS concurrent;
CREATE TABLE concurrent (id INT64, data JSON);
DROP TABLE IF EXISTS writes;
CREATE TABLE writes (id INT64, data JSON);
DROP TABLE IF EXISTS perf;
CREATE TABLE perf (id INT64, data JSON);
DROP TABLE IF EXISTS extract_perf;
CREATE TABLE extract_perf (id INT64, data JSON);

WITH RECURSIVE tree_path AS ( SELECT id, JSON_VALUE(data, '$.name') as name FROM tree WHERE JSON_VALUE(data, '$.parent') IS NULL UNION ALL SELECT t.id, JSON_VALUE(t.data, '$.name') FROM tree t JOIN tree_path tp ON CAST(JSON_VALUE(t.data, '$.parent') AS INT64) = tp.id ) SELECT * FROM tree_path;
-- Tag: cte_cte_test_select_4611
SELECT JSON_VALUE(data, '$.value') FROM concurrent WHERE id = 1;
-- Tag: cte_cte_test_select_4612
SELECT COUNT(*) FROM writes;
-- Tag: cte_cte_test_select_4613
SELECT JSON_EXTRACT(data, '$.nested.value') FROM extract_perf;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, active BOOL);
INSERT INTO t1 VALUES (1, TRUE), (2, FALSE);
INSERT INTO t2 VALUES (3, TRUE), (4, FALSE);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, is_cancelled BOOL, amount FLOAT64);
INSERT INTO orders VALUES (1, FALSE, 100.0), (2, TRUE, 50.0), (3, FALSE, 200.0), (4, TRUE, 30.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, active BOOL, last_login TIMESTAMP);
INSERT INTO users VALUES (1, TRUE, CURRENT_TIMESTAMP), (2, FALSE, CURRENT_TIMESTAMP);
DROP TABLE IF EXISTS temp_data;
CREATE TABLE temp_data (id INT64, keep BOOL);
INSERT INTO temp_data VALUES (1, TRUE), (2, FALSE), (3, TRUE), (4, FALSE);

-- Tag: cte_cte_test_select_4614
SELECT id FROM t1 WHERE NOT active UNION SELECT id FROM t2 WHERE NOT active ORDER BY id;
WITH active_orders AS ( SELECT order_id, amount FROM orders WHERE NOT is_cancelled ) SELECT SUM(amount) as total FROM active_orders;
UPDATE users SET active = TRUE WHERE NOT active;
-- Tag: cte_cte_test_select_4615
SELECT COUNT(*) as cnt FROM users WHERE active;
DELETE FROM temp_data WHERE NOT keep;
-- Tag: cte_cte_test_select_4616
SELECT COUNT(*) as cnt FROM temp_data;

DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, is_cancelled BOOL, amount FLOAT64);
INSERT INTO orders VALUES (1, FALSE, 100.0), (2, TRUE, 50.0), (3, FALSE, 200.0), (4, TRUE, 30.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, active BOOL, last_login TIMESTAMP);
INSERT INTO users VALUES (1, TRUE, CURRENT_TIMESTAMP), (2, FALSE, CURRENT_TIMESTAMP);
DROP TABLE IF EXISTS temp_data;
CREATE TABLE temp_data (id INT64, keep BOOL);
INSERT INTO temp_data VALUES (1, TRUE), (2, FALSE), (3, TRUE), (4, FALSE);

WITH active_orders AS ( SELECT order_id, amount FROM orders WHERE NOT is_cancelled ) SELECT SUM(amount) as total FROM active_orders;
UPDATE users SET active = TRUE WHERE NOT active;
-- Tag: cte_cte_test_select_4617
SELECT COUNT(*) as cnt FROM users WHERE active;
DELETE FROM temp_data WHERE NOT keep;
-- Tag: cte_cte_test_select_4618
SELECT COUNT(*) as cnt FROM temp_data;

DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old_value');
INSERT INTO source VALUES (1, 'new_value');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, name STRING, status STRING, version INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, name STRING, status STRING);
INSERT INTO target VALUES (1, 'Alice', 'active', 1);
INSERT INTO source VALUES (1, 'Alice Updated', 'inactive');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'existing');
INSERT INTO source VALUES (2, 'new_value');
DROP TABLE IF EXISTS target;
CREATE TABLE target ( id INT64, value STRING, status STRING DEFAULT 'pending', created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'new_value');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old_value');
INSERT INTO source VALUES (1, 'updated_value'), (2, 'new_value');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'a'), (2, 'b');
INSERT INTO source VALUES (1, 'aa'), (2, 'bb');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'a'), (2, 'b');
INSERT INTO source VALUES (3, 'c'), (4, 'd');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep'), (2, 'delete_me'), (3, 'delete_me_too');
INSERT INTO source VALUES (1, 'updated');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'update_me'), (2, 'delete_me'), (3, 'keep');
INSERT INTO source VALUES (1, 'updated'), (3, 'keep'), (4, 'new');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, status STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'active'), (2, 20, 'inactive');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, category STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'A'), (2, 20, 'B');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, total INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 100);
INSERT INTO orders VALUES (1, 10), (1, 20), (2, 30);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old');
INSERT INTO staging VALUES (1, 'new'), (2, 'inserted');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep_me');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'a'), (2, 'b');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (NULL, 'target_null'), (1, 'target_1');
INSERT INTO source VALUES (NULL, 'source_null'), (1, 'source_1');
DROP TABLE IF EXISTS target;
CREATE TABLE target (order_id INT64, product_id INT64, quantity INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (order_id INT64, product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 101, 5);
INSERT INTO source VALUES (1, 101, 10), (1, 102, 20);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
INSERT INTO source VALUES (1, 'duplicate1'), (1, 'duplicate2');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 'string');
INSERT INTO source VALUES (1, 123);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, 'B', 20), (3, 'A', 30);

MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4619
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name, status = S.status, version = T.version + 1;
-- Tag: cte_cte_test_select_4620
SELECT name, status, version FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4621
SELECT COUNT(*) FROM target;
-- Tag: cte_cte_test_select_4622
SELECT value FROM target WHERE id = 2;
MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4623
SELECT status FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4624
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4625
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4626
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED BY SOURCE THEN DELETE;
-- Tag: cte_cte_test_select_4627
SELECT COUNT(*) FROM target;
-- Tag: cte_cte_test_select_4628
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value) WHEN NOT MATCHED BY SOURCE THEN DELETE;
-- Tag: cte_cte_test_select_4629
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.status = 'active' THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4630
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.category = 'A' THEN UPDATE SET value = S.value * 2 WHEN MATCHED AND T.category = 'B' THEN UPDATE SET value = S.value * 3 WHEN MATCHED THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4631
SELECT value FROM target WHERE id = 1;
-- Tag: cte_cte_test_select_4632
SELECT value FROM target WHERE id = 2;
MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED AND S.value > 100 THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4633
SELECT id FROM target ORDER BY id;
MERGE target T USING (SELECT product_id as id, SUM(quantity) as qty FROM orders GROUP BY product_id) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET total = T.total + S.qty WHEN NOT MATCHED THEN INSERT (id, total) VALUES (S.id, S.qty);
-- Tag: cte_cte_test_select_4634
SELECT id, total FROM target ORDER BY id;
WITH source_cte AS ( SELECT id, value FROM staging WHERE id <= 2 ) MERGE target T USING source_cte S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4635
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4636
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4637
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4638
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.order_id = S.order_id AND T.product_id = S.product_id WHEN MATCHED THEN UPDATE SET quantity = S.quantity WHEN NOT MATCHED THEN INSERT (order_id, product_id, quantity) VALUES (S.order_id, S.product_id, S.quantity);
-- Tag: cte_cte_test_select_4639
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.nonexistent = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4640
SELECT COUNT(*) FROM target;
MERGE data T USING (SELECT category, SUM(value) as total FROM data WHERE category = 'A' GROUP BY category) S ON T.category = S.category WHEN MATCHED THEN UPDATE SET value = S.total;
-- Tag: cte_cte_test_select_4641
SELECT value FROM data WHERE category = 'A';

DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, name STRING, status STRING, version INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, name STRING, status STRING);
INSERT INTO target VALUES (1, 'Alice', 'active', 1);
INSERT INTO source VALUES (1, 'Alice Updated', 'inactive');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'existing');
INSERT INTO source VALUES (2, 'new_value');
DROP TABLE IF EXISTS target;
CREATE TABLE target ( id INT64, value STRING, status STRING DEFAULT 'pending', created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'new_value');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old_value');
INSERT INTO source VALUES (1, 'updated_value'), (2, 'new_value');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'a'), (2, 'b');
INSERT INTO source VALUES (1, 'aa'), (2, 'bb');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'a'), (2, 'b');
INSERT INTO source VALUES (3, 'c'), (4, 'd');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep'), (2, 'delete_me'), (3, 'delete_me_too');
INSERT INTO source VALUES (1, 'updated');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'update_me'), (2, 'delete_me'), (3, 'keep');
INSERT INTO source VALUES (1, 'updated'), (3, 'keep'), (4, 'new');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, status STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'active'), (2, 20, 'inactive');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, category STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'A'), (2, 20, 'B');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, total INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 100);
INSERT INTO orders VALUES (1, 10), (1, 20), (2, 30);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old');
INSERT INTO staging VALUES (1, 'new'), (2, 'inserted');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep_me');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'a'), (2, 'b');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (NULL, 'target_null'), (1, 'target_1');
INSERT INTO source VALUES (NULL, 'source_null'), (1, 'source_1');
DROP TABLE IF EXISTS target;
CREATE TABLE target (order_id INT64, product_id INT64, quantity INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (order_id INT64, product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 101, 5);
INSERT INTO source VALUES (1, 101, 10), (1, 102, 20);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
INSERT INTO source VALUES (1, 'duplicate1'), (1, 'duplicate2');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 'string');
INSERT INTO source VALUES (1, 123);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, 'B', 20), (3, 'A', 30);

MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name, status = S.status, version = T.version + 1;
-- Tag: cte_cte_test_select_4642
SELECT name, status, version FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4643
SELECT COUNT(*) FROM target;
-- Tag: cte_cte_test_select_4644
SELECT value FROM target WHERE id = 2;
MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4645
SELECT status FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4646
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4647
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4648
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED BY SOURCE THEN DELETE;
-- Tag: cte_cte_test_select_4649
SELECT COUNT(*) FROM target;
-- Tag: cte_cte_test_select_4650
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value) WHEN NOT MATCHED BY SOURCE THEN DELETE;
-- Tag: cte_cte_test_select_4651
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.status = 'active' THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4652
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.category = 'A' THEN UPDATE SET value = S.value * 2 WHEN MATCHED AND T.category = 'B' THEN UPDATE SET value = S.value * 3 WHEN MATCHED THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4653
SELECT value FROM target WHERE id = 1;
-- Tag: cte_cte_test_select_4654
SELECT value FROM target WHERE id = 2;
MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED AND S.value > 100 THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4655
SELECT id FROM target ORDER BY id;
MERGE target T USING (SELECT product_id as id, SUM(quantity) as qty FROM orders GROUP BY product_id) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET total = T.total + S.qty WHEN NOT MATCHED THEN INSERT (id, total) VALUES (S.id, S.qty);
-- Tag: cte_cte_test_select_4656
SELECT id, total FROM target ORDER BY id;
WITH source_cte AS ( SELECT id, value FROM staging WHERE id <= 2 ) MERGE target T USING source_cte S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4657
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4658
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4659
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4660
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.order_id = S.order_id AND T.product_id = S.product_id WHEN MATCHED THEN UPDATE SET quantity = S.quantity WHEN NOT MATCHED THEN INSERT (order_id, product_id, quantity) VALUES (S.order_id, S.product_id, S.quantity);
-- Tag: cte_cte_test_select_4661
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.nonexistent = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4662
SELECT COUNT(*) FROM target;
MERGE data T USING (SELECT category, SUM(value) as total FROM data WHERE category = 'A' GROUP BY category) S ON T.category = S.category WHEN MATCHED THEN UPDATE SET value = S.total;
-- Tag: cte_cte_test_select_4663
SELECT value FROM data WHERE category = 'A';

DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'existing');
INSERT INTO source VALUES (2, 'new_value');
DROP TABLE IF EXISTS target;
CREATE TABLE target ( id INT64, value STRING, status STRING DEFAULT 'pending', created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'new_value');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old_value');
INSERT INTO source VALUES (1, 'updated_value'), (2, 'new_value');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'a'), (2, 'b');
INSERT INTO source VALUES (1, 'aa'), (2, 'bb');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'a'), (2, 'b');
INSERT INTO source VALUES (3, 'c'), (4, 'd');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep'), (2, 'delete_me'), (3, 'delete_me_too');
INSERT INTO source VALUES (1, 'updated');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'update_me'), (2, 'delete_me'), (3, 'keep');
INSERT INTO source VALUES (1, 'updated'), (3, 'keep'), (4, 'new');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, status STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'active'), (2, 20, 'inactive');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, category STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'A'), (2, 20, 'B');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, total INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 100);
INSERT INTO orders VALUES (1, 10), (1, 20), (2, 30);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old');
INSERT INTO staging VALUES (1, 'new'), (2, 'inserted');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep_me');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'a'), (2, 'b');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (NULL, 'target_null'), (1, 'target_1');
INSERT INTO source VALUES (NULL, 'source_null'), (1, 'source_1');
DROP TABLE IF EXISTS target;
CREATE TABLE target (order_id INT64, product_id INT64, quantity INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (order_id INT64, product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 101, 5);
INSERT INTO source VALUES (1, 101, 10), (1, 102, 20);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
INSERT INTO source VALUES (1, 'duplicate1'), (1, 'duplicate2');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 'string');
INSERT INTO source VALUES (1, 123);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, 'B', 20), (3, 'A', 30);

MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4664
SELECT COUNT(*) FROM target;
-- Tag: cte_cte_test_select_4665
SELECT value FROM target WHERE id = 2;
MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4666
SELECT status FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4667
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4668
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4669
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED BY SOURCE THEN DELETE;
-- Tag: cte_cte_test_select_4670
SELECT COUNT(*) FROM target;
-- Tag: cte_cte_test_select_4671
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value) WHEN NOT MATCHED BY SOURCE THEN DELETE;
-- Tag: cte_cte_test_select_4672
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.status = 'active' THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4673
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.category = 'A' THEN UPDATE SET value = S.value * 2 WHEN MATCHED AND T.category = 'B' THEN UPDATE SET value = S.value * 3 WHEN MATCHED THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4674
SELECT value FROM target WHERE id = 1;
-- Tag: cte_cte_test_select_4675
SELECT value FROM target WHERE id = 2;
MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED AND S.value > 100 THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4676
SELECT id FROM target ORDER BY id;
MERGE target T USING (SELECT product_id as id, SUM(quantity) as qty FROM orders GROUP BY product_id) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET total = T.total + S.qty WHEN NOT MATCHED THEN INSERT (id, total) VALUES (S.id, S.qty);
-- Tag: cte_cte_test_select_4677
SELECT id, total FROM target ORDER BY id;
WITH source_cte AS ( SELECT id, value FROM staging WHERE id <= 2 ) MERGE target T USING source_cte S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4678
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4679
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4680
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4681
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.order_id = S.order_id AND T.product_id = S.product_id WHEN MATCHED THEN UPDATE SET quantity = S.quantity WHEN NOT MATCHED THEN INSERT (order_id, product_id, quantity) VALUES (S.order_id, S.product_id, S.quantity);
-- Tag: cte_cte_test_select_4682
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.nonexistent = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4683
SELECT COUNT(*) FROM target;
MERGE data T USING (SELECT category, SUM(value) as total FROM data WHERE category = 'A' GROUP BY category) S ON T.category = S.category WHEN MATCHED THEN UPDATE SET value = S.total;
-- Tag: cte_cte_test_select_4684
SELECT value FROM data WHERE category = 'A';

DROP TABLE IF EXISTS target;
CREATE TABLE target ( id INT64, value STRING, status STRING DEFAULT 'pending', created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'new_value');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old_value');
INSERT INTO source VALUES (1, 'updated_value'), (2, 'new_value');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'a'), (2, 'b');
INSERT INTO source VALUES (1, 'aa'), (2, 'bb');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'a'), (2, 'b');
INSERT INTO source VALUES (3, 'c'), (4, 'd');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep'), (2, 'delete_me'), (3, 'delete_me_too');
INSERT INTO source VALUES (1, 'updated');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'update_me'), (2, 'delete_me'), (3, 'keep');
INSERT INTO source VALUES (1, 'updated'), (3, 'keep'), (4, 'new');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, status STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'active'), (2, 20, 'inactive');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, category STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'A'), (2, 20, 'B');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, total INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 100);
INSERT INTO orders VALUES (1, 10), (1, 20), (2, 30);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old');
INSERT INTO staging VALUES (1, 'new'), (2, 'inserted');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep_me');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'a'), (2, 'b');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (NULL, 'target_null'), (1, 'target_1');
INSERT INTO source VALUES (NULL, 'source_null'), (1, 'source_1');
DROP TABLE IF EXISTS target;
CREATE TABLE target (order_id INT64, product_id INT64, quantity INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (order_id INT64, product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 101, 5);
INSERT INTO source VALUES (1, 101, 10), (1, 102, 20);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
INSERT INTO source VALUES (1, 'duplicate1'), (1, 'duplicate2');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 'string');
INSERT INTO source VALUES (1, 123);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, 'B', 20), (3, 'A', 30);

MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4685
SELECT status FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4686
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4687
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4688
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED BY SOURCE THEN DELETE;
-- Tag: cte_cte_test_select_4689
SELECT COUNT(*) FROM target;
-- Tag: cte_cte_test_select_4690
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value) WHEN NOT MATCHED BY SOURCE THEN DELETE;
-- Tag: cte_cte_test_select_4691
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.status = 'active' THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4692
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.category = 'A' THEN UPDATE SET value = S.value * 2 WHEN MATCHED AND T.category = 'B' THEN UPDATE SET value = S.value * 3 WHEN MATCHED THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4693
SELECT value FROM target WHERE id = 1;
-- Tag: cte_cte_test_select_4694
SELECT value FROM target WHERE id = 2;
MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED AND S.value > 100 THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4695
SELECT id FROM target ORDER BY id;
MERGE target T USING (SELECT product_id as id, SUM(quantity) as qty FROM orders GROUP BY product_id) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET total = T.total + S.qty WHEN NOT MATCHED THEN INSERT (id, total) VALUES (S.id, S.qty);
-- Tag: cte_cte_test_select_4696
SELECT id, total FROM target ORDER BY id;
WITH source_cte AS ( SELECT id, value FROM staging WHERE id <= 2 ) MERGE target T USING source_cte S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4697
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4698
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4699
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4700
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.order_id = S.order_id AND T.product_id = S.product_id WHEN MATCHED THEN UPDATE SET quantity = S.quantity WHEN NOT MATCHED THEN INSERT (order_id, product_id, quantity) VALUES (S.order_id, S.product_id, S.quantity);
-- Tag: cte_cte_test_select_4701
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.nonexistent = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4702
SELECT COUNT(*) FROM target;
MERGE data T USING (SELECT category, SUM(value) as total FROM data WHERE category = 'A' GROUP BY category) S ON T.category = S.category WHEN MATCHED THEN UPDATE SET value = S.total;
-- Tag: cte_cte_test_select_4703
SELECT value FROM data WHERE category = 'A';

DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old_value');
INSERT INTO source VALUES (1, 'updated_value'), (2, 'new_value');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'a'), (2, 'b');
INSERT INTO source VALUES (1, 'aa'), (2, 'bb');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'a'), (2, 'b');
INSERT INTO source VALUES (3, 'c'), (4, 'd');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep'), (2, 'delete_me'), (3, 'delete_me_too');
INSERT INTO source VALUES (1, 'updated');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'update_me'), (2, 'delete_me'), (3, 'keep');
INSERT INTO source VALUES (1, 'updated'), (3, 'keep'), (4, 'new');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, status STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'active'), (2, 20, 'inactive');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, category STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'A'), (2, 20, 'B');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, total INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 100);
INSERT INTO orders VALUES (1, 10), (1, 20), (2, 30);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old');
INSERT INTO staging VALUES (1, 'new'), (2, 'inserted');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep_me');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'a'), (2, 'b');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (NULL, 'target_null'), (1, 'target_1');
INSERT INTO source VALUES (NULL, 'source_null'), (1, 'source_1');
DROP TABLE IF EXISTS target;
CREATE TABLE target (order_id INT64, product_id INT64, quantity INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (order_id INT64, product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 101, 5);
INSERT INTO source VALUES (1, 101, 10), (1, 102, 20);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
INSERT INTO source VALUES (1, 'duplicate1'), (1, 'duplicate2');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 'string');
INSERT INTO source VALUES (1, 123);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, 'B', 20), (3, 'A', 30);

MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4704
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4705
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4706
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED BY SOURCE THEN DELETE;
-- Tag: cte_cte_test_select_4707
SELECT COUNT(*) FROM target;
-- Tag: cte_cte_test_select_4708
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value) WHEN NOT MATCHED BY SOURCE THEN DELETE;
-- Tag: cte_cte_test_select_4709
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.status = 'active' THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4710
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.category = 'A' THEN UPDATE SET value = S.value * 2 WHEN MATCHED AND T.category = 'B' THEN UPDATE SET value = S.value * 3 WHEN MATCHED THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4711
SELECT value FROM target WHERE id = 1;
-- Tag: cte_cte_test_select_4712
SELECT value FROM target WHERE id = 2;
MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED AND S.value > 100 THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4713
SELECT id FROM target ORDER BY id;
MERGE target T USING (SELECT product_id as id, SUM(quantity) as qty FROM orders GROUP BY product_id) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET total = T.total + S.qty WHEN NOT MATCHED THEN INSERT (id, total) VALUES (S.id, S.qty);
-- Tag: cte_cte_test_select_4714
SELECT id, total FROM target ORDER BY id;
WITH source_cte AS ( SELECT id, value FROM staging WHERE id <= 2 ) MERGE target T USING source_cte S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4715
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4716
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4717
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4718
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.order_id = S.order_id AND T.product_id = S.product_id WHEN MATCHED THEN UPDATE SET quantity = S.quantity WHEN NOT MATCHED THEN INSERT (order_id, product_id, quantity) VALUES (S.order_id, S.product_id, S.quantity);
-- Tag: cte_cte_test_select_4719
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.nonexistent = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4720
SELECT COUNT(*) FROM target;
MERGE data T USING (SELECT category, SUM(value) as total FROM data WHERE category = 'A' GROUP BY category) S ON T.category = S.category WHEN MATCHED THEN UPDATE SET value = S.total;
-- Tag: cte_cte_test_select_4721
SELECT value FROM data WHERE category = 'A';

DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'a'), (2, 'b');
INSERT INTO source VALUES (1, 'aa'), (2, 'bb');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'a'), (2, 'b');
INSERT INTO source VALUES (3, 'c'), (4, 'd');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep'), (2, 'delete_me'), (3, 'delete_me_too');
INSERT INTO source VALUES (1, 'updated');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'update_me'), (2, 'delete_me'), (3, 'keep');
INSERT INTO source VALUES (1, 'updated'), (3, 'keep'), (4, 'new');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, status STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'active'), (2, 20, 'inactive');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, category STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'A'), (2, 20, 'B');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, total INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 100);
INSERT INTO orders VALUES (1, 10), (1, 20), (2, 30);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old');
INSERT INTO staging VALUES (1, 'new'), (2, 'inserted');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep_me');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'a'), (2, 'b');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (NULL, 'target_null'), (1, 'target_1');
INSERT INTO source VALUES (NULL, 'source_null'), (1, 'source_1');
DROP TABLE IF EXISTS target;
CREATE TABLE target (order_id INT64, product_id INT64, quantity INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (order_id INT64, product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 101, 5);
INSERT INTO source VALUES (1, 101, 10), (1, 102, 20);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
INSERT INTO source VALUES (1, 'duplicate1'), (1, 'duplicate2');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 'string');
INSERT INTO source VALUES (1, 123);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, 'B', 20), (3, 'A', 30);

MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4722
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4723
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED BY SOURCE THEN DELETE;
-- Tag: cte_cte_test_select_4724
SELECT COUNT(*) FROM target;
-- Tag: cte_cte_test_select_4725
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value) WHEN NOT MATCHED BY SOURCE THEN DELETE;
-- Tag: cte_cte_test_select_4726
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.status = 'active' THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4727
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.category = 'A' THEN UPDATE SET value = S.value * 2 WHEN MATCHED AND T.category = 'B' THEN UPDATE SET value = S.value * 3 WHEN MATCHED THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4728
SELECT value FROM target WHERE id = 1;
-- Tag: cte_cte_test_select_4729
SELECT value FROM target WHERE id = 2;
MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED AND S.value > 100 THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4730
SELECT id FROM target ORDER BY id;
MERGE target T USING (SELECT product_id as id, SUM(quantity) as qty FROM orders GROUP BY product_id) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET total = T.total + S.qty WHEN NOT MATCHED THEN INSERT (id, total) VALUES (S.id, S.qty);
-- Tag: cte_cte_test_select_4731
SELECT id, total FROM target ORDER BY id;
WITH source_cte AS ( SELECT id, value FROM staging WHERE id <= 2 ) MERGE target T USING source_cte S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4732
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4733
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4734
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4735
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.order_id = S.order_id AND T.product_id = S.product_id WHEN MATCHED THEN UPDATE SET quantity = S.quantity WHEN NOT MATCHED THEN INSERT (order_id, product_id, quantity) VALUES (S.order_id, S.product_id, S.quantity);
-- Tag: cte_cte_test_select_4736
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.nonexistent = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4737
SELECT COUNT(*) FROM target;
MERGE data T USING (SELECT category, SUM(value) as total FROM data WHERE category = 'A' GROUP BY category) S ON T.category = S.category WHEN MATCHED THEN UPDATE SET value = S.total;
-- Tag: cte_cte_test_select_4738
SELECT value FROM data WHERE category = 'A';

DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'a'), (2, 'b');
INSERT INTO source VALUES (3, 'c'), (4, 'd');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep'), (2, 'delete_me'), (3, 'delete_me_too');
INSERT INTO source VALUES (1, 'updated');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'update_me'), (2, 'delete_me'), (3, 'keep');
INSERT INTO source VALUES (1, 'updated'), (3, 'keep'), (4, 'new');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, status STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'active'), (2, 20, 'inactive');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, category STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'A'), (2, 20, 'B');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, total INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 100);
INSERT INTO orders VALUES (1, 10), (1, 20), (2, 30);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old');
INSERT INTO staging VALUES (1, 'new'), (2, 'inserted');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep_me');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'a'), (2, 'b');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (NULL, 'target_null'), (1, 'target_1');
INSERT INTO source VALUES (NULL, 'source_null'), (1, 'source_1');
DROP TABLE IF EXISTS target;
CREATE TABLE target (order_id INT64, product_id INT64, quantity INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (order_id INT64, product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 101, 5);
INSERT INTO source VALUES (1, 101, 10), (1, 102, 20);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
INSERT INTO source VALUES (1, 'duplicate1'), (1, 'duplicate2');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 'string');
INSERT INTO source VALUES (1, 123);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, 'B', 20), (3, 'A', 30);

MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4739
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED BY SOURCE THEN DELETE;
-- Tag: cte_cte_test_select_4740
SELECT COUNT(*) FROM target;
-- Tag: cte_cte_test_select_4741
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value) WHEN NOT MATCHED BY SOURCE THEN DELETE;
-- Tag: cte_cte_test_select_4742
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.status = 'active' THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4743
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.category = 'A' THEN UPDATE SET value = S.value * 2 WHEN MATCHED AND T.category = 'B' THEN UPDATE SET value = S.value * 3 WHEN MATCHED THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4744
SELECT value FROM target WHERE id = 1;
-- Tag: cte_cte_test_select_4745
SELECT value FROM target WHERE id = 2;
MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED AND S.value > 100 THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4746
SELECT id FROM target ORDER BY id;
MERGE target T USING (SELECT product_id as id, SUM(quantity) as qty FROM orders GROUP BY product_id) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET total = T.total + S.qty WHEN NOT MATCHED THEN INSERT (id, total) VALUES (S.id, S.qty);
-- Tag: cte_cte_test_select_4747
SELECT id, total FROM target ORDER BY id;
WITH source_cte AS ( SELECT id, value FROM staging WHERE id <= 2 ) MERGE target T USING source_cte S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4748
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4749
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4750
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4751
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.order_id = S.order_id AND T.product_id = S.product_id WHEN MATCHED THEN UPDATE SET quantity = S.quantity WHEN NOT MATCHED THEN INSERT (order_id, product_id, quantity) VALUES (S.order_id, S.product_id, S.quantity);
-- Tag: cte_cte_test_select_4752
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.nonexistent = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4753
SELECT COUNT(*) FROM target;
MERGE data T USING (SELECT category, SUM(value) as total FROM data WHERE category = 'A' GROUP BY category) S ON T.category = S.category WHEN MATCHED THEN UPDATE SET value = S.total;
-- Tag: cte_cte_test_select_4754
SELECT value FROM data WHERE category = 'A';

DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep'), (2, 'delete_me'), (3, 'delete_me_too');
INSERT INTO source VALUES (1, 'updated');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'update_me'), (2, 'delete_me'), (3, 'keep');
INSERT INTO source VALUES (1, 'updated'), (3, 'keep'), (4, 'new');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, status STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'active'), (2, 20, 'inactive');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, category STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'A'), (2, 20, 'B');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, total INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 100);
INSERT INTO orders VALUES (1, 10), (1, 20), (2, 30);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old');
INSERT INTO staging VALUES (1, 'new'), (2, 'inserted');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep_me');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'a'), (2, 'b');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (NULL, 'target_null'), (1, 'target_1');
INSERT INTO source VALUES (NULL, 'source_null'), (1, 'source_1');
DROP TABLE IF EXISTS target;
CREATE TABLE target (order_id INT64, product_id INT64, quantity INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (order_id INT64, product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 101, 5);
INSERT INTO source VALUES (1, 101, 10), (1, 102, 20);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
INSERT INTO source VALUES (1, 'duplicate1'), (1, 'duplicate2');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 'string');
INSERT INTO source VALUES (1, 123);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, 'B', 20), (3, 'A', 30);

MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED BY SOURCE THEN DELETE;
-- Tag: cte_cte_test_select_4755
SELECT COUNT(*) FROM target;
-- Tag: cte_cte_test_select_4756
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value) WHEN NOT MATCHED BY SOURCE THEN DELETE;
-- Tag: cte_cte_test_select_4757
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.status = 'active' THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4758
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.category = 'A' THEN UPDATE SET value = S.value * 2 WHEN MATCHED AND T.category = 'B' THEN UPDATE SET value = S.value * 3 WHEN MATCHED THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4759
SELECT value FROM target WHERE id = 1;
-- Tag: cte_cte_test_select_4760
SELECT value FROM target WHERE id = 2;
MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED AND S.value > 100 THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4761
SELECT id FROM target ORDER BY id;
MERGE target T USING (SELECT product_id as id, SUM(quantity) as qty FROM orders GROUP BY product_id) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET total = T.total + S.qty WHEN NOT MATCHED THEN INSERT (id, total) VALUES (S.id, S.qty);
-- Tag: cte_cte_test_select_4762
SELECT id, total FROM target ORDER BY id;
WITH source_cte AS ( SELECT id, value FROM staging WHERE id <= 2 ) MERGE target T USING source_cte S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4763
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4764
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4765
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4766
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.order_id = S.order_id AND T.product_id = S.product_id WHEN MATCHED THEN UPDATE SET quantity = S.quantity WHEN NOT MATCHED THEN INSERT (order_id, product_id, quantity) VALUES (S.order_id, S.product_id, S.quantity);
-- Tag: cte_cte_test_select_4767
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.nonexistent = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4768
SELECT COUNT(*) FROM target;
MERGE data T USING (SELECT category, SUM(value) as total FROM data WHERE category = 'A' GROUP BY category) S ON T.category = S.category WHEN MATCHED THEN UPDATE SET value = S.total;
-- Tag: cte_cte_test_select_4769
SELECT value FROM data WHERE category = 'A';

DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'update_me'), (2, 'delete_me'), (3, 'keep');
INSERT INTO source VALUES (1, 'updated'), (3, 'keep'), (4, 'new');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, status STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'active'), (2, 20, 'inactive');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, category STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'A'), (2, 20, 'B');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, total INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 100);
INSERT INTO orders VALUES (1, 10), (1, 20), (2, 30);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old');
INSERT INTO staging VALUES (1, 'new'), (2, 'inserted');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep_me');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'a'), (2, 'b');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (NULL, 'target_null'), (1, 'target_1');
INSERT INTO source VALUES (NULL, 'source_null'), (1, 'source_1');
DROP TABLE IF EXISTS target;
CREATE TABLE target (order_id INT64, product_id INT64, quantity INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (order_id INT64, product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 101, 5);
INSERT INTO source VALUES (1, 101, 10), (1, 102, 20);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
INSERT INTO source VALUES (1, 'duplicate1'), (1, 'duplicate2');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 'string');
INSERT INTO source VALUES (1, 123);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, 'B', 20), (3, 'A', 30);

MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value) WHEN NOT MATCHED BY SOURCE THEN DELETE;
-- Tag: cte_cte_test_select_4770
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.status = 'active' THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4771
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.category = 'A' THEN UPDATE SET value = S.value * 2 WHEN MATCHED AND T.category = 'B' THEN UPDATE SET value = S.value * 3 WHEN MATCHED THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4772
SELECT value FROM target WHERE id = 1;
-- Tag: cte_cte_test_select_4773
SELECT value FROM target WHERE id = 2;
MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED AND S.value > 100 THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4774
SELECT id FROM target ORDER BY id;
MERGE target T USING (SELECT product_id as id, SUM(quantity) as qty FROM orders GROUP BY product_id) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET total = T.total + S.qty WHEN NOT MATCHED THEN INSERT (id, total) VALUES (S.id, S.qty);
-- Tag: cte_cte_test_select_4775
SELECT id, total FROM target ORDER BY id;
WITH source_cte AS ( SELECT id, value FROM staging WHERE id <= 2 ) MERGE target T USING source_cte S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4776
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4777
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4778
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4779
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.order_id = S.order_id AND T.product_id = S.product_id WHEN MATCHED THEN UPDATE SET quantity = S.quantity WHEN NOT MATCHED THEN INSERT (order_id, product_id, quantity) VALUES (S.order_id, S.product_id, S.quantity);
-- Tag: cte_cte_test_select_4780
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.nonexistent = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4781
SELECT COUNT(*) FROM target;
MERGE data T USING (SELECT category, SUM(value) as total FROM data WHERE category = 'A' GROUP BY category) S ON T.category = S.category WHEN MATCHED THEN UPDATE SET value = S.total;
-- Tag: cte_cte_test_select_4782
SELECT value FROM data WHERE category = 'A';

DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, status STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'active'), (2, 20, 'inactive');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, category STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'A'), (2, 20, 'B');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, total INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 100);
INSERT INTO orders VALUES (1, 10), (1, 20), (2, 30);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old');
INSERT INTO staging VALUES (1, 'new'), (2, 'inserted');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep_me');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'a'), (2, 'b');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (NULL, 'target_null'), (1, 'target_1');
INSERT INTO source VALUES (NULL, 'source_null'), (1, 'source_1');
DROP TABLE IF EXISTS target;
CREATE TABLE target (order_id INT64, product_id INT64, quantity INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (order_id INT64, product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 101, 5);
INSERT INTO source VALUES (1, 101, 10), (1, 102, 20);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
INSERT INTO source VALUES (1, 'duplicate1'), (1, 'duplicate2');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 'string');
INSERT INTO source VALUES (1, 123);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, 'B', 20), (3, 'A', 30);

MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.status = 'active' THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4783
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.category = 'A' THEN UPDATE SET value = S.value * 2 WHEN MATCHED AND T.category = 'B' THEN UPDATE SET value = S.value * 3 WHEN MATCHED THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4784
SELECT value FROM target WHERE id = 1;
-- Tag: cte_cte_test_select_4785
SELECT value FROM target WHERE id = 2;
MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED AND S.value > 100 THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4786
SELECT id FROM target ORDER BY id;
MERGE target T USING (SELECT product_id as id, SUM(quantity) as qty FROM orders GROUP BY product_id) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET total = T.total + S.qty WHEN NOT MATCHED THEN INSERT (id, total) VALUES (S.id, S.qty);
-- Tag: cte_cte_test_select_4787
SELECT id, total FROM target ORDER BY id;
WITH source_cte AS ( SELECT id, value FROM staging WHERE id <= 2 ) MERGE target T USING source_cte S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4788
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4789
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4790
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4791
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.order_id = S.order_id AND T.product_id = S.product_id WHEN MATCHED THEN UPDATE SET quantity = S.quantity WHEN NOT MATCHED THEN INSERT (order_id, product_id, quantity) VALUES (S.order_id, S.product_id, S.quantity);
-- Tag: cte_cte_test_select_4792
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.nonexistent = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4793
SELECT COUNT(*) FROM target;
MERGE data T USING (SELECT category, SUM(value) as total FROM data WHERE category = 'A' GROUP BY category) S ON T.category = S.category WHEN MATCHED THEN UPDATE SET value = S.total;
-- Tag: cte_cte_test_select_4794
SELECT value FROM data WHERE category = 'A';

DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64, category STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 10, 'A'), (2, 20, 'B');
INSERT INTO source VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, total INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 100);
INSERT INTO orders VALUES (1, 10), (1, 20), (2, 30);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old');
INSERT INTO staging VALUES (1, 'new'), (2, 'inserted');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep_me');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'a'), (2, 'b');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (NULL, 'target_null'), (1, 'target_1');
INSERT INTO source VALUES (NULL, 'source_null'), (1, 'source_1');
DROP TABLE IF EXISTS target;
CREATE TABLE target (order_id INT64, product_id INT64, quantity INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (order_id INT64, product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 101, 5);
INSERT INTO source VALUES (1, 101, 10), (1, 102, 20);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
INSERT INTO source VALUES (1, 'duplicate1'), (1, 'duplicate2');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 'string');
INSERT INTO source VALUES (1, 123);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, 'B', 20), (3, 'A', 30);

MERGE target T USING source S ON T.id = S.id WHEN MATCHED AND T.category = 'A' THEN UPDATE SET value = S.value * 2 WHEN MATCHED AND T.category = 'B' THEN UPDATE SET value = S.value * 3 WHEN MATCHED THEN UPDATE SET value = S.value;
-- Tag: cte_cte_test_select_4795
SELECT value FROM target WHERE id = 1;
-- Tag: cte_cte_test_select_4796
SELECT value FROM target WHERE id = 2;
MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED AND S.value > 100 THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4797
SELECT id FROM target ORDER BY id;
MERGE target T USING (SELECT product_id as id, SUM(quantity) as qty FROM orders GROUP BY product_id) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET total = T.total + S.qty WHEN NOT MATCHED THEN INSERT (id, total) VALUES (S.id, S.qty);
-- Tag: cte_cte_test_select_4798
SELECT id, total FROM target ORDER BY id;
WITH source_cte AS ( SELECT id, value FROM staging WHERE id <= 2 ) MERGE target T USING source_cte S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4799
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4800
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4801
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4802
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.order_id = S.order_id AND T.product_id = S.product_id WHEN MATCHED THEN UPDATE SET quantity = S.quantity WHEN NOT MATCHED THEN INSERT (order_id, product_id, quantity) VALUES (S.order_id, S.product_id, S.quantity);
-- Tag: cte_cte_test_select_4803
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.nonexistent = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4804
SELECT COUNT(*) FROM target;
MERGE data T USING (SELECT category, SUM(value) as total FROM data WHERE category = 'A' GROUP BY category) S ON T.category = S.category WHEN MATCHED THEN UPDATE SET value = S.total;
-- Tag: cte_cte_test_select_4805
SELECT value FROM data WHERE category = 'A';

DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, total INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 100);
INSERT INTO orders VALUES (1, 10), (1, 20), (2, 30);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old');
INSERT INTO staging VALUES (1, 'new'), (2, 'inserted');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep_me');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'a'), (2, 'b');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (NULL, 'target_null'), (1, 'target_1');
INSERT INTO source VALUES (NULL, 'source_null'), (1, 'source_1');
DROP TABLE IF EXISTS target;
CREATE TABLE target (order_id INT64, product_id INT64, quantity INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (order_id INT64, product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 101, 5);
INSERT INTO source VALUES (1, 101, 10), (1, 102, 20);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
INSERT INTO source VALUES (1, 'duplicate1'), (1, 'duplicate2');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 'string');
INSERT INTO source VALUES (1, 123);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, 'B', 20), (3, 'A', 30);

MERGE target T USING source S ON T.id = S.id WHEN NOT MATCHED AND S.value > 100 THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4806
SELECT id FROM target ORDER BY id;
MERGE target T USING (SELECT product_id as id, SUM(quantity) as qty FROM orders GROUP BY product_id) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET total = T.total + S.qty WHEN NOT MATCHED THEN INSERT (id, total) VALUES (S.id, S.qty);
-- Tag: cte_cte_test_select_4807
SELECT id, total FROM target ORDER BY id;
WITH source_cte AS ( SELECT id, value FROM staging WHERE id <= 2 ) MERGE target T USING source_cte S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4808
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4809
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4810
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4811
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.order_id = S.order_id AND T.product_id = S.product_id WHEN MATCHED THEN UPDATE SET quantity = S.quantity WHEN NOT MATCHED THEN INSERT (order_id, product_id, quantity) VALUES (S.order_id, S.product_id, S.quantity);
-- Tag: cte_cte_test_select_4812
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.nonexistent = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4813
SELECT COUNT(*) FROM target;
MERGE data T USING (SELECT category, SUM(value) as total FROM data WHERE category = 'A' GROUP BY category) S ON T.category = S.category WHEN MATCHED THEN UPDATE SET value = S.total;
-- Tag: cte_cte_test_select_4814
SELECT value FROM data WHERE category = 'A';

DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, total INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 100);
INSERT INTO orders VALUES (1, 10), (1, 20), (2, 30);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old');
INSERT INTO staging VALUES (1, 'new'), (2, 'inserted');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep_me');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'a'), (2, 'b');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (NULL, 'target_null'), (1, 'target_1');
INSERT INTO source VALUES (NULL, 'source_null'), (1, 'source_1');
DROP TABLE IF EXISTS target;
CREATE TABLE target (order_id INT64, product_id INT64, quantity INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (order_id INT64, product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 101, 5);
INSERT INTO source VALUES (1, 101, 10), (1, 102, 20);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
INSERT INTO source VALUES (1, 'duplicate1'), (1, 'duplicate2');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 'string');
INSERT INTO source VALUES (1, 123);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, 'B', 20), (3, 'A', 30);

MERGE target T USING (SELECT product_id as id, SUM(quantity) as qty FROM orders GROUP BY product_id) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET total = T.total + S.qty WHEN NOT MATCHED THEN INSERT (id, total) VALUES (S.id, S.qty);
-- Tag: cte_cte_test_select_4815
SELECT id, total FROM target ORDER BY id;
WITH source_cte AS ( SELECT id, value FROM staging WHERE id <= 2 ) MERGE target T USING source_cte S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4816
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4817
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4818
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4819
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.order_id = S.order_id AND T.product_id = S.product_id WHEN MATCHED THEN UPDATE SET quantity = S.quantity WHEN NOT MATCHED THEN INSERT (order_id, product_id, quantity) VALUES (S.order_id, S.product_id, S.quantity);
-- Tag: cte_cte_test_select_4820
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.nonexistent = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4821
SELECT COUNT(*) FROM target;
MERGE data T USING (SELECT category, SUM(value) as total FROM data WHERE category = 'A' GROUP BY category) S ON T.category = S.category WHEN MATCHED THEN UPDATE SET value = S.total;
-- Tag: cte_cte_test_select_4822
SELECT value FROM data WHERE category = 'A';

DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, value STRING);
INSERT INTO target VALUES (1, 'old');
INSERT INTO staging VALUES (1, 'new'), (2, 'inserted');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep_me');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'a'), (2, 'b');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (NULL, 'target_null'), (1, 'target_1');
INSERT INTO source VALUES (NULL, 'source_null'), (1, 'source_1');
DROP TABLE IF EXISTS target;
CREATE TABLE target (order_id INT64, product_id INT64, quantity INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (order_id INT64, product_id INT64, quantity INT64);
INSERT INTO target VALUES (1, 101, 5);
INSERT INTO source VALUES (1, 101, 10), (1, 102, 20);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
INSERT INTO source VALUES (1, 'duplicate1'), (1, 'duplicate2');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO target VALUES (1, 'string');
INSERT INTO source VALUES (1, 123);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (1, 'A', 10), (2, 'B', 20), (3, 'A', 30);

WITH source_cte AS ( SELECT id, value FROM staging WHERE id <= 2 ) MERGE target T USING source_cte S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4823
SELECT id, value FROM target ORDER BY id;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4824
SELECT value FROM target WHERE id = 1;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4825
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4826
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.order_id = S.order_id AND T.product_id = S.product_id WHEN MATCHED THEN UPDATE SET quantity = S.quantity WHEN NOT MATCHED THEN INSERT (order_id, product_id, quantity) VALUES (S.order_id, S.product_id, S.quantity);
-- Tag: cte_cte_test_select_4827
SELECT COUNT(*) FROM target;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.nonexistent = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value;
MERGE target T USING source S ON T.id = S.id WHEN MATCHED THEN UPDATE SET value = S.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (S.id, S.value);
-- Tag: cte_cte_test_select_4828
SELECT COUNT(*) FROM target;
MERGE data T USING (SELECT category, SUM(value) as total FROM data WHERE category = 'A' GROUP BY category) S ON T.category = S.category WHEN MATCHED THEN UPDATE SET value = S.total;
-- Tag: cte_cte_test_select_4829
SELECT value FROM data WHERE category = 'A';

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a BOOL, b BOOL);
INSERT INTO test VALUES (1, true, NULL), (2, false, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a BOOL, b BOOL);
INSERT INTO test VALUES (1, true, NULL), (2, false, NULL), (3, true, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a BOOL, b BOOL);
INSERT INTO test VALUES (1, true, true), (2, true, false), (3, false, true), (4, false, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a BOOL, b BOOL);
INSERT INTO test VALUES (1, true, true), (2, true, false), (3, false, true), (4, false, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value BOOL);
INSERT INTO test VALUES (1, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value BOOL);
INSERT INTO test VALUES (1, true), (2, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 1), (2, 3), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 5), (2, 15);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
INSERT INTO test VALUES (1, 'alice'), (2, 'bob');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, category STRING, amount INT64);
INSERT INTO sales VALUES (1, 'A', 100), (2, 'A', 200), (3, 'B', NULL), (4, 'B', 150);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (1, 1), (2, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, status STRING);
INSERT INTO test VALUES (1, 'active'), (2, 'inactive'), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a INT64, b INT64);
INSERT INTO test VALUES (1, 10, 5), (2, NULL, 5), (3, 10, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_4830
SELECT id FROM test WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_4831
SELECT id FROM test WHERE NOT (a AND b) ORDER BY id;
-- Tag: cte_cte_test_select_4832
SELECT id FROM test WHERE NOT (a OR b) ORDER BY id;
-- Tag: cte_cte_test_select_4833
SELECT id FROM test WHERE NOT (a AND b) ORDER BY id;
-- Tag: cte_cte_test_select_4834
SELECT id FROM test WHERE (NOT a) OR (NOT b) ORDER BY id;
-- Tag: cte_cte_test_select_4835
SELECT id FROM test WHERE NOT (a OR b) ORDER BY id;
-- Tag: cte_cte_test_select_4836
SELECT id FROM test WHERE (NOT a) AND (NOT b) ORDER BY id;
-- Tag: cte_cte_test_select_4837
SELECT id, NOT NOT NOT value AS triple_neg FROM test;
-- Tag: cte_cte_test_select_4838
SELECT id FROM test WHERE NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT value ORDER BY id;
-- Tag: cte_cte_test_select_4839
SELECT id FROM test WHERE NOT NOT NOT NOT NOT NOT NOT NOT NOT value ORDER BY id;
-- Tag: cte_cte_test_select_4840
SELECT id FROM test WHERE value NOT IN (1, 2, NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4841
SELECT id FROM test WHERE value NOT BETWEEN NULL AND 10 ORDER BY id;
-- Tag: cte_cte_test_select_4842
SELECT id FROM test WHERE name NOT LIKE NULL ORDER BY id;
-- Tag: cte_cte_test_select_4843
SELECT category FROM sales GROUP BY category HAVING NOT (SUM(amount) > 200);
-- Tag: cte_cte_test_select_4844
SELECT NOT (COUNT(value) = COUNT(*)) AS has_nulls FROM test;
-- Tag: cte_cte_test_select_4845
SELECT name FROM customers c WHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);
-- Tag: cte_cte_test_select_4846
SELECT id FROM test WHERE NOT EXISTS (SELECT 1 FROM test WHERE id > 100);
-- Tag: cte_cte_test_select_4847
SELECT id FROM test WHERE NOT (CASE WHEN value > 15 THEN true ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_4848
SELECT id FROM test WHERE NOT (CASE status WHEN 'active' THEN true WHEN 'inactive' THEN false ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_4849
SELECT id FROM test WHERE NOT (a + b > 10) ORDER BY id;
-- Tag: cte_cte_test_select_4850
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_4851
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4852
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_4853
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4854
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_4855
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_4856
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_4857
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_4858
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_4859
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a BOOL, b BOOL);
INSERT INTO test VALUES (1, true, NULL), (2, false, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a BOOL, b BOOL);
INSERT INTO test VALUES (1, true, NULL), (2, false, NULL), (3, true, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a BOOL, b BOOL);
INSERT INTO test VALUES (1, true, true), (2, true, false), (3, false, true), (4, false, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a BOOL, b BOOL);
INSERT INTO test VALUES (1, true, true), (2, true, false), (3, false, true), (4, false, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value BOOL);
INSERT INTO test VALUES (1, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value BOOL);
INSERT INTO test VALUES (1, true), (2, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 1), (2, 3), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 5), (2, 15);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
INSERT INTO test VALUES (1, 'alice'), (2, 'bob');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, category STRING, amount INT64);
INSERT INTO sales VALUES (1, 'A', 100), (2, 'A', 200), (3, 'B', NULL), (4, 'B', 150);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (1, 1), (2, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, status STRING);
INSERT INTO test VALUES (1, 'active'), (2, 'inactive'), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a INT64, b INT64);
INSERT INTO test VALUES (1, 10, 5), (2, NULL, 5), (3, 10, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_4860
SELECT id FROM test WHERE NOT (a AND b) ORDER BY id;
-- Tag: cte_cte_test_select_4861
SELECT id FROM test WHERE NOT (a OR b) ORDER BY id;
-- Tag: cte_cte_test_select_4862
SELECT id FROM test WHERE NOT (a AND b) ORDER BY id;
-- Tag: cte_cte_test_select_4863
SELECT id FROM test WHERE (NOT a) OR (NOT b) ORDER BY id;
-- Tag: cte_cte_test_select_4864
SELECT id FROM test WHERE NOT (a OR b) ORDER BY id;
-- Tag: cte_cte_test_select_4865
SELECT id FROM test WHERE (NOT a) AND (NOT b) ORDER BY id;
-- Tag: cte_cte_test_select_4866
SELECT id, NOT NOT NOT value AS triple_neg FROM test;
-- Tag: cte_cte_test_select_4867
SELECT id FROM test WHERE NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT value ORDER BY id;
-- Tag: cte_cte_test_select_4868
SELECT id FROM test WHERE NOT NOT NOT NOT NOT NOT NOT NOT NOT value ORDER BY id;
-- Tag: cte_cte_test_select_4869
SELECT id FROM test WHERE value NOT IN (1, 2, NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4870
SELECT id FROM test WHERE value NOT BETWEEN NULL AND 10 ORDER BY id;
-- Tag: cte_cte_test_select_4871
SELECT id FROM test WHERE name NOT LIKE NULL ORDER BY id;
-- Tag: cte_cte_test_select_4872
SELECT category FROM sales GROUP BY category HAVING NOT (SUM(amount) > 200);
-- Tag: cte_cte_test_select_4873
SELECT NOT (COUNT(value) = COUNT(*)) AS has_nulls FROM test;
-- Tag: cte_cte_test_select_4874
SELECT name FROM customers c WHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);
-- Tag: cte_cte_test_select_4875
SELECT id FROM test WHERE NOT EXISTS (SELECT 1 FROM test WHERE id > 100);
-- Tag: cte_cte_test_select_4876
SELECT id FROM test WHERE NOT (CASE WHEN value > 15 THEN true ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_4877
SELECT id FROM test WHERE NOT (CASE status WHEN 'active' THEN true WHEN 'inactive' THEN false ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_4878
SELECT id FROM test WHERE NOT (a + b > 10) ORDER BY id;
-- Tag: cte_cte_test_select_4879
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_4880
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4881
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_4882
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4883
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_4884
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_4885
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_4886
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_4887
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_4888
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a BOOL, b BOOL);
INSERT INTO test VALUES (1, true, NULL), (2, false, NULL), (3, true, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a BOOL, b BOOL);
INSERT INTO test VALUES (1, true, true), (2, true, false), (3, false, true), (4, false, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a BOOL, b BOOL);
INSERT INTO test VALUES (1, true, true), (2, true, false), (3, false, true), (4, false, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value BOOL);
INSERT INTO test VALUES (1, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value BOOL);
INSERT INTO test VALUES (1, true), (2, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 1), (2, 3), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 5), (2, 15);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
INSERT INTO test VALUES (1, 'alice'), (2, 'bob');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, category STRING, amount INT64);
INSERT INTO sales VALUES (1, 'A', 100), (2, 'A', 200), (3, 'B', NULL), (4, 'B', 150);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (1, 1), (2, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, status STRING);
INSERT INTO test VALUES (1, 'active'), (2, 'inactive'), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a INT64, b INT64);
INSERT INTO test VALUES (1, 10, 5), (2, NULL, 5), (3, 10, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_4889
SELECT id FROM test WHERE NOT (a OR b) ORDER BY id;
-- Tag: cte_cte_test_select_4890
SELECT id FROM test WHERE NOT (a AND b) ORDER BY id;
-- Tag: cte_cte_test_select_4891
SELECT id FROM test WHERE (NOT a) OR (NOT b) ORDER BY id;
-- Tag: cte_cte_test_select_4892
SELECT id FROM test WHERE NOT (a OR b) ORDER BY id;
-- Tag: cte_cte_test_select_4893
SELECT id FROM test WHERE (NOT a) AND (NOT b) ORDER BY id;
-- Tag: cte_cte_test_select_4894
SELECT id, NOT NOT NOT value AS triple_neg FROM test;
-- Tag: cte_cte_test_select_4895
SELECT id FROM test WHERE NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT value ORDER BY id;
-- Tag: cte_cte_test_select_4896
SELECT id FROM test WHERE NOT NOT NOT NOT NOT NOT NOT NOT NOT value ORDER BY id;
-- Tag: cte_cte_test_select_4897
SELECT id FROM test WHERE value NOT IN (1, 2, NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4898
SELECT id FROM test WHERE value NOT BETWEEN NULL AND 10 ORDER BY id;
-- Tag: cte_cte_test_select_4899
SELECT id FROM test WHERE name NOT LIKE NULL ORDER BY id;
-- Tag: cte_cte_test_select_4900
SELECT category FROM sales GROUP BY category HAVING NOT (SUM(amount) > 200);
-- Tag: cte_cte_test_select_4901
SELECT NOT (COUNT(value) = COUNT(*)) AS has_nulls FROM test;
-- Tag: cte_cte_test_select_4902
SELECT name FROM customers c WHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);
-- Tag: cte_cte_test_select_4903
SELECT id FROM test WHERE NOT EXISTS (SELECT 1 FROM test WHERE id > 100);
-- Tag: cte_cte_test_select_4904
SELECT id FROM test WHERE NOT (CASE WHEN value > 15 THEN true ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_4905
SELECT id FROM test WHERE NOT (CASE status WHEN 'active' THEN true WHEN 'inactive' THEN false ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_4906
SELECT id FROM test WHERE NOT (a + b > 10) ORDER BY id;
-- Tag: cte_cte_test_select_4907
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_4908
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4909
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_4910
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4911
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_4912
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_4913
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_4914
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_4915
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_4916
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a BOOL, b BOOL);
INSERT INTO test VALUES (1, true, true), (2, true, false), (3, false, true), (4, false, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a BOOL, b BOOL);
INSERT INTO test VALUES (1, true, true), (2, true, false), (3, false, true), (4, false, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value BOOL);
INSERT INTO test VALUES (1, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value BOOL);
INSERT INTO test VALUES (1, true), (2, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 1), (2, 3), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 5), (2, 15);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
INSERT INTO test VALUES (1, 'alice'), (2, 'bob');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, category STRING, amount INT64);
INSERT INTO sales VALUES (1, 'A', 100), (2, 'A', 200), (3, 'B', NULL), (4, 'B', 150);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (1, 1), (2, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, status STRING);
INSERT INTO test VALUES (1, 'active'), (2, 'inactive'), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a INT64, b INT64);
INSERT INTO test VALUES (1, 10, 5), (2, NULL, 5), (3, 10, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_4917
SELECT id FROM test WHERE NOT (a AND b) ORDER BY id;
-- Tag: cte_cte_test_select_4918
SELECT id FROM test WHERE (NOT a) OR (NOT b) ORDER BY id;
-- Tag: cte_cte_test_select_4919
SELECT id FROM test WHERE NOT (a OR b) ORDER BY id;
-- Tag: cte_cte_test_select_4920
SELECT id FROM test WHERE (NOT a) AND (NOT b) ORDER BY id;
-- Tag: cte_cte_test_select_4921
SELECT id, NOT NOT NOT value AS triple_neg FROM test;
-- Tag: cte_cte_test_select_4922
SELECT id FROM test WHERE NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT value ORDER BY id;
-- Tag: cte_cte_test_select_4923
SELECT id FROM test WHERE NOT NOT NOT NOT NOT NOT NOT NOT NOT value ORDER BY id;
-- Tag: cte_cte_test_select_4924
SELECT id FROM test WHERE value NOT IN (1, 2, NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4925
SELECT id FROM test WHERE value NOT BETWEEN NULL AND 10 ORDER BY id;
-- Tag: cte_cte_test_select_4926
SELECT id FROM test WHERE name NOT LIKE NULL ORDER BY id;
-- Tag: cte_cte_test_select_4927
SELECT category FROM sales GROUP BY category HAVING NOT (SUM(amount) > 200);
-- Tag: cte_cte_test_select_4928
SELECT NOT (COUNT(value) = COUNT(*)) AS has_nulls FROM test;
-- Tag: cte_cte_test_select_4929
SELECT name FROM customers c WHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);
-- Tag: cte_cte_test_select_4930
SELECT id FROM test WHERE NOT EXISTS (SELECT 1 FROM test WHERE id > 100);
-- Tag: cte_cte_test_select_4931
SELECT id FROM test WHERE NOT (CASE WHEN value > 15 THEN true ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_4932
SELECT id FROM test WHERE NOT (CASE status WHEN 'active' THEN true WHEN 'inactive' THEN false ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_4933
SELECT id FROM test WHERE NOT (a + b > 10) ORDER BY id;
-- Tag: cte_cte_test_select_4934
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_4935
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4936
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_4937
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4938
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_4939
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_4940
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_4941
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_4942
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_4943
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a BOOL, b BOOL);
INSERT INTO test VALUES (1, true, true), (2, true, false), (3, false, true), (4, false, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value BOOL);
INSERT INTO test VALUES (1, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value BOOL);
INSERT INTO test VALUES (1, true), (2, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 1), (2, 3), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 5), (2, 15);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
INSERT INTO test VALUES (1, 'alice'), (2, 'bob');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, category STRING, amount INT64);
INSERT INTO sales VALUES (1, 'A', 100), (2, 'A', 200), (3, 'B', NULL), (4, 'B', 150);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (1, 1), (2, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, status STRING);
INSERT INTO test VALUES (1, 'active'), (2, 'inactive'), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a INT64, b INT64);
INSERT INTO test VALUES (1, 10, 5), (2, NULL, 5), (3, 10, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_4944
SELECT id FROM test WHERE NOT (a OR b) ORDER BY id;
-- Tag: cte_cte_test_select_4945
SELECT id FROM test WHERE (NOT a) AND (NOT b) ORDER BY id;
-- Tag: cte_cte_test_select_4946
SELECT id, NOT NOT NOT value AS triple_neg FROM test;
-- Tag: cte_cte_test_select_4947
SELECT id FROM test WHERE NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT value ORDER BY id;
-- Tag: cte_cte_test_select_4948
SELECT id FROM test WHERE NOT NOT NOT NOT NOT NOT NOT NOT NOT value ORDER BY id;
-- Tag: cte_cte_test_select_4949
SELECT id FROM test WHERE value NOT IN (1, 2, NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4950
SELECT id FROM test WHERE value NOT BETWEEN NULL AND 10 ORDER BY id;
-- Tag: cte_cte_test_select_4951
SELECT id FROM test WHERE name NOT LIKE NULL ORDER BY id;
-- Tag: cte_cte_test_select_4952
SELECT category FROM sales GROUP BY category HAVING NOT (SUM(amount) > 200);
-- Tag: cte_cte_test_select_4953
SELECT NOT (COUNT(value) = COUNT(*)) AS has_nulls FROM test;
-- Tag: cte_cte_test_select_4954
SELECT name FROM customers c WHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);
-- Tag: cte_cte_test_select_4955
SELECT id FROM test WHERE NOT EXISTS (SELECT 1 FROM test WHERE id > 100);
-- Tag: cte_cte_test_select_4956
SELECT id FROM test WHERE NOT (CASE WHEN value > 15 THEN true ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_4957
SELECT id FROM test WHERE NOT (CASE status WHEN 'active' THEN true WHEN 'inactive' THEN false ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_4958
SELECT id FROM test WHERE NOT (a + b > 10) ORDER BY id;
-- Tag: cte_cte_test_select_4959
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_4960
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4961
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_4962
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4963
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_4964
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_4965
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_4966
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_4967
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_4968
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value BOOL);
INSERT INTO test VALUES (1, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value BOOL);
INSERT INTO test VALUES (1, true), (2, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 1), (2, 3), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 5), (2, 15);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
INSERT INTO test VALUES (1, 'alice'), (2, 'bob');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, category STRING, amount INT64);
INSERT INTO sales VALUES (1, 'A', 100), (2, 'A', 200), (3, 'B', NULL), (4, 'B', 150);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (1, 1), (2, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, status STRING);
INSERT INTO test VALUES (1, 'active'), (2, 'inactive'), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a INT64, b INT64);
INSERT INTO test VALUES (1, 10, 5), (2, NULL, 5), (3, 10, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_4969
SELECT id, NOT NOT NOT value AS triple_neg FROM test;
-- Tag: cte_cte_test_select_4970
SELECT id FROM test WHERE NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT value ORDER BY id;
-- Tag: cte_cte_test_select_4971
SELECT id FROM test WHERE NOT NOT NOT NOT NOT NOT NOT NOT NOT value ORDER BY id;
-- Tag: cte_cte_test_select_4972
SELECT id FROM test WHERE value NOT IN (1, 2, NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4973
SELECT id FROM test WHERE value NOT BETWEEN NULL AND 10 ORDER BY id;
-- Tag: cte_cte_test_select_4974
SELECT id FROM test WHERE name NOT LIKE NULL ORDER BY id;
-- Tag: cte_cte_test_select_4975
SELECT category FROM sales GROUP BY category HAVING NOT (SUM(amount) > 200);
-- Tag: cte_cte_test_select_4976
SELECT NOT (COUNT(value) = COUNT(*)) AS has_nulls FROM test;
-- Tag: cte_cte_test_select_4977
SELECT name FROM customers c WHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);
-- Tag: cte_cte_test_select_4978
SELECT id FROM test WHERE NOT EXISTS (SELECT 1 FROM test WHERE id > 100);
-- Tag: cte_cte_test_select_4979
SELECT id FROM test WHERE NOT (CASE WHEN value > 15 THEN true ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_4980
SELECT id FROM test WHERE NOT (CASE status WHEN 'active' THEN true WHEN 'inactive' THEN false ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_4981
SELECT id FROM test WHERE NOT (a + b > 10) ORDER BY id;
-- Tag: cte_cte_test_select_4982
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_4983
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4984
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_4985
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4986
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_4987
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_4988
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_4989
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_4990
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_4991
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value BOOL);
INSERT INTO test VALUES (1, true), (2, false);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 1), (2, 3), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 5), (2, 15);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
INSERT INTO test VALUES (1, 'alice'), (2, 'bob');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, category STRING, amount INT64);
INSERT INTO sales VALUES (1, 'A', 100), (2, 'A', 200), (3, 'B', NULL), (4, 'B', 150);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (1, 1), (2, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, status STRING);
INSERT INTO test VALUES (1, 'active'), (2, 'inactive'), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a INT64, b INT64);
INSERT INTO test VALUES (1, 10, 5), (2, NULL, 5), (3, 10, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_4992
SELECT id FROM test WHERE NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT value ORDER BY id;
-- Tag: cte_cte_test_select_4993
SELECT id FROM test WHERE NOT NOT NOT NOT NOT NOT NOT NOT NOT value ORDER BY id;
-- Tag: cte_cte_test_select_4994
SELECT id FROM test WHERE value NOT IN (1, 2, NULL) ORDER BY id;
-- Tag: cte_cte_test_select_4995
SELECT id FROM test WHERE value NOT BETWEEN NULL AND 10 ORDER BY id;
-- Tag: cte_cte_test_select_4996
SELECT id FROM test WHERE name NOT LIKE NULL ORDER BY id;
-- Tag: cte_cte_test_select_4997
SELECT category FROM sales GROUP BY category HAVING NOT (SUM(amount) > 200);
-- Tag: cte_cte_test_select_4998
SELECT NOT (COUNT(value) = COUNT(*)) AS has_nulls FROM test;
-- Tag: cte_cte_test_select_4999
SELECT name FROM customers c WHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);
-- Tag: cte_cte_test_select_5000
SELECT id FROM test WHERE NOT EXISTS (SELECT 1 FROM test WHERE id > 100);
-- Tag: cte_cte_test_select_5001
SELECT id FROM test WHERE NOT (CASE WHEN value > 15 THEN true ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5002
SELECT id FROM test WHERE NOT (CASE status WHEN 'active' THEN true WHEN 'inactive' THEN false ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5003
SELECT id FROM test WHERE NOT (a + b > 10) ORDER BY id;
-- Tag: cte_cte_test_select_5004
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_5005
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5006
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_5007
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5008
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_5009
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_5010
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_5011
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5012
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5013
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 1), (2, 3), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 5), (2, 15);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
INSERT INTO test VALUES (1, 'alice'), (2, 'bob');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, category STRING, amount INT64);
INSERT INTO sales VALUES (1, 'A', 100), (2, 'A', 200), (3, 'B', NULL), (4, 'B', 150);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (1, 1), (2, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, status STRING);
INSERT INTO test VALUES (1, 'active'), (2, 'inactive'), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a INT64, b INT64);
INSERT INTO test VALUES (1, 10, 5), (2, NULL, 5), (3, 10, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_5014
SELECT id FROM test WHERE value NOT IN (1, 2, NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5015
SELECT id FROM test WHERE value NOT BETWEEN NULL AND 10 ORDER BY id;
-- Tag: cte_cte_test_select_5016
SELECT id FROM test WHERE name NOT LIKE NULL ORDER BY id;
-- Tag: cte_cte_test_select_5017
SELECT category FROM sales GROUP BY category HAVING NOT (SUM(amount) > 200);
-- Tag: cte_cte_test_select_5018
SELECT NOT (COUNT(value) = COUNT(*)) AS has_nulls FROM test;
-- Tag: cte_cte_test_select_5019
SELECT name FROM customers c WHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);
-- Tag: cte_cte_test_select_5020
SELECT id FROM test WHERE NOT EXISTS (SELECT 1 FROM test WHERE id > 100);
-- Tag: cte_cte_test_select_5021
SELECT id FROM test WHERE NOT (CASE WHEN value > 15 THEN true ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5022
SELECT id FROM test WHERE NOT (CASE status WHEN 'active' THEN true WHEN 'inactive' THEN false ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5023
SELECT id FROM test WHERE NOT (a + b > 10) ORDER BY id;
-- Tag: cte_cte_test_select_5024
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_5025
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5026
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_5027
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5028
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_5029
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_5030
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_5031
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5032
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5033
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 5), (2, 15);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
INSERT INTO test VALUES (1, 'alice'), (2, 'bob');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, category STRING, amount INT64);
INSERT INTO sales VALUES (1, 'A', 100), (2, 'A', 200), (3, 'B', NULL), (4, 'B', 150);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (1, 1), (2, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, status STRING);
INSERT INTO test VALUES (1, 'active'), (2, 'inactive'), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a INT64, b INT64);
INSERT INTO test VALUES (1, 10, 5), (2, NULL, 5), (3, 10, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_5034
SELECT id FROM test WHERE value NOT BETWEEN NULL AND 10 ORDER BY id;
-- Tag: cte_cte_test_select_5035
SELECT id FROM test WHERE name NOT LIKE NULL ORDER BY id;
-- Tag: cte_cte_test_select_5036
SELECT category FROM sales GROUP BY category HAVING NOT (SUM(amount) > 200);
-- Tag: cte_cte_test_select_5037
SELECT NOT (COUNT(value) = COUNT(*)) AS has_nulls FROM test;
-- Tag: cte_cte_test_select_5038
SELECT name FROM customers c WHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);
-- Tag: cte_cte_test_select_5039
SELECT id FROM test WHERE NOT EXISTS (SELECT 1 FROM test WHERE id > 100);
-- Tag: cte_cte_test_select_5040
SELECT id FROM test WHERE NOT (CASE WHEN value > 15 THEN true ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5041
SELECT id FROM test WHERE NOT (CASE status WHEN 'active' THEN true WHEN 'inactive' THEN false ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5042
SELECT id FROM test WHERE NOT (a + b > 10) ORDER BY id;
-- Tag: cte_cte_test_select_5043
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_5044
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5045
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_5046
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5047
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_5048
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_5049
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_5050
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5051
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5052
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
INSERT INTO test VALUES (1, 'alice'), (2, 'bob');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, category STRING, amount INT64);
INSERT INTO sales VALUES (1, 'A', 100), (2, 'A', 200), (3, 'B', NULL), (4, 'B', 150);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (1, 1), (2, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, status STRING);
INSERT INTO test VALUES (1, 'active'), (2, 'inactive'), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a INT64, b INT64);
INSERT INTO test VALUES (1, 10, 5), (2, NULL, 5), (3, 10, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_5053
SELECT id FROM test WHERE name NOT LIKE NULL ORDER BY id;
-- Tag: cte_cte_test_select_5054
SELECT category FROM sales GROUP BY category HAVING NOT (SUM(amount) > 200);
-- Tag: cte_cte_test_select_5055
SELECT NOT (COUNT(value) = COUNT(*)) AS has_nulls FROM test;
-- Tag: cte_cte_test_select_5056
SELECT name FROM customers c WHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);
-- Tag: cte_cte_test_select_5057
SELECT id FROM test WHERE NOT EXISTS (SELECT 1 FROM test WHERE id > 100);
-- Tag: cte_cte_test_select_5058
SELECT id FROM test WHERE NOT (CASE WHEN value > 15 THEN true ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5059
SELECT id FROM test WHERE NOT (CASE status WHEN 'active' THEN true WHEN 'inactive' THEN false ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5060
SELECT id FROM test WHERE NOT (a + b > 10) ORDER BY id;
-- Tag: cte_cte_test_select_5061
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_5062
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5063
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_5064
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5065
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_5066
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_5067
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_5068
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5069
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5070
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, category STRING, amount INT64);
INSERT INTO sales VALUES (1, 'A', 100), (2, 'A', 200), (3, 'B', NULL), (4, 'B', 150);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (1, 1), (2, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, status STRING);
INSERT INTO test VALUES (1, 'active'), (2, 'inactive'), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a INT64, b INT64);
INSERT INTO test VALUES (1, 10, 5), (2, NULL, 5), (3, 10, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_5071
SELECT category FROM sales GROUP BY category HAVING NOT (SUM(amount) > 200);
-- Tag: cte_cte_test_select_5072
SELECT NOT (COUNT(value) = COUNT(*)) AS has_nulls FROM test;
-- Tag: cte_cte_test_select_5073
SELECT name FROM customers c WHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);
-- Tag: cte_cte_test_select_5074
SELECT id FROM test WHERE NOT EXISTS (SELECT 1 FROM test WHERE id > 100);
-- Tag: cte_cte_test_select_5075
SELECT id FROM test WHERE NOT (CASE WHEN value > 15 THEN true ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5076
SELECT id FROM test WHERE NOT (CASE status WHEN 'active' THEN true WHEN 'inactive' THEN false ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5077
SELECT id FROM test WHERE NOT (a + b > 10) ORDER BY id;
-- Tag: cte_cte_test_select_5078
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_5079
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5080
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_5081
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5082
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_5083
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_5084
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_5085
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5086
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5087
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (1, 1), (2, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, status STRING);
INSERT INTO test VALUES (1, 'active'), (2, 'inactive'), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a INT64, b INT64);
INSERT INTO test VALUES (1, 10, 5), (2, NULL, 5), (3, 10, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_5088
SELECT NOT (COUNT(value) = COUNT(*)) AS has_nulls FROM test;
-- Tag: cte_cte_test_select_5089
SELECT name FROM customers c WHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);
-- Tag: cte_cte_test_select_5090
SELECT id FROM test WHERE NOT EXISTS (SELECT 1 FROM test WHERE id > 100);
-- Tag: cte_cte_test_select_5091
SELECT id FROM test WHERE NOT (CASE WHEN value > 15 THEN true ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5092
SELECT id FROM test WHERE NOT (CASE status WHEN 'active' THEN true WHEN 'inactive' THEN false ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5093
SELECT id FROM test WHERE NOT (a + b > 10) ORDER BY id;
-- Tag: cte_cte_test_select_5094
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_5095
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5096
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_5097
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5098
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_5099
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_5100
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_5101
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5102
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5103
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (1, 1), (2, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, status STRING);
INSERT INTO test VALUES (1, 'active'), (2, 'inactive'), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a INT64, b INT64);
INSERT INTO test VALUES (1, 10, 5), (2, NULL, 5), (3, 10, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_5104
SELECT name FROM customers c WHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);
-- Tag: cte_cte_test_select_5105
SELECT id FROM test WHERE NOT EXISTS (SELECT 1 FROM test WHERE id > 100);
-- Tag: cte_cte_test_select_5106
SELECT id FROM test WHERE NOT (CASE WHEN value > 15 THEN true ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5107
SELECT id FROM test WHERE NOT (CASE status WHEN 'active' THEN true WHEN 'inactive' THEN false ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5108
SELECT id FROM test WHERE NOT (a + b > 10) ORDER BY id;
-- Tag: cte_cte_test_select_5109
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_5110
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5111
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_5112
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5113
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_5114
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_5115
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_5116
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5117
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5118
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, status STRING);
INSERT INTO test VALUES (1, 'active'), (2, 'inactive'), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a INT64, b INT64);
INSERT INTO test VALUES (1, 10, 5), (2, NULL, 5), (3, 10, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_5119
SELECT id FROM test WHERE NOT EXISTS (SELECT 1 FROM test WHERE id > 100);
-- Tag: cte_cte_test_select_5120
SELECT id FROM test WHERE NOT (CASE WHEN value > 15 THEN true ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5121
SELECT id FROM test WHERE NOT (CASE status WHEN 'active' THEN true WHEN 'inactive' THEN false ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5122
SELECT id FROM test WHERE NOT (a + b > 10) ORDER BY id;
-- Tag: cte_cte_test_select_5123
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_5124
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5125
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_5126
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5127
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_5128
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_5129
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_5130
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5131
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5132
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, 20), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, status STRING);
INSERT INTO test VALUES (1, 'active'), (2, 'inactive'), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a INT64, b INT64);
INSERT INTO test VALUES (1, 10, 5), (2, NULL, 5), (3, 10, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_5133
SELECT id FROM test WHERE NOT (CASE WHEN value > 15 THEN true ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5134
SELECT id FROM test WHERE NOT (CASE status WHEN 'active' THEN true WHEN 'inactive' THEN false ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5135
SELECT id FROM test WHERE NOT (a + b > 10) ORDER BY id;
-- Tag: cte_cte_test_select_5136
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_5137
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5138
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_5139
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5140
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_5141
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_5142
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_5143
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5144
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5145
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, status STRING);
INSERT INTO test VALUES (1, 'active'), (2, 'inactive'), (3, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a INT64, b INT64);
INSERT INTO test VALUES (1, 10, 5), (2, NULL, 5), (3, 10, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_5146
SELECT id FROM test WHERE NOT (CASE status WHEN 'active' THEN true WHEN 'inactive' THEN false ELSE NULL END) ORDER BY id;
-- Tag: cte_cte_test_select_5147
SELECT id FROM test WHERE NOT (a + b > 10) ORDER BY id;
-- Tag: cte_cte_test_select_5148
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_5149
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5150
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_5151
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5152
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_5153
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_5154
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_5155
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5156
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5157
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, a INT64, b INT64);
INSERT INTO test VALUES (1, 10, 5), (2, NULL, 5), (3, 10, NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_5158
SELECT id FROM test WHERE NOT (a + b > 10) ORDER BY id;
-- Tag: cte_cte_test_select_5159
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_5160
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5161
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_5162
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5163
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_5164
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_5165
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_5166
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5167
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5168
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, first STRING, last STRING);
INSERT INTO test VALUES (1, 'Alice', 'Smith'), (2, NULL, 'Jones'), (3, 'Bob', NULL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_5169
SELECT id FROM test WHERE NOT (CONCAT(first, last) = 'AliceSmith') ORDER BY id;
-- Tag: cte_cte_test_select_5170
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5171
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_5172
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5173
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_5174
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_5175
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_5176
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5177
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5178
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_5179
SELECT id FROM test WHERE NOT (value IS NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5180
SELECT id FROM test WHERE value IS NOT NULL ORDER BY id;
-- Tag: cte_cte_test_select_5181
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5182
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_5183
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_5184
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_5185
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5186
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5187
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_5188
SELECT id FROM test WHERE NOT (value IS NOT NULL) ORDER BY id;
-- Tag: cte_cte_test_select_5189
SELECT id FROM test WHERE value IS NULL ORDER BY id;
-- Tag: cte_cte_test_select_5190
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_5191
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_5192
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5193
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5194
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS large_test;
CREATE TABLE large_test (id INT64, value BOOL);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_5195
SELECT COUNT(*) FROM large_test WHERE NOT (NOT (NOT (value OR NOT value)));
-- Tag: cte_cte_test_select_5196
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_5197
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5198
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5199
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_5200
SELECT id FROM test WHERE NOT value;
-- Tag: cte_cte_test_select_5201
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5202
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5203
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

-- Tag: cte_cte_test_select_5204
SELECT id FROM test WHERE NOT name;
WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5205
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5206
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 10), (2, NULL), (3, 30);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, active BOOL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value INT64);
INSERT INTO t1 VALUES (1, true), (2, false);
INSERT INTO t2 VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64, category STRING);
INSERT INTO test VALUES (1, 100, 'A'), (2, 200, 'A'), (3, 150, 'B');

WITH filtered AS (SELECT id, value FROM test WHERE value IS NOT NULL) \ SELECT id FROM filtered WHERE NOT (value > 20) ORDER BY id;
-- Tag: cte_cte_test_select_5207
SELECT t1.id FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE NOT t1.active;
-- Tag: cte_cte_test_select_5208
SELECT id FROM test WHERE NOT (value > (SELECT AVG(value) FROM test)) ORDER BY id;

DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64, quantity INT64);
INSERT INTO products VALUES (1, 10.0, 5), (2, 20.0, 2), (3, 15.0, 3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, first_name STRING, last_name STRING);
INSERT INTO users VALUES (1, 'John', 'Doe'), (2, 'Jane', 'Smith'), (3, 'Bob', 'Anderson');
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, priority STRING);
INSERT INTO items VALUES (1, 'low'), (2, 'high'), (3, 'medium'), (4, 'high');
DROP TABLE IF EXISTS words;
CREATE TABLE words (id INT64, text STRING);
INSERT INTO words VALUES (1, 'apple'), (2, 'BANANA'), (3, 'Cherry');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, year INT64, quarter INT64, revenue FLOAT64);
INSERT INTO sales VALUES (1, 2023, 1, 100.0), (2, 2023, 2, 150.0), (3, 2024, 1, 120.0), (4, 2024, 1, 110.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64, name STRING);
INSERT INTO data VALUES (30, 'c'), (10, 'a'), (20, 'b');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (3, 'A', 100), (1, 'A', 200), (2, 'B', 150);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, NULL), (3, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5209
SELECT id, price * quantity AS total FROM products ORDER BY price * quantity;
-- Tag: cte_cte_test_select_5210
SELECT id FROM users ORDER BY CONCAT(last_name, ', ', first_name);
-- Tag: cte_cte_test_select_5211
SELECT id FROM items ORDER BY CASE priority WHEN 'high' THEN 1 WHEN 'medium' THEN 2 WHEN 'low' THEN 3 ELSE 4 END, id;
-- Tag: cte_cte_test_select_5212
SELECT id FROM words ORDER BY UPPER(text);
-- Tag: cte_cte_test_select_5213
SELECT id FROM sales ORDER BY year DESC, quarter ASC, revenue DESC;
-- Tag: cte_cte_test_select_5214
SELECT id FROM data ORDER BY value ASC NULLS FIRST;
-- Tag: cte_cte_test_select_5215
SELECT id FROM data ORDER BY value ASC NULLS LAST;
-- Tag: cte_cte_test_select_5216
SELECT id FROM data ORDER BY value DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5217
SELECT id FROM data ORDER BY value DESC NULLS LAST;
-- Tag: cte_cte_test_select_5218
SELECT id FROM data ORDER BY value ASC;
-- Tag: cte_cte_test_select_5219
SELECT id FROM data ORDER BY value DESC;
-- Tag: cte_cte_test_select_5220
SELECT value, name FROM data ORDER BY 1;
-- Tag: cte_cte_test_select_5221
SELECT id, category, value FROM data ORDER BY 2, 1;
-- Tag: cte_cte_test_select_5222
SELECT value FROM data ORDER BY 1 DESC;
-- Tag: cte_cte_test_select_5223
SELECT value FROM data ORDER BY 1 NULLS FIRST;
-- Tag: cte_cte_test_select_5224
SELECT value * 2 AS doubled FROM data ORDER BY value * 2;
-- Tag: cte_cte_test_select_5225
SELECT id FROM data ORDER BY value NULLS FIRST;
-- Tag: cte_cte_test_select_5226
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5227
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5228
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5229
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5230
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5231
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5232
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5233
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5234
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5235
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5236
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5237
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5238
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5239
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5240
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5241
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5242
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5243
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5244
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, first_name STRING, last_name STRING);
INSERT INTO users VALUES (1, 'John', 'Doe'), (2, 'Jane', 'Smith'), (3, 'Bob', 'Anderson');
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, priority STRING);
INSERT INTO items VALUES (1, 'low'), (2, 'high'), (3, 'medium'), (4, 'high');
DROP TABLE IF EXISTS words;
CREATE TABLE words (id INT64, text STRING);
INSERT INTO words VALUES (1, 'apple'), (2, 'BANANA'), (3, 'Cherry');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, year INT64, quarter INT64, revenue FLOAT64);
INSERT INTO sales VALUES (1, 2023, 1, 100.0), (2, 2023, 2, 150.0), (3, 2024, 1, 120.0), (4, 2024, 1, 110.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64, name STRING);
INSERT INTO data VALUES (30, 'c'), (10, 'a'), (20, 'b');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (3, 'A', 100), (1, 'A', 200), (2, 'B', 150);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, NULL), (3, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5245
SELECT id FROM users ORDER BY CONCAT(last_name, ', ', first_name);
-- Tag: cte_cte_test_select_5246
SELECT id FROM items ORDER BY CASE priority WHEN 'high' THEN 1 WHEN 'medium' THEN 2 WHEN 'low' THEN 3 ELSE 4 END, id;
-- Tag: cte_cte_test_select_5247
SELECT id FROM words ORDER BY UPPER(text);
-- Tag: cte_cte_test_select_5248
SELECT id FROM sales ORDER BY year DESC, quarter ASC, revenue DESC;
-- Tag: cte_cte_test_select_5249
SELECT id FROM data ORDER BY value ASC NULLS FIRST;
-- Tag: cte_cte_test_select_5250
SELECT id FROM data ORDER BY value ASC NULLS LAST;
-- Tag: cte_cte_test_select_5251
SELECT id FROM data ORDER BY value DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5252
SELECT id FROM data ORDER BY value DESC NULLS LAST;
-- Tag: cte_cte_test_select_5253
SELECT id FROM data ORDER BY value ASC;
-- Tag: cte_cte_test_select_5254
SELECT id FROM data ORDER BY value DESC;
-- Tag: cte_cte_test_select_5255
SELECT value, name FROM data ORDER BY 1;
-- Tag: cte_cte_test_select_5256
SELECT id, category, value FROM data ORDER BY 2, 1;
-- Tag: cte_cte_test_select_5257
SELECT value FROM data ORDER BY 1 DESC;
-- Tag: cte_cte_test_select_5258
SELECT value FROM data ORDER BY 1 NULLS FIRST;
-- Tag: cte_cte_test_select_5259
SELECT value * 2 AS doubled FROM data ORDER BY value * 2;
-- Tag: cte_cte_test_select_5260
SELECT id FROM data ORDER BY value NULLS FIRST;
-- Tag: cte_cte_test_select_5261
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5262
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5263
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5264
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5265
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5266
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5267
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5268
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5269
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5270
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5271
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5272
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5273
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5274
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5275
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5276
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5277
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5278
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5279
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, priority STRING);
INSERT INTO items VALUES (1, 'low'), (2, 'high'), (3, 'medium'), (4, 'high');
DROP TABLE IF EXISTS words;
CREATE TABLE words (id INT64, text STRING);
INSERT INTO words VALUES (1, 'apple'), (2, 'BANANA'), (3, 'Cherry');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, year INT64, quarter INT64, revenue FLOAT64);
INSERT INTO sales VALUES (1, 2023, 1, 100.0), (2, 2023, 2, 150.0), (3, 2024, 1, 120.0), (4, 2024, 1, 110.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64, name STRING);
INSERT INTO data VALUES (30, 'c'), (10, 'a'), (20, 'b');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (3, 'A', 100), (1, 'A', 200), (2, 'B', 150);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, NULL), (3, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5280
SELECT id FROM items ORDER BY CASE priority WHEN 'high' THEN 1 WHEN 'medium' THEN 2 WHEN 'low' THEN 3 ELSE 4 END, id;
-- Tag: cte_cte_test_select_5281
SELECT id FROM words ORDER BY UPPER(text);
-- Tag: cte_cte_test_select_5282
SELECT id FROM sales ORDER BY year DESC, quarter ASC, revenue DESC;
-- Tag: cte_cte_test_select_5283
SELECT id FROM data ORDER BY value ASC NULLS FIRST;
-- Tag: cte_cte_test_select_5284
SELECT id FROM data ORDER BY value ASC NULLS LAST;
-- Tag: cte_cte_test_select_5285
SELECT id FROM data ORDER BY value DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5286
SELECT id FROM data ORDER BY value DESC NULLS LAST;
-- Tag: cte_cte_test_select_5287
SELECT id FROM data ORDER BY value ASC;
-- Tag: cte_cte_test_select_5288
SELECT id FROM data ORDER BY value DESC;
-- Tag: cte_cte_test_select_5289
SELECT value, name FROM data ORDER BY 1;
-- Tag: cte_cte_test_select_5290
SELECT id, category, value FROM data ORDER BY 2, 1;
-- Tag: cte_cte_test_select_5291
SELECT value FROM data ORDER BY 1 DESC;
-- Tag: cte_cte_test_select_5292
SELECT value FROM data ORDER BY 1 NULLS FIRST;
-- Tag: cte_cte_test_select_5293
SELECT value * 2 AS doubled FROM data ORDER BY value * 2;
-- Tag: cte_cte_test_select_5294
SELECT id FROM data ORDER BY value NULLS FIRST;
-- Tag: cte_cte_test_select_5295
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5296
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5297
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5298
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5299
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5300
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5301
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5302
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5303
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5304
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5305
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5306
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5307
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5308
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5309
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5310
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5311
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5312
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5313
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS words;
CREATE TABLE words (id INT64, text STRING);
INSERT INTO words VALUES (1, 'apple'), (2, 'BANANA'), (3, 'Cherry');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, year INT64, quarter INT64, revenue FLOAT64);
INSERT INTO sales VALUES (1, 2023, 1, 100.0), (2, 2023, 2, 150.0), (3, 2024, 1, 120.0), (4, 2024, 1, 110.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64, name STRING);
INSERT INTO data VALUES (30, 'c'), (10, 'a'), (20, 'b');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (3, 'A', 100), (1, 'A', 200), (2, 'B', 150);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, NULL), (3, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5314
SELECT id FROM words ORDER BY UPPER(text);
-- Tag: cte_cte_test_select_5315
SELECT id FROM sales ORDER BY year DESC, quarter ASC, revenue DESC;
-- Tag: cte_cte_test_select_5316
SELECT id FROM data ORDER BY value ASC NULLS FIRST;
-- Tag: cte_cte_test_select_5317
SELECT id FROM data ORDER BY value ASC NULLS LAST;
-- Tag: cte_cte_test_select_5318
SELECT id FROM data ORDER BY value DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5319
SELECT id FROM data ORDER BY value DESC NULLS LAST;
-- Tag: cte_cte_test_select_5320
SELECT id FROM data ORDER BY value ASC;
-- Tag: cte_cte_test_select_5321
SELECT id FROM data ORDER BY value DESC;
-- Tag: cte_cte_test_select_5322
SELECT value, name FROM data ORDER BY 1;
-- Tag: cte_cte_test_select_5323
SELECT id, category, value FROM data ORDER BY 2, 1;
-- Tag: cte_cte_test_select_5324
SELECT value FROM data ORDER BY 1 DESC;
-- Tag: cte_cte_test_select_5325
SELECT value FROM data ORDER BY 1 NULLS FIRST;
-- Tag: cte_cte_test_select_5326
SELECT value * 2 AS doubled FROM data ORDER BY value * 2;
-- Tag: cte_cte_test_select_5327
SELECT id FROM data ORDER BY value NULLS FIRST;
-- Tag: cte_cte_test_select_5328
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5329
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5330
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5331
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5332
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5333
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5334
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5335
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5336
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5337
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5338
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5339
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5340
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5341
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5342
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5343
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5344
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5345
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5346
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, year INT64, quarter INT64, revenue FLOAT64);
INSERT INTO sales VALUES (1, 2023, 1, 100.0), (2, 2023, 2, 150.0), (3, 2024, 1, 120.0), (4, 2024, 1, 110.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64, name STRING);
INSERT INTO data VALUES (30, 'c'), (10, 'a'), (20, 'b');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (3, 'A', 100), (1, 'A', 200), (2, 'B', 150);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, NULL), (3, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5347
SELECT id FROM sales ORDER BY year DESC, quarter ASC, revenue DESC;
-- Tag: cte_cte_test_select_5348
SELECT id FROM data ORDER BY value ASC NULLS FIRST;
-- Tag: cte_cte_test_select_5349
SELECT id FROM data ORDER BY value ASC NULLS LAST;
-- Tag: cte_cte_test_select_5350
SELECT id FROM data ORDER BY value DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5351
SELECT id FROM data ORDER BY value DESC NULLS LAST;
-- Tag: cte_cte_test_select_5352
SELECT id FROM data ORDER BY value ASC;
-- Tag: cte_cte_test_select_5353
SELECT id FROM data ORDER BY value DESC;
-- Tag: cte_cte_test_select_5354
SELECT value, name FROM data ORDER BY 1;
-- Tag: cte_cte_test_select_5355
SELECT id, category, value FROM data ORDER BY 2, 1;
-- Tag: cte_cte_test_select_5356
SELECT value FROM data ORDER BY 1 DESC;
-- Tag: cte_cte_test_select_5357
SELECT value FROM data ORDER BY 1 NULLS FIRST;
-- Tag: cte_cte_test_select_5358
SELECT value * 2 AS doubled FROM data ORDER BY value * 2;
-- Tag: cte_cte_test_select_5359
SELECT id FROM data ORDER BY value NULLS FIRST;
-- Tag: cte_cte_test_select_5360
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5361
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5362
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5363
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5364
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5365
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5366
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5367
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5368
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5369
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5370
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5371
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5372
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5373
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5374
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5375
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5376
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5377
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5378
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64, name STRING);
INSERT INTO data VALUES (30, 'c'), (10, 'a'), (20, 'b');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (3, 'A', 100), (1, 'A', 200), (2, 'B', 150);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, NULL), (3, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5379
SELECT id FROM data ORDER BY value ASC NULLS FIRST;
-- Tag: cte_cte_test_select_5380
SELECT id FROM data ORDER BY value ASC NULLS LAST;
-- Tag: cte_cte_test_select_5381
SELECT id FROM data ORDER BY value DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5382
SELECT id FROM data ORDER BY value DESC NULLS LAST;
-- Tag: cte_cte_test_select_5383
SELECT id FROM data ORDER BY value ASC;
-- Tag: cte_cte_test_select_5384
SELECT id FROM data ORDER BY value DESC;
-- Tag: cte_cte_test_select_5385
SELECT value, name FROM data ORDER BY 1;
-- Tag: cte_cte_test_select_5386
SELECT id, category, value FROM data ORDER BY 2, 1;
-- Tag: cte_cte_test_select_5387
SELECT value FROM data ORDER BY 1 DESC;
-- Tag: cte_cte_test_select_5388
SELECT value FROM data ORDER BY 1 NULLS FIRST;
-- Tag: cte_cte_test_select_5389
SELECT value * 2 AS doubled FROM data ORDER BY value * 2;
-- Tag: cte_cte_test_select_5390
SELECT id FROM data ORDER BY value NULLS FIRST;
-- Tag: cte_cte_test_select_5391
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5392
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5393
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5394
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5395
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5396
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5397
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5398
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5399
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5400
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5401
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5402
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5403
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5404
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5405
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5406
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5407
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5408
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5409
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64, name STRING);
INSERT INTO data VALUES (30, 'c'), (10, 'a'), (20, 'b');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (3, 'A', 100), (1, 'A', 200), (2, 'B', 150);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, NULL), (3, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5410
SELECT id FROM data ORDER BY value ASC NULLS LAST;
-- Tag: cte_cte_test_select_5411
SELECT id FROM data ORDER BY value DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5412
SELECT id FROM data ORDER BY value DESC NULLS LAST;
-- Tag: cte_cte_test_select_5413
SELECT id FROM data ORDER BY value ASC;
-- Tag: cte_cte_test_select_5414
SELECT id FROM data ORDER BY value DESC;
-- Tag: cte_cte_test_select_5415
SELECT value, name FROM data ORDER BY 1;
-- Tag: cte_cte_test_select_5416
SELECT id, category, value FROM data ORDER BY 2, 1;
-- Tag: cte_cte_test_select_5417
SELECT value FROM data ORDER BY 1 DESC;
-- Tag: cte_cte_test_select_5418
SELECT value FROM data ORDER BY 1 NULLS FIRST;
-- Tag: cte_cte_test_select_5419
SELECT value * 2 AS doubled FROM data ORDER BY value * 2;
-- Tag: cte_cte_test_select_5420
SELECT id FROM data ORDER BY value NULLS FIRST;
-- Tag: cte_cte_test_select_5421
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5422
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5423
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5424
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5425
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5426
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5427
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5428
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5429
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5430
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5431
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5432
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5433
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5434
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5435
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5436
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5437
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5438
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5439
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64, name STRING);
INSERT INTO data VALUES (30, 'c'), (10, 'a'), (20, 'b');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (3, 'A', 100), (1, 'A', 200), (2, 'B', 150);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, NULL), (3, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5440
SELECT id FROM data ORDER BY value DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5441
SELECT id FROM data ORDER BY value DESC NULLS LAST;
-- Tag: cte_cte_test_select_5442
SELECT id FROM data ORDER BY value ASC;
-- Tag: cte_cte_test_select_5443
SELECT id FROM data ORDER BY value DESC;
-- Tag: cte_cte_test_select_5444
SELECT value, name FROM data ORDER BY 1;
-- Tag: cte_cte_test_select_5445
SELECT id, category, value FROM data ORDER BY 2, 1;
-- Tag: cte_cte_test_select_5446
SELECT value FROM data ORDER BY 1 DESC;
-- Tag: cte_cte_test_select_5447
SELECT value FROM data ORDER BY 1 NULLS FIRST;
-- Tag: cte_cte_test_select_5448
SELECT value * 2 AS doubled FROM data ORDER BY value * 2;
-- Tag: cte_cte_test_select_5449
SELECT id FROM data ORDER BY value NULLS FIRST;
-- Tag: cte_cte_test_select_5450
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5451
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5452
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5453
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5454
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5455
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5456
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5457
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5458
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5459
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5460
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5461
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5462
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5463
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5464
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5465
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5466
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5467
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5468
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20), (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64, name STRING);
INSERT INTO data VALUES (30, 'c'), (10, 'a'), (20, 'b');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (3, 'A', 100), (1, 'A', 200), (2, 'B', 150);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, NULL), (3, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5469
SELECT id FROM data ORDER BY value DESC NULLS LAST;
-- Tag: cte_cte_test_select_5470
SELECT id FROM data ORDER BY value ASC;
-- Tag: cte_cte_test_select_5471
SELECT id FROM data ORDER BY value DESC;
-- Tag: cte_cte_test_select_5472
SELECT value, name FROM data ORDER BY 1;
-- Tag: cte_cte_test_select_5473
SELECT id, category, value FROM data ORDER BY 2, 1;
-- Tag: cte_cte_test_select_5474
SELECT value FROM data ORDER BY 1 DESC;
-- Tag: cte_cte_test_select_5475
SELECT value FROM data ORDER BY 1 NULLS FIRST;
-- Tag: cte_cte_test_select_5476
SELECT value * 2 AS doubled FROM data ORDER BY value * 2;
-- Tag: cte_cte_test_select_5477
SELECT id FROM data ORDER BY value NULLS FIRST;
-- Tag: cte_cte_test_select_5478
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5479
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5480
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5481
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5482
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5483
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5484
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5485
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5486
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5487
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5488
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5489
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5490
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5491
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5492
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5493
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5494
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5495
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5496
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64, name STRING);
INSERT INTO data VALUES (30, 'c'), (10, 'a'), (20, 'b');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (3, 'A', 100), (1, 'A', 200), (2, 'B', 150);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, NULL), (3, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5497
SELECT id FROM data ORDER BY value ASC;
-- Tag: cte_cte_test_select_5498
SELECT id FROM data ORDER BY value DESC;
-- Tag: cte_cte_test_select_5499
SELECT value, name FROM data ORDER BY 1;
-- Tag: cte_cte_test_select_5500
SELECT id, category, value FROM data ORDER BY 2, 1;
-- Tag: cte_cte_test_select_5501
SELECT value FROM data ORDER BY 1 DESC;
-- Tag: cte_cte_test_select_5502
SELECT value FROM data ORDER BY 1 NULLS FIRST;
-- Tag: cte_cte_test_select_5503
SELECT value * 2 AS doubled FROM data ORDER BY value * 2;
-- Tag: cte_cte_test_select_5504
SELECT id FROM data ORDER BY value NULLS FIRST;
-- Tag: cte_cte_test_select_5505
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5506
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5507
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5508
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5509
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5510
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5511
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5512
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5513
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5514
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5515
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5516
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5517
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5518
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5519
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5520
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5521
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5522
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5523
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64, name STRING);
INSERT INTO data VALUES (30, 'c'), (10, 'a'), (20, 'b');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (3, 'A', 100), (1, 'A', 200), (2, 'B', 150);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, NULL), (3, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5524
SELECT id FROM data ORDER BY value DESC;
-- Tag: cte_cte_test_select_5525
SELECT value, name FROM data ORDER BY 1;
-- Tag: cte_cte_test_select_5526
SELECT id, category, value FROM data ORDER BY 2, 1;
-- Tag: cte_cte_test_select_5527
SELECT value FROM data ORDER BY 1 DESC;
-- Tag: cte_cte_test_select_5528
SELECT value FROM data ORDER BY 1 NULLS FIRST;
-- Tag: cte_cte_test_select_5529
SELECT value * 2 AS doubled FROM data ORDER BY value * 2;
-- Tag: cte_cte_test_select_5530
SELECT id FROM data ORDER BY value NULLS FIRST;
-- Tag: cte_cte_test_select_5531
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5532
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5533
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5534
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5535
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5536
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5537
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5538
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5539
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5540
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5541
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5542
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5543
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5544
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5545
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5546
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5547
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5548
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5549
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64, name STRING);
INSERT INTO data VALUES (30, 'c'), (10, 'a'), (20, 'b');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (3, 'A', 100), (1, 'A', 200), (2, 'B', 150);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, NULL), (3, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5550
SELECT value, name FROM data ORDER BY 1;
-- Tag: cte_cte_test_select_5551
SELECT id, category, value FROM data ORDER BY 2, 1;
-- Tag: cte_cte_test_select_5552
SELECT value FROM data ORDER BY 1 DESC;
-- Tag: cte_cte_test_select_5553
SELECT value FROM data ORDER BY 1 NULLS FIRST;
-- Tag: cte_cte_test_select_5554
SELECT value * 2 AS doubled FROM data ORDER BY value * 2;
-- Tag: cte_cte_test_select_5555
SELECT id FROM data ORDER BY value NULLS FIRST;
-- Tag: cte_cte_test_select_5556
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5557
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5558
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5559
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5560
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5561
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5562
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5563
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5564
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5565
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5566
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5567
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5568
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5569
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5570
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5571
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5572
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5573
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5574
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES (3, 'A', 100), (1, 'A', 200), (2, 'B', 150);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, NULL), (3, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5575
SELECT id, category, value FROM data ORDER BY 2, 1;
-- Tag: cte_cte_test_select_5576
SELECT value FROM data ORDER BY 1 DESC;
-- Tag: cte_cte_test_select_5577
SELECT value FROM data ORDER BY 1 NULLS FIRST;
-- Tag: cte_cte_test_select_5578
SELECT value * 2 AS doubled FROM data ORDER BY value * 2;
-- Tag: cte_cte_test_select_5579
SELECT id FROM data ORDER BY value NULLS FIRST;
-- Tag: cte_cte_test_select_5580
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5581
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5582
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5583
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5584
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5585
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5586
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5587
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5588
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5589
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5590
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5591
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5592
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5593
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5594
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5595
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5596
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5597
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5598
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (30), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, NULL), (3, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5599
SELECT value FROM data ORDER BY 1 DESC;
-- Tag: cte_cte_test_select_5600
SELECT value FROM data ORDER BY 1 NULLS FIRST;
-- Tag: cte_cte_test_select_5601
SELECT value * 2 AS doubled FROM data ORDER BY value * 2;
-- Tag: cte_cte_test_select_5602
SELECT id FROM data ORDER BY value NULLS FIRST;
-- Tag: cte_cte_test_select_5603
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5604
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5605
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5606
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5607
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5608
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5609
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5610
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5611
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5612
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5613
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5614
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5615
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5616
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5617
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5618
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5619
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5620
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5621
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10), (NULL), (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, NULL), (3, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5622
SELECT value FROM data ORDER BY 1 NULLS FIRST;
-- Tag: cte_cte_test_select_5623
SELECT value * 2 AS doubled FROM data ORDER BY value * 2;
-- Tag: cte_cte_test_select_5624
SELECT id FROM data ORDER BY value NULLS FIRST;
-- Tag: cte_cte_test_select_5625
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5626
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5627
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5628
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5629
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5630
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5631
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5632
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5633
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5634
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5635
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5636
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5637
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5638
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5639
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5640
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5641
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5642
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5643
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, NULL), (3, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5644
SELECT value * 2 AS doubled FROM data ORDER BY value * 2;
-- Tag: cte_cte_test_select_5645
SELECT id FROM data ORDER BY value NULLS FIRST;
-- Tag: cte_cte_test_select_5646
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5647
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5648
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5649
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5650
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5651
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5652
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5653
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5654
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5655
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5656
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5657
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5658
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5659
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5660
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5661
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5662
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5663
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5664
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, NULL), (3, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5665
SELECT id FROM data ORDER BY value NULLS FIRST;
-- Tag: cte_cte_test_select_5666
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5667
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5668
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5669
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5670
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5671
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5672
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5673
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5674
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5675
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5676
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5677
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5678
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5679
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5680
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5681
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5682
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5683
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5684
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5685
SELECT id FROM data ORDER BY value * 2 NULLS LAST;
-- Tag: cte_cte_test_select_5686
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5687
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5688
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5689
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5690
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5691
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5692
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5693
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5694
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5695
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5696
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5697
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5698
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5699
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5700
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5701
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5702
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5703
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5704
SELECT id FROM data ORDER BY CASE WHEN category = 'B' THEN NULL ELSE id END NULLS FIRST;
-- Tag: cte_cte_test_select_5705
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5706
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5707
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5708
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5709
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5710
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5711
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5712
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5713
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5714
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5715
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5716
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5717
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5718
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5719
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5720
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5721
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5722
SELECT id FROM data ORDER BY COALESCE(value, 999);
-- Tag: cte_cte_test_select_5723
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5724
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5725
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5726
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5727
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5728
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5729
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5730
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5731
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5732
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5733
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5734
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5735
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5736
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5737
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5738
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, text STRING);
INSERT INTO data VALUES (1, '  abc  '), (2, 'DEF'), (3, '  ghi');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5739
SELECT id FROM data ORDER BY UPPER(TRIM(text));
-- Tag: cte_cte_test_select_5740
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5741
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5742
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5743
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5744
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5745
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5746
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5747
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5748
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5749
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5750
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5751
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5752
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5753
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5754
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b INT64);
INSERT INTO data VALUES (1, NULL, 10), (2, 5, NULL), (3, 5, 20), (4, NULL, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5755
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST;
-- Tag: cte_cte_test_select_5756
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5757
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5758
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5759
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5760
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5761
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5762
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5763
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5764
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5765
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5766
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5767
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5768
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5769
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20), (4, 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5770
SELECT id FROM data ORDER BY value * 2 DESC LIMIT 2;
-- Tag: cte_cte_test_select_5771
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5772
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5773
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5774
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5775
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5776
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5777
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5778
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5779
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5780
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5781
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5782
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5783
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5784
SELECT id FROM data ORDER BY value ASC OFFSET 1;
-- Tag: cte_cte_test_select_5785
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5786
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5787
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5788
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5789
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5790
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5791
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5792
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5793
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5794
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5795
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5796
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 10), ('A', 20), ('B', 10), ('B', 30);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5797
SELECT DISTINCT category FROM data ORDER BY category DESC;
-- Tag: cte_cte_test_select_5798
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5799
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5800
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5801
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5802
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5803
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5804
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5805
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5806
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5807
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5808
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (category STRING, amount FLOAT64);
INSERT INTO sales VALUES ('A', 100.0), ('A', 200.0), ('B', 150.0), ('B', 50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5809
SELECT category, SUM(amount) as total FROM sales GROUP BY category ORDER BY SUM(amount) DESC;
-- Tag: cte_cte_test_select_5810
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5811
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5812
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5813
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5814
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5815
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5816
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5817
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5818
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5819
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 10), (3, NULL), (4, 20), (5, 30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5820
SELECT id FROM data ORDER BY value NULLS FIRST LIMIT 3;
-- Tag: cte_cte_test_select_5821
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5822
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5823
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5824
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5825
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5826
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5827
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5828
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5829
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5830
SELECT value FROM data ORDER BY 0;
-- Tag: cte_cte_test_select_5831
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5832
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5833
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5834
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5835
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5836
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5837
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5838
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (a INT64, b INT64);
INSERT INTO data VALUES (10, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5839
SELECT a, b FROM data ORDER BY 3;
-- Tag: cte_cte_test_select_5840
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5841
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5842
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5843
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5844
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5845
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5846
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5847
SELECT value FROM data ORDER BY undefined_col * 2;
-- Tag: cte_cte_test_select_5848
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5849
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5850
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5851
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5852
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5853
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5854
SELECT value FROM data ORDER BY INVALID_FUNC(value);
-- Tag: cte_cte_test_select_5855
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5856
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5857
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5858
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5859
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (text STRING);
INSERT INTO data VALUES ('abc');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5860
SELECT text FROM data ORDER BY text * 2;
-- Tag: cte_cte_test_select_5861
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5862
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5863
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5864
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 30), (2, 10), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

-- Tag: cte_cte_test_select_5865
SELECT * FROM (SELECT id, value * 2 AS doubled FROM data ORDER BY value * 2) AS sub;
WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5866
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5867
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5868
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 30), (3, 20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a INT64, b STRING, c FLOAT64);
INSERT INTO data VALUES (1, NULL, 'x', 1.0), (2, 10, NULL, 2.0), (3, 10, 'y', NULL), (4, 10, 'y', 3.0), (5, NULL, NULL, 4.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);

WITH doubled AS (SELECT id, value * 2 AS val FROM data) SELECT id FROM doubled ORDER BY val DESC;
-- Tag: cte_cte_test_select_5869
SELECT id FROM data ORDER BY a NULLS FIRST, b NULLS LAST, c DESC NULLS FIRST;
-- Tag: cte_cte_test_select_5870
SELECT id FROM data ORDER BY value * 2 LIMIT 10;
-- Tag: cte_cte_test_select_5871
SELECT id FROM data ORDER BY value NULLS LAST LIMIT 5;

DROP TABLE IF EXISTS test;
CREATE TABLE test (text STRING);
INSERT INTO test VALUES ('aaaaaaaaaaaaaaaaaaaaaaaaaaaa');
DROP TABLE IF EXISTS test;
CREATE TABLE test (text STRING);
INSERT INTO test VALUES ('aaaaaaaaaaaaaaaaaaaaac');
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (data STRING);

-- Tag: cte_cte_test_select_5872
SELECT * FROM test WHERE text LIKE '%a%a%a%a%a%a%a%a%a%a%b';
-- Tag: cte_cte_test_select_5873
SELECT * FROM test WHERE REGEXP_CONTAINS(text, '(a+)+b');
WITH RECURSIVE cte AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM cte WHERE n < 10000 ) SELECT MAX(n) FROM cte;
WITH RECURSIVE cte AS ( SELECT 1 as n UNION ALL SELECT n FROM cte UNION ALL SELECT n FROM cte ) SELECT COUNT(*) FROM cte;
-- Tag: cte_cte_test_select_5874
SELECT * FROM test ORDER BY id DESC;
-- Tag: cte_cte_test_select_5875
SELECT * FROM test t1, test t2, test t3 WHERE t1.id + t2.id + t3.id > 999999999;
-- Tag: cte_cte_test_select_5876
SELECT * FROM test;

DROP TABLE IF EXISTS test;
CREATE TABLE test (text STRING);
INSERT INTO test VALUES ('aaaaaaaaaaaaaaaaaaaaac');
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (data STRING);

-- Tag: cte_cte_test_select_5877
SELECT * FROM test WHERE REGEXP_CONTAINS(text, '(a+)+b');
WITH RECURSIVE cte AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM cte WHERE n < 10000 ) SELECT MAX(n) FROM cte;
WITH RECURSIVE cte AS ( SELECT 1 as n UNION ALL SELECT n FROM cte UNION ALL SELECT n FROM cte ) SELECT COUNT(*) FROM cte;
-- Tag: cte_cte_test_select_5878
SELECT * FROM test ORDER BY id DESC;
-- Tag: cte_cte_test_select_5879
SELECT * FROM test t1, test t2, test t3 WHERE t1.id + t2.id + t3.id > 999999999;
-- Tag: cte_cte_test_select_5880
SELECT * FROM test;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (data STRING);

WITH RECURSIVE cte AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM cte WHERE n < 10000 ) SELECT MAX(n) FROM cte;
WITH RECURSIVE cte AS ( SELECT 1 as n UNION ALL SELECT n FROM cte UNION ALL SELECT n FROM cte ) SELECT COUNT(*) FROM cte;
-- Tag: cte_cte_test_select_5881
SELECT * FROM test ORDER BY id DESC;
-- Tag: cte_cte_test_select_5882
SELECT * FROM test t1, test t2, test t3 WHERE t1.id + t2.id + t3.id > 999999999;
-- Tag: cte_cte_test_select_5883
SELECT * FROM test;

DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (data STRING);

WITH RECURSIVE cte AS ( SELECT 1 as n UNION ALL SELECT n FROM cte UNION ALL SELECT n FROM cte ) SELECT COUNT(*) FROM cte;
-- Tag: cte_cte_test_select_5884
SELECT * FROM test ORDER BY id DESC;
-- Tag: cte_cte_test_select_5885
SELECT * FROM test t1, test t2, test t3 WHERE t1.id + t2.id + t3.id > 999999999;
-- Tag: cte_cte_test_select_5886
SELECT * FROM test;

-- Base case: Start with VP Engineering
-- Recursive case: Find direct reports
-- Base case: F(0) = 0, F(1) = 1
-- Recursive case: F(n+1) = F(n) + F(n-1)
-- Base case returns no rows
-- Recursive case will never execute
-- Base case: Start with CEO (manager_id is NULL)
-- Recursive case: Try to find manager (will fail for NULL)
-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS circular;
CREATE TABLE circular (id INT64, next_id INT64);
INSERT INTO circular VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (1, 3), (2, 4), (3, 4);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (1, 3), (2, 4), (3, 4);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 2), (3, 4);
DROP TABLE IF EXISTS parts;
CREATE TABLE parts ( part_id INT64, part_name STRING, quantity INT64 );
DROP TABLE IF EXISTS bom;
CREATE TABLE bom ( parent_part_id INT64, child_part_id INT64, quantity_needed INT64 );
INSERT INTO parts VALUES (1, 'Car', 1), (2, 'Engine', 1), (3, 'Wheel', 4), (4, 'Piston', 4), (5, 'Tire', 1);
INSERT INTO bom VALUES (1, 2, 1), (1, 3, 4), (2, 4, 4), (3, 5, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 5 ) SELECT * FROM numbers ORDER BY n;
WITH RECURSIVE subordinates AS (;
-- Tag: cte_cte_test_select_5887
SELECT id, name, manager_id, 0 AS level FROM employees WHERE id = 2 UNION ALL;
-- Tag: cte_cte_test_select_5888
SELECT e.id, e.name, e.manager_id, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT * FROM subordinates ORDER BY level, id;
WITH RECURSIVE fibonacci(n, fib_n, fib_n_plus_1) AS (;
-- Tag: cte_cte_test_select_5889
SELECT 0 AS n, 0 AS fib_n, 1 AS fib_n_plus_1 UNION ALL;
-- Tag: cte_cte_test_select_5890
SELECT n + 1, fib_n_plus_1, fib_n + fib_n_plus_1 FROM fibonacci WHERE n < 9 ) SELECT n, fib_n FROM fibonacci ORDER BY n;
WITH RECURSIVE empty_cte AS (;
-- Tag: cte_cte_test_select_5891
SELECT id, name FROM employees WHERE id = 999 UNION ALL;
-- Tag: cte_cte_test_select_5892
SELECT e.id, e.name FROM employees e INNER JOIN empty_cte ec ON e.manager_id = ec.id ) SELECT * FROM empty_cte;
WITH RECURSIVE ancestors AS (;
-- Tag: cte_cte_test_select_5893
SELECT id, name, manager_id FROM employees WHERE id = 1 UNION ALL;
-- Tag: cte_cte_test_select_5894
SELECT e.id, e.name, e.manager_id FROM employees e INNER JOIN ancestors a ON e.id = a.manager_id ) SELECT * FROM ancestors;
WITH numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 5 ) SELECT * FROM numbers;
WITH RECURSIVE cycle AS ( SELECT id, next_id FROM circular WHERE id = 1 UNION ALL SELECT c.id, c.next_id FROM circular c INNER JOIN cycle cy ON c.id = cy.next_id ) SELECT * FROM cycle;
WITH RECURSIVE reachable AS ( SELECT node_to AS node FROM graph WHERE node_from = 1 UNION SELECT g.node_to FROM graph g INNER JOIN reachable r ON g.node_from = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE paths AS ( SELECT node_from, node_to, 1 AS depth FROM graph WHERE node_from = 1 UNION ALL SELECT p.node_from, g.node_to, p.depth + 1 FROM graph g INNER JOIN paths p ON g.node_from = p.node_to WHERE p.depth < 3 ) SELECT * FROM paths ORDER BY depth, node_to;
WITH RECURSIVE subordinates AS ( SELECT id, name, manager_id, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, s.depth + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id WHERE s.depth < 2 ) SELECT * FROM subordinates ORDER BY depth, id;
WITH RECURSIVE high_earners AS ( SELECT id, name, salary, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, h.depth + 1 FROM employees e INNER JOIN high_earners h ON e.manager_id = h.id WHERE h.depth < 5 AND e.salary >= 100000 ) SELECT * FROM high_earners ORDER BY depth, id;
WITH RECURSIVE org_levels AS ( SELECT id, 0 AS level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, ol.level + 1 FROM employees e INNER JOIN org_levels ol ON e.manager_id = ol.id ) SELECT level, COUNT(*) AS employee_count FROM org_levels GROUP BY level ORDER BY level;
WITH RECURSIVE team_members AS ( SELECT id, salary FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.salary FROM employees e INNER JOIN team_members tm ON e.manager_id = tm.id ) SELECT SUM(salary) AS total_team_salary FROM team_members;
WITH RECURSIVE org_path AS ( SELECT id, name, CAST(name AS STRING) AS path, 0 AS depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, CONCAT(op.path, ' > ', e.name), op.depth + 1 FROM employees e INNER JOIN org_path op ON e.manager_id = op.id ) SELECT name, path FROM org_path WHERE id = 7 ORDER BY depth DESC;
WITH high_salary_threshold AS ( SELECT AVG(salary) * 1.2 AS threshold FROM employees ), RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT s.name, s.salary, s.level FROM subordinates s, high_salary_threshold hst WHERE s.salary >= hst.threshold ORDER BY s.level;
WITH RECURSIVE traversal AS ( SELECT node_from, node_to, ARRAY[node_from] AS path FROM graph WHERE node_from = 1 UNION ALL SELECT g.node_from, g.node_to, ARRAY_APPEND(t.path, g.node_from) FROM graph g INNER JOIN traversal t ON g.node_from = t.node_to WHERE NOT (g.node_from = ANY(t.path)) ) SELECT * FROM traversal;
WITH RECURSIVE bom_explosion AS ( SELECT b.parent_part_id, b.child_part_id, b.quantity_needed, 1 AS level FROM bom b WHERE parent_part_id = 1 UNION ALL SELECT be.parent_part_id, b.child_part_id, be.quantity_needed * b.quantity_needed, be.level + 1 FROM bom b INNER JOIN bom_explosion be ON b.parent_part_id = be.child_part_id WHERE be.level < 10 ) SELECT child_part_id, SUM(quantity_needed) AS total_quantity FROM bom_explosion GROUP BY child_part_id ORDER BY child_part_id;
WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_5895
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_5896
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_5897
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_5898
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_5899
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_5900
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_5901
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_5902
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_5903
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- Base case: Start with VP Engineering
-- Recursive case: Find direct reports
-- Base case: F(0) = 0, F(1) = 1
-- Recursive case: F(n+1) = F(n) + F(n-1)
-- Base case returns no rows
-- Recursive case will never execute
-- Base case: Start with CEO (manager_id is NULL)
-- Recursive case: Try to find manager (will fail for NULL)
-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS circular;
CREATE TABLE circular (id INT64, next_id INT64);
INSERT INTO circular VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (1, 3), (2, 4), (3, 4);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (1, 3), (2, 4), (3, 4);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 2), (3, 4);
DROP TABLE IF EXISTS parts;
CREATE TABLE parts ( part_id INT64, part_name STRING, quantity INT64 );
DROP TABLE IF EXISTS bom;
CREATE TABLE bom ( parent_part_id INT64, child_part_id INT64, quantity_needed INT64 );
INSERT INTO parts VALUES (1, 'Car', 1), (2, 'Engine', 1), (3, 'Wheel', 4), (4, 'Piston', 4), (5, 'Tire', 1);
INSERT INTO bom VALUES (1, 2, 1), (1, 3, 4), (2, 4, 4), (3, 5, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE subordinates AS (;
-- Tag: cte_cte_test_select_5904
SELECT id, name, manager_id, 0 AS level FROM employees WHERE id = 2 UNION ALL;
-- Tag: cte_cte_test_select_5905
SELECT e.id, e.name, e.manager_id, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT * FROM subordinates ORDER BY level, id;
WITH RECURSIVE fibonacci(n, fib_n, fib_n_plus_1) AS (;
-- Tag: cte_cte_test_select_5906
SELECT 0 AS n, 0 AS fib_n, 1 AS fib_n_plus_1 UNION ALL;
-- Tag: cte_cte_test_select_5907
SELECT n + 1, fib_n_plus_1, fib_n + fib_n_plus_1 FROM fibonacci WHERE n < 9 ) SELECT n, fib_n FROM fibonacci ORDER BY n;
WITH RECURSIVE empty_cte AS (;
-- Tag: cte_cte_test_select_5908
SELECT id, name FROM employees WHERE id = 999 UNION ALL;
-- Tag: cte_cte_test_select_5909
SELECT e.id, e.name FROM employees e INNER JOIN empty_cte ec ON e.manager_id = ec.id ) SELECT * FROM empty_cte;
WITH RECURSIVE ancestors AS (;
-- Tag: cte_cte_test_select_5910
SELECT id, name, manager_id FROM employees WHERE id = 1 UNION ALL;
-- Tag: cte_cte_test_select_5911
SELECT e.id, e.name, e.manager_id FROM employees e INNER JOIN ancestors a ON e.id = a.manager_id ) SELECT * FROM ancestors;
WITH numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 5 ) SELECT * FROM numbers;
WITH RECURSIVE cycle AS ( SELECT id, next_id FROM circular WHERE id = 1 UNION ALL SELECT c.id, c.next_id FROM circular c INNER JOIN cycle cy ON c.id = cy.next_id ) SELECT * FROM cycle;
WITH RECURSIVE reachable AS ( SELECT node_to AS node FROM graph WHERE node_from = 1 UNION SELECT g.node_to FROM graph g INNER JOIN reachable r ON g.node_from = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE paths AS ( SELECT node_from, node_to, 1 AS depth FROM graph WHERE node_from = 1 UNION ALL SELECT p.node_from, g.node_to, p.depth + 1 FROM graph g INNER JOIN paths p ON g.node_from = p.node_to WHERE p.depth < 3 ) SELECT * FROM paths ORDER BY depth, node_to;
WITH RECURSIVE subordinates AS ( SELECT id, name, manager_id, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, s.depth + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id WHERE s.depth < 2 ) SELECT * FROM subordinates ORDER BY depth, id;
WITH RECURSIVE high_earners AS ( SELECT id, name, salary, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, h.depth + 1 FROM employees e INNER JOIN high_earners h ON e.manager_id = h.id WHERE h.depth < 5 AND e.salary >= 100000 ) SELECT * FROM high_earners ORDER BY depth, id;
WITH RECURSIVE org_levels AS ( SELECT id, 0 AS level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, ol.level + 1 FROM employees e INNER JOIN org_levels ol ON e.manager_id = ol.id ) SELECT level, COUNT(*) AS employee_count FROM org_levels GROUP BY level ORDER BY level;
WITH RECURSIVE team_members AS ( SELECT id, salary FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.salary FROM employees e INNER JOIN team_members tm ON e.manager_id = tm.id ) SELECT SUM(salary) AS total_team_salary FROM team_members;
WITH RECURSIVE org_path AS ( SELECT id, name, CAST(name AS STRING) AS path, 0 AS depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, CONCAT(op.path, ' > ', e.name), op.depth + 1 FROM employees e INNER JOIN org_path op ON e.manager_id = op.id ) SELECT name, path FROM org_path WHERE id = 7 ORDER BY depth DESC;
WITH high_salary_threshold AS ( SELECT AVG(salary) * 1.2 AS threshold FROM employees ), RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT s.name, s.salary, s.level FROM subordinates s, high_salary_threshold hst WHERE s.salary >= hst.threshold ORDER BY s.level;
WITH RECURSIVE traversal AS ( SELECT node_from, node_to, ARRAY[node_from] AS path FROM graph WHERE node_from = 1 UNION ALL SELECT g.node_from, g.node_to, ARRAY_APPEND(t.path, g.node_from) FROM graph g INNER JOIN traversal t ON g.node_from = t.node_to WHERE NOT (g.node_from = ANY(t.path)) ) SELECT * FROM traversal;
WITH RECURSIVE bom_explosion AS ( SELECT b.parent_part_id, b.child_part_id, b.quantity_needed, 1 AS level FROM bom b WHERE parent_part_id = 1 UNION ALL SELECT be.parent_part_id, b.child_part_id, be.quantity_needed * b.quantity_needed, be.level + 1 FROM bom b INNER JOIN bom_explosion be ON b.parent_part_id = be.child_part_id WHERE be.level < 10 ) SELECT child_part_id, SUM(quantity_needed) AS total_quantity FROM bom_explosion GROUP BY child_part_id ORDER BY child_part_id;
WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_5912
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_5913
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_5914
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_5915
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_5916
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_5917
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_5918
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_5919
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_5920
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- Base case: F(0) = 0, F(1) = 1
-- Recursive case: F(n+1) = F(n) + F(n-1)
-- Base case returns no rows
-- Recursive case will never execute
-- Base case: Start with CEO (manager_id is NULL)
-- Recursive case: Try to find manager (will fail for NULL)
-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS circular;
CREATE TABLE circular (id INT64, next_id INT64);
INSERT INTO circular VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (1, 3), (2, 4), (3, 4);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (1, 3), (2, 4), (3, 4);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 2), (3, 4);
DROP TABLE IF EXISTS parts;
CREATE TABLE parts ( part_id INT64, part_name STRING, quantity INT64 );
DROP TABLE IF EXISTS bom;
CREATE TABLE bom ( parent_part_id INT64, child_part_id INT64, quantity_needed INT64 );
INSERT INTO parts VALUES (1, 'Car', 1), (2, 'Engine', 1), (3, 'Wheel', 4), (4, 'Piston', 4), (5, 'Tire', 1);
INSERT INTO bom VALUES (1, 2, 1), (1, 3, 4), (2, 4, 4), (3, 5, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE fibonacci(n, fib_n, fib_n_plus_1) AS (;
-- Tag: cte_cte_test_select_5921
SELECT 0 AS n, 0 AS fib_n, 1 AS fib_n_plus_1 UNION ALL;
-- Tag: cte_cte_test_select_5922
SELECT n + 1, fib_n_plus_1, fib_n + fib_n_plus_1 FROM fibonacci WHERE n < 9 ) SELECT n, fib_n FROM fibonacci ORDER BY n;
WITH RECURSIVE empty_cte AS (;
-- Tag: cte_cte_test_select_5923
SELECT id, name FROM employees WHERE id = 999 UNION ALL;
-- Tag: cte_cte_test_select_5924
SELECT e.id, e.name FROM employees e INNER JOIN empty_cte ec ON e.manager_id = ec.id ) SELECT * FROM empty_cte;
WITH RECURSIVE ancestors AS (;
-- Tag: cte_cte_test_select_5925
SELECT id, name, manager_id FROM employees WHERE id = 1 UNION ALL;
-- Tag: cte_cte_test_select_5926
SELECT e.id, e.name, e.manager_id FROM employees e INNER JOIN ancestors a ON e.id = a.manager_id ) SELECT * FROM ancestors;
WITH numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 5 ) SELECT * FROM numbers;
WITH RECURSIVE cycle AS ( SELECT id, next_id FROM circular WHERE id = 1 UNION ALL SELECT c.id, c.next_id FROM circular c INNER JOIN cycle cy ON c.id = cy.next_id ) SELECT * FROM cycle;
WITH RECURSIVE reachable AS ( SELECT node_to AS node FROM graph WHERE node_from = 1 UNION SELECT g.node_to FROM graph g INNER JOIN reachable r ON g.node_from = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE paths AS ( SELECT node_from, node_to, 1 AS depth FROM graph WHERE node_from = 1 UNION ALL SELECT p.node_from, g.node_to, p.depth + 1 FROM graph g INNER JOIN paths p ON g.node_from = p.node_to WHERE p.depth < 3 ) SELECT * FROM paths ORDER BY depth, node_to;
WITH RECURSIVE subordinates AS ( SELECT id, name, manager_id, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, s.depth + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id WHERE s.depth < 2 ) SELECT * FROM subordinates ORDER BY depth, id;
WITH RECURSIVE high_earners AS ( SELECT id, name, salary, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, h.depth + 1 FROM employees e INNER JOIN high_earners h ON e.manager_id = h.id WHERE h.depth < 5 AND e.salary >= 100000 ) SELECT * FROM high_earners ORDER BY depth, id;
WITH RECURSIVE org_levels AS ( SELECT id, 0 AS level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, ol.level + 1 FROM employees e INNER JOIN org_levels ol ON e.manager_id = ol.id ) SELECT level, COUNT(*) AS employee_count FROM org_levels GROUP BY level ORDER BY level;
WITH RECURSIVE team_members AS ( SELECT id, salary FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.salary FROM employees e INNER JOIN team_members tm ON e.manager_id = tm.id ) SELECT SUM(salary) AS total_team_salary FROM team_members;
WITH RECURSIVE org_path AS ( SELECT id, name, CAST(name AS STRING) AS path, 0 AS depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, CONCAT(op.path, ' > ', e.name), op.depth + 1 FROM employees e INNER JOIN org_path op ON e.manager_id = op.id ) SELECT name, path FROM org_path WHERE id = 7 ORDER BY depth DESC;
WITH high_salary_threshold AS ( SELECT AVG(salary) * 1.2 AS threshold FROM employees ), RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT s.name, s.salary, s.level FROM subordinates s, high_salary_threshold hst WHERE s.salary >= hst.threshold ORDER BY s.level;
WITH RECURSIVE traversal AS ( SELECT node_from, node_to, ARRAY[node_from] AS path FROM graph WHERE node_from = 1 UNION ALL SELECT g.node_from, g.node_to, ARRAY_APPEND(t.path, g.node_from) FROM graph g INNER JOIN traversal t ON g.node_from = t.node_to WHERE NOT (g.node_from = ANY(t.path)) ) SELECT * FROM traversal;
WITH RECURSIVE bom_explosion AS ( SELECT b.parent_part_id, b.child_part_id, b.quantity_needed, 1 AS level FROM bom b WHERE parent_part_id = 1 UNION ALL SELECT be.parent_part_id, b.child_part_id, be.quantity_needed * b.quantity_needed, be.level + 1 FROM bom b INNER JOIN bom_explosion be ON b.parent_part_id = be.child_part_id WHERE be.level < 10 ) SELECT child_part_id, SUM(quantity_needed) AS total_quantity FROM bom_explosion GROUP BY child_part_id ORDER BY child_part_id;
WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_5927
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_5928
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_5929
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_5930
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_5931
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_5932
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_5933
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_5934
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_5935
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- Base case returns no rows
-- Recursive case will never execute
-- Base case: Start with CEO (manager_id is NULL)
-- Recursive case: Try to find manager (will fail for NULL)
-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS circular;
CREATE TABLE circular (id INT64, next_id INT64);
INSERT INTO circular VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (1, 3), (2, 4), (3, 4);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (1, 3), (2, 4), (3, 4);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 2), (3, 4);
DROP TABLE IF EXISTS parts;
CREATE TABLE parts ( part_id INT64, part_name STRING, quantity INT64 );
DROP TABLE IF EXISTS bom;
CREATE TABLE bom ( parent_part_id INT64, child_part_id INT64, quantity_needed INT64 );
INSERT INTO parts VALUES (1, 'Car', 1), (2, 'Engine', 1), (3, 'Wheel', 4), (4, 'Piston', 4), (5, 'Tire', 1);
INSERT INTO bom VALUES (1, 2, 1), (1, 3, 4), (2, 4, 4), (3, 5, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE empty_cte AS (;
-- Tag: cte_cte_test_select_5936
SELECT id, name FROM employees WHERE id = 999 UNION ALL;
-- Tag: cte_cte_test_select_5937
SELECT e.id, e.name FROM employees e INNER JOIN empty_cte ec ON e.manager_id = ec.id ) SELECT * FROM empty_cte;
WITH RECURSIVE ancestors AS (;
-- Tag: cte_cte_test_select_5938
SELECT id, name, manager_id FROM employees WHERE id = 1 UNION ALL;
-- Tag: cte_cte_test_select_5939
SELECT e.id, e.name, e.manager_id FROM employees e INNER JOIN ancestors a ON e.id = a.manager_id ) SELECT * FROM ancestors;
WITH numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 5 ) SELECT * FROM numbers;
WITH RECURSIVE cycle AS ( SELECT id, next_id FROM circular WHERE id = 1 UNION ALL SELECT c.id, c.next_id FROM circular c INNER JOIN cycle cy ON c.id = cy.next_id ) SELECT * FROM cycle;
WITH RECURSIVE reachable AS ( SELECT node_to AS node FROM graph WHERE node_from = 1 UNION SELECT g.node_to FROM graph g INNER JOIN reachable r ON g.node_from = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE paths AS ( SELECT node_from, node_to, 1 AS depth FROM graph WHERE node_from = 1 UNION ALL SELECT p.node_from, g.node_to, p.depth + 1 FROM graph g INNER JOIN paths p ON g.node_from = p.node_to WHERE p.depth < 3 ) SELECT * FROM paths ORDER BY depth, node_to;
WITH RECURSIVE subordinates AS ( SELECT id, name, manager_id, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, s.depth + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id WHERE s.depth < 2 ) SELECT * FROM subordinates ORDER BY depth, id;
WITH RECURSIVE high_earners AS ( SELECT id, name, salary, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, h.depth + 1 FROM employees e INNER JOIN high_earners h ON e.manager_id = h.id WHERE h.depth < 5 AND e.salary >= 100000 ) SELECT * FROM high_earners ORDER BY depth, id;
WITH RECURSIVE org_levels AS ( SELECT id, 0 AS level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, ol.level + 1 FROM employees e INNER JOIN org_levels ol ON e.manager_id = ol.id ) SELECT level, COUNT(*) AS employee_count FROM org_levels GROUP BY level ORDER BY level;
WITH RECURSIVE team_members AS ( SELECT id, salary FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.salary FROM employees e INNER JOIN team_members tm ON e.manager_id = tm.id ) SELECT SUM(salary) AS total_team_salary FROM team_members;
WITH RECURSIVE org_path AS ( SELECT id, name, CAST(name AS STRING) AS path, 0 AS depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, CONCAT(op.path, ' > ', e.name), op.depth + 1 FROM employees e INNER JOIN org_path op ON e.manager_id = op.id ) SELECT name, path FROM org_path WHERE id = 7 ORDER BY depth DESC;
WITH high_salary_threshold AS ( SELECT AVG(salary) * 1.2 AS threshold FROM employees ), RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT s.name, s.salary, s.level FROM subordinates s, high_salary_threshold hst WHERE s.salary >= hst.threshold ORDER BY s.level;
WITH RECURSIVE traversal AS ( SELECT node_from, node_to, ARRAY[node_from] AS path FROM graph WHERE node_from = 1 UNION ALL SELECT g.node_from, g.node_to, ARRAY_APPEND(t.path, g.node_from) FROM graph g INNER JOIN traversal t ON g.node_from = t.node_to WHERE NOT (g.node_from = ANY(t.path)) ) SELECT * FROM traversal;
WITH RECURSIVE bom_explosion AS ( SELECT b.parent_part_id, b.child_part_id, b.quantity_needed, 1 AS level FROM bom b WHERE parent_part_id = 1 UNION ALL SELECT be.parent_part_id, b.child_part_id, be.quantity_needed * b.quantity_needed, be.level + 1 FROM bom b INNER JOIN bom_explosion be ON b.parent_part_id = be.child_part_id WHERE be.level < 10 ) SELECT child_part_id, SUM(quantity_needed) AS total_quantity FROM bom_explosion GROUP BY child_part_id ORDER BY child_part_id;
WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_5940
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_5941
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_5942
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_5943
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_5944
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_5945
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_5946
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_5947
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_5948
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- Base case: Start with CEO (manager_id is NULL)
-- Recursive case: Try to find manager (will fail for NULL)
-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS circular;
CREATE TABLE circular (id INT64, next_id INT64);
INSERT INTO circular VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (1, 3), (2, 4), (3, 4);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (1, 3), (2, 4), (3, 4);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 2), (3, 4);
DROP TABLE IF EXISTS parts;
CREATE TABLE parts ( part_id INT64, part_name STRING, quantity INT64 );
DROP TABLE IF EXISTS bom;
CREATE TABLE bom ( parent_part_id INT64, child_part_id INT64, quantity_needed INT64 );
INSERT INTO parts VALUES (1, 'Car', 1), (2, 'Engine', 1), (3, 'Wheel', 4), (4, 'Piston', 4), (5, 'Tire', 1);
INSERT INTO bom VALUES (1, 2, 1), (1, 3, 4), (2, 4, 4), (3, 5, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE ancestors AS (;
-- Tag: cte_cte_test_select_5949
SELECT id, name, manager_id FROM employees WHERE id = 1 UNION ALL;
-- Tag: cte_cte_test_select_5950
SELECT e.id, e.name, e.manager_id FROM employees e INNER JOIN ancestors a ON e.id = a.manager_id ) SELECT * FROM ancestors;
WITH numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 5 ) SELECT * FROM numbers;
WITH RECURSIVE cycle AS ( SELECT id, next_id FROM circular WHERE id = 1 UNION ALL SELECT c.id, c.next_id FROM circular c INNER JOIN cycle cy ON c.id = cy.next_id ) SELECT * FROM cycle;
WITH RECURSIVE reachable AS ( SELECT node_to AS node FROM graph WHERE node_from = 1 UNION SELECT g.node_to FROM graph g INNER JOIN reachable r ON g.node_from = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE paths AS ( SELECT node_from, node_to, 1 AS depth FROM graph WHERE node_from = 1 UNION ALL SELECT p.node_from, g.node_to, p.depth + 1 FROM graph g INNER JOIN paths p ON g.node_from = p.node_to WHERE p.depth < 3 ) SELECT * FROM paths ORDER BY depth, node_to;
WITH RECURSIVE subordinates AS ( SELECT id, name, manager_id, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, s.depth + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id WHERE s.depth < 2 ) SELECT * FROM subordinates ORDER BY depth, id;
WITH RECURSIVE high_earners AS ( SELECT id, name, salary, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, h.depth + 1 FROM employees e INNER JOIN high_earners h ON e.manager_id = h.id WHERE h.depth < 5 AND e.salary >= 100000 ) SELECT * FROM high_earners ORDER BY depth, id;
WITH RECURSIVE org_levels AS ( SELECT id, 0 AS level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, ol.level + 1 FROM employees e INNER JOIN org_levels ol ON e.manager_id = ol.id ) SELECT level, COUNT(*) AS employee_count FROM org_levels GROUP BY level ORDER BY level;
WITH RECURSIVE team_members AS ( SELECT id, salary FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.salary FROM employees e INNER JOIN team_members tm ON e.manager_id = tm.id ) SELECT SUM(salary) AS total_team_salary FROM team_members;
WITH RECURSIVE org_path AS ( SELECT id, name, CAST(name AS STRING) AS path, 0 AS depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, CONCAT(op.path, ' > ', e.name), op.depth + 1 FROM employees e INNER JOIN org_path op ON e.manager_id = op.id ) SELECT name, path FROM org_path WHERE id = 7 ORDER BY depth DESC;
WITH high_salary_threshold AS ( SELECT AVG(salary) * 1.2 AS threshold FROM employees ), RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT s.name, s.salary, s.level FROM subordinates s, high_salary_threshold hst WHERE s.salary >= hst.threshold ORDER BY s.level;
WITH RECURSIVE traversal AS ( SELECT node_from, node_to, ARRAY[node_from] AS path FROM graph WHERE node_from = 1 UNION ALL SELECT g.node_from, g.node_to, ARRAY_APPEND(t.path, g.node_from) FROM graph g INNER JOIN traversal t ON g.node_from = t.node_to WHERE NOT (g.node_from = ANY(t.path)) ) SELECT * FROM traversal;
WITH RECURSIVE bom_explosion AS ( SELECT b.parent_part_id, b.child_part_id, b.quantity_needed, 1 AS level FROM bom b WHERE parent_part_id = 1 UNION ALL SELECT be.parent_part_id, b.child_part_id, be.quantity_needed * b.quantity_needed, be.level + 1 FROM bom b INNER JOIN bom_explosion be ON b.parent_part_id = be.child_part_id WHERE be.level < 10 ) SELECT child_part_id, SUM(quantity_needed) AS total_quantity FROM bom_explosion GROUP BY child_part_id ORDER BY child_part_id;
WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_5951
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_5952
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_5953
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_5954
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_5955
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_5956
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_5957
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_5958
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_5959
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS circular;
CREATE TABLE circular (id INT64, next_id INT64);
INSERT INTO circular VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (1, 3), (2, 4), (3, 4);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (1, 3), (2, 4), (3, 4);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 2), (3, 4);
DROP TABLE IF EXISTS parts;
CREATE TABLE parts ( part_id INT64, part_name STRING, quantity INT64 );
DROP TABLE IF EXISTS bom;
CREATE TABLE bom ( parent_part_id INT64, child_part_id INT64, quantity_needed INT64 );
INSERT INTO parts VALUES (1, 'Car', 1), (2, 'Engine', 1), (3, 'Wheel', 4), (4, 'Piston', 4), (5, 'Tire', 1);
INSERT INTO bom VALUES (1, 2, 1), (1, 3, 4), (2, 4, 4), (3, 5, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 5 ) SELECT * FROM numbers;
WITH RECURSIVE cycle AS ( SELECT id, next_id FROM circular WHERE id = 1 UNION ALL SELECT c.id, c.next_id FROM circular c INNER JOIN cycle cy ON c.id = cy.next_id ) SELECT * FROM cycle;
WITH RECURSIVE reachable AS ( SELECT node_to AS node FROM graph WHERE node_from = 1 UNION SELECT g.node_to FROM graph g INNER JOIN reachable r ON g.node_from = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE paths AS ( SELECT node_from, node_to, 1 AS depth FROM graph WHERE node_from = 1 UNION ALL SELECT p.node_from, g.node_to, p.depth + 1 FROM graph g INNER JOIN paths p ON g.node_from = p.node_to WHERE p.depth < 3 ) SELECT * FROM paths ORDER BY depth, node_to;
WITH RECURSIVE subordinates AS ( SELECT id, name, manager_id, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, s.depth + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id WHERE s.depth < 2 ) SELECT * FROM subordinates ORDER BY depth, id;
WITH RECURSIVE high_earners AS ( SELECT id, name, salary, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, h.depth + 1 FROM employees e INNER JOIN high_earners h ON e.manager_id = h.id WHERE h.depth < 5 AND e.salary >= 100000 ) SELECT * FROM high_earners ORDER BY depth, id;
WITH RECURSIVE org_levels AS ( SELECT id, 0 AS level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, ol.level + 1 FROM employees e INNER JOIN org_levels ol ON e.manager_id = ol.id ) SELECT level, COUNT(*) AS employee_count FROM org_levels GROUP BY level ORDER BY level;
WITH RECURSIVE team_members AS ( SELECT id, salary FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.salary FROM employees e INNER JOIN team_members tm ON e.manager_id = tm.id ) SELECT SUM(salary) AS total_team_salary FROM team_members;
WITH RECURSIVE org_path AS ( SELECT id, name, CAST(name AS STRING) AS path, 0 AS depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, CONCAT(op.path, ' > ', e.name), op.depth + 1 FROM employees e INNER JOIN org_path op ON e.manager_id = op.id ) SELECT name, path FROM org_path WHERE id = 7 ORDER BY depth DESC;
WITH high_salary_threshold AS ( SELECT AVG(salary) * 1.2 AS threshold FROM employees ), RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT s.name, s.salary, s.level FROM subordinates s, high_salary_threshold hst WHERE s.salary >= hst.threshold ORDER BY s.level;
WITH RECURSIVE traversal AS ( SELECT node_from, node_to, ARRAY[node_from] AS path FROM graph WHERE node_from = 1 UNION ALL SELECT g.node_from, g.node_to, ARRAY_APPEND(t.path, g.node_from) FROM graph g INNER JOIN traversal t ON g.node_from = t.node_to WHERE NOT (g.node_from = ANY(t.path)) ) SELECT * FROM traversal;
WITH RECURSIVE bom_explosion AS ( SELECT b.parent_part_id, b.child_part_id, b.quantity_needed, 1 AS level FROM bom b WHERE parent_part_id = 1 UNION ALL SELECT be.parent_part_id, b.child_part_id, be.quantity_needed * b.quantity_needed, be.level + 1 FROM bom b INNER JOIN bom_explosion be ON b.parent_part_id = be.child_part_id WHERE be.level < 10 ) SELECT child_part_id, SUM(quantity_needed) AS total_quantity FROM bom_explosion GROUP BY child_part_id ORDER BY child_part_id;
WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_5960
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_5961
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_5962
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_5963
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_5964
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_5965
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_5966
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_5967
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_5968
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS circular;
CREATE TABLE circular (id INT64, next_id INT64);
INSERT INTO circular VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (1, 3), (2, 4), (3, 4);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (1, 3), (2, 4), (3, 4);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 2), (3, 4);
DROP TABLE IF EXISTS parts;
CREATE TABLE parts ( part_id INT64, part_name STRING, quantity INT64 );
DROP TABLE IF EXISTS bom;
CREATE TABLE bom ( parent_part_id INT64, child_part_id INT64, quantity_needed INT64 );
INSERT INTO parts VALUES (1, 'Car', 1), (2, 'Engine', 1), (3, 'Wheel', 4), (4, 'Piston', 4), (5, 'Tire', 1);
INSERT INTO bom VALUES (1, 2, 1), (1, 3, 4), (2, 4, 4), (3, 5, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE cycle AS ( SELECT id, next_id FROM circular WHERE id = 1 UNION ALL SELECT c.id, c.next_id FROM circular c INNER JOIN cycle cy ON c.id = cy.next_id ) SELECT * FROM cycle;
WITH RECURSIVE reachable AS ( SELECT node_to AS node FROM graph WHERE node_from = 1 UNION SELECT g.node_to FROM graph g INNER JOIN reachable r ON g.node_from = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE paths AS ( SELECT node_from, node_to, 1 AS depth FROM graph WHERE node_from = 1 UNION ALL SELECT p.node_from, g.node_to, p.depth + 1 FROM graph g INNER JOIN paths p ON g.node_from = p.node_to WHERE p.depth < 3 ) SELECT * FROM paths ORDER BY depth, node_to;
WITH RECURSIVE subordinates AS ( SELECT id, name, manager_id, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, s.depth + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id WHERE s.depth < 2 ) SELECT * FROM subordinates ORDER BY depth, id;
WITH RECURSIVE high_earners AS ( SELECT id, name, salary, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, h.depth + 1 FROM employees e INNER JOIN high_earners h ON e.manager_id = h.id WHERE h.depth < 5 AND e.salary >= 100000 ) SELECT * FROM high_earners ORDER BY depth, id;
WITH RECURSIVE org_levels AS ( SELECT id, 0 AS level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, ol.level + 1 FROM employees e INNER JOIN org_levels ol ON e.manager_id = ol.id ) SELECT level, COUNT(*) AS employee_count FROM org_levels GROUP BY level ORDER BY level;
WITH RECURSIVE team_members AS ( SELECT id, salary FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.salary FROM employees e INNER JOIN team_members tm ON e.manager_id = tm.id ) SELECT SUM(salary) AS total_team_salary FROM team_members;
WITH RECURSIVE org_path AS ( SELECT id, name, CAST(name AS STRING) AS path, 0 AS depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, CONCAT(op.path, ' > ', e.name), op.depth + 1 FROM employees e INNER JOIN org_path op ON e.manager_id = op.id ) SELECT name, path FROM org_path WHERE id = 7 ORDER BY depth DESC;
WITH high_salary_threshold AS ( SELECT AVG(salary) * 1.2 AS threshold FROM employees ), RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT s.name, s.salary, s.level FROM subordinates s, high_salary_threshold hst WHERE s.salary >= hst.threshold ORDER BY s.level;
WITH RECURSIVE traversal AS ( SELECT node_from, node_to, ARRAY[node_from] AS path FROM graph WHERE node_from = 1 UNION ALL SELECT g.node_from, g.node_to, ARRAY_APPEND(t.path, g.node_from) FROM graph g INNER JOIN traversal t ON g.node_from = t.node_to WHERE NOT (g.node_from = ANY(t.path)) ) SELECT * FROM traversal;
WITH RECURSIVE bom_explosion AS ( SELECT b.parent_part_id, b.child_part_id, b.quantity_needed, 1 AS level FROM bom b WHERE parent_part_id = 1 UNION ALL SELECT be.parent_part_id, b.child_part_id, be.quantity_needed * b.quantity_needed, be.level + 1 FROM bom b INNER JOIN bom_explosion be ON b.parent_part_id = be.child_part_id WHERE be.level < 10 ) SELECT child_part_id, SUM(quantity_needed) AS total_quantity FROM bom_explosion GROUP BY child_part_id ORDER BY child_part_id;
WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_5969
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_5970
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_5971
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_5972
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_5973
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_5974
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_5975
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_5976
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_5977
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (1, 3), (2, 4), (3, 4);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (1, 3), (2, 4), (3, 4);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 2), (3, 4);
DROP TABLE IF EXISTS parts;
CREATE TABLE parts ( part_id INT64, part_name STRING, quantity INT64 );
DROP TABLE IF EXISTS bom;
CREATE TABLE bom ( parent_part_id INT64, child_part_id INT64, quantity_needed INT64 );
INSERT INTO parts VALUES (1, 'Car', 1), (2, 'Engine', 1), (3, 'Wheel', 4), (4, 'Piston', 4), (5, 'Tire', 1);
INSERT INTO bom VALUES (1, 2, 1), (1, 3, 4), (2, 4, 4), (3, 5, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE reachable AS ( SELECT node_to AS node FROM graph WHERE node_from = 1 UNION SELECT g.node_to FROM graph g INNER JOIN reachable r ON g.node_from = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE paths AS ( SELECT node_from, node_to, 1 AS depth FROM graph WHERE node_from = 1 UNION ALL SELECT p.node_from, g.node_to, p.depth + 1 FROM graph g INNER JOIN paths p ON g.node_from = p.node_to WHERE p.depth < 3 ) SELECT * FROM paths ORDER BY depth, node_to;
WITH RECURSIVE subordinates AS ( SELECT id, name, manager_id, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, s.depth + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id WHERE s.depth < 2 ) SELECT * FROM subordinates ORDER BY depth, id;
WITH RECURSIVE high_earners AS ( SELECT id, name, salary, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, h.depth + 1 FROM employees e INNER JOIN high_earners h ON e.manager_id = h.id WHERE h.depth < 5 AND e.salary >= 100000 ) SELECT * FROM high_earners ORDER BY depth, id;
WITH RECURSIVE org_levels AS ( SELECT id, 0 AS level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, ol.level + 1 FROM employees e INNER JOIN org_levels ol ON e.manager_id = ol.id ) SELECT level, COUNT(*) AS employee_count FROM org_levels GROUP BY level ORDER BY level;
WITH RECURSIVE team_members AS ( SELECT id, salary FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.salary FROM employees e INNER JOIN team_members tm ON e.manager_id = tm.id ) SELECT SUM(salary) AS total_team_salary FROM team_members;
WITH RECURSIVE org_path AS ( SELECT id, name, CAST(name AS STRING) AS path, 0 AS depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, CONCAT(op.path, ' > ', e.name), op.depth + 1 FROM employees e INNER JOIN org_path op ON e.manager_id = op.id ) SELECT name, path FROM org_path WHERE id = 7 ORDER BY depth DESC;
WITH high_salary_threshold AS ( SELECT AVG(salary) * 1.2 AS threshold FROM employees ), RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT s.name, s.salary, s.level FROM subordinates s, high_salary_threshold hst WHERE s.salary >= hst.threshold ORDER BY s.level;
WITH RECURSIVE traversal AS ( SELECT node_from, node_to, ARRAY[node_from] AS path FROM graph WHERE node_from = 1 UNION ALL SELECT g.node_from, g.node_to, ARRAY_APPEND(t.path, g.node_from) FROM graph g INNER JOIN traversal t ON g.node_from = t.node_to WHERE NOT (g.node_from = ANY(t.path)) ) SELECT * FROM traversal;
WITH RECURSIVE bom_explosion AS ( SELECT b.parent_part_id, b.child_part_id, b.quantity_needed, 1 AS level FROM bom b WHERE parent_part_id = 1 UNION ALL SELECT be.parent_part_id, b.child_part_id, be.quantity_needed * b.quantity_needed, be.level + 1 FROM bom b INNER JOIN bom_explosion be ON b.parent_part_id = be.child_part_id WHERE be.level < 10 ) SELECT child_part_id, SUM(quantity_needed) AS total_quantity FROM bom_explosion GROUP BY child_part_id ORDER BY child_part_id;
WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_5978
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_5979
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_5980
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_5981
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_5982
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_5983
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_5984
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_5985
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_5986
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (1, 3), (2, 4), (3, 4);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 2), (3, 4);
DROP TABLE IF EXISTS parts;
CREATE TABLE parts ( part_id INT64, part_name STRING, quantity INT64 );
DROP TABLE IF EXISTS bom;
CREATE TABLE bom ( parent_part_id INT64, child_part_id INT64, quantity_needed INT64 );
INSERT INTO parts VALUES (1, 'Car', 1), (2, 'Engine', 1), (3, 'Wheel', 4), (4, 'Piston', 4), (5, 'Tire', 1);
INSERT INTO bom VALUES (1, 2, 1), (1, 3, 4), (2, 4, 4), (3, 5, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE paths AS ( SELECT node_from, node_to, 1 AS depth FROM graph WHERE node_from = 1 UNION ALL SELECT p.node_from, g.node_to, p.depth + 1 FROM graph g INNER JOIN paths p ON g.node_from = p.node_to WHERE p.depth < 3 ) SELECT * FROM paths ORDER BY depth, node_to;
WITH RECURSIVE subordinates AS ( SELECT id, name, manager_id, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, s.depth + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id WHERE s.depth < 2 ) SELECT * FROM subordinates ORDER BY depth, id;
WITH RECURSIVE high_earners AS ( SELECT id, name, salary, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, h.depth + 1 FROM employees e INNER JOIN high_earners h ON e.manager_id = h.id WHERE h.depth < 5 AND e.salary >= 100000 ) SELECT * FROM high_earners ORDER BY depth, id;
WITH RECURSIVE org_levels AS ( SELECT id, 0 AS level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, ol.level + 1 FROM employees e INNER JOIN org_levels ol ON e.manager_id = ol.id ) SELECT level, COUNT(*) AS employee_count FROM org_levels GROUP BY level ORDER BY level;
WITH RECURSIVE team_members AS ( SELECT id, salary FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.salary FROM employees e INNER JOIN team_members tm ON e.manager_id = tm.id ) SELECT SUM(salary) AS total_team_salary FROM team_members;
WITH RECURSIVE org_path AS ( SELECT id, name, CAST(name AS STRING) AS path, 0 AS depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, CONCAT(op.path, ' > ', e.name), op.depth + 1 FROM employees e INNER JOIN org_path op ON e.manager_id = op.id ) SELECT name, path FROM org_path WHERE id = 7 ORDER BY depth DESC;
WITH high_salary_threshold AS ( SELECT AVG(salary) * 1.2 AS threshold FROM employees ), RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT s.name, s.salary, s.level FROM subordinates s, high_salary_threshold hst WHERE s.salary >= hst.threshold ORDER BY s.level;
WITH RECURSIVE traversal AS ( SELECT node_from, node_to, ARRAY[node_from] AS path FROM graph WHERE node_from = 1 UNION ALL SELECT g.node_from, g.node_to, ARRAY_APPEND(t.path, g.node_from) FROM graph g INNER JOIN traversal t ON g.node_from = t.node_to WHERE NOT (g.node_from = ANY(t.path)) ) SELECT * FROM traversal;
WITH RECURSIVE bom_explosion AS ( SELECT b.parent_part_id, b.child_part_id, b.quantity_needed, 1 AS level FROM bom b WHERE parent_part_id = 1 UNION ALL SELECT be.parent_part_id, b.child_part_id, be.quantity_needed * b.quantity_needed, be.level + 1 FROM bom b INNER JOIN bom_explosion be ON b.parent_part_id = be.child_part_id WHERE be.level < 10 ) SELECT child_part_id, SUM(quantity_needed) AS total_quantity FROM bom_explosion GROUP BY child_part_id ORDER BY child_part_id;
WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_5987
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_5988
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_5989
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_5990
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_5991
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_5992
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_5993
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_5994
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_5995
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 2), (3, 4);
DROP TABLE IF EXISTS parts;
CREATE TABLE parts ( part_id INT64, part_name STRING, quantity INT64 );
DROP TABLE IF EXISTS bom;
CREATE TABLE bom ( parent_part_id INT64, child_part_id INT64, quantity_needed INT64 );
INSERT INTO parts VALUES (1, 'Car', 1), (2, 'Engine', 1), (3, 'Wheel', 4), (4, 'Piston', 4), (5, 'Tire', 1);
INSERT INTO bom VALUES (1, 2, 1), (1, 3, 4), (2, 4, 4), (3, 5, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE subordinates AS ( SELECT id, name, manager_id, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, s.depth + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id WHERE s.depth < 2 ) SELECT * FROM subordinates ORDER BY depth, id;
WITH RECURSIVE high_earners AS ( SELECT id, name, salary, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, h.depth + 1 FROM employees e INNER JOIN high_earners h ON e.manager_id = h.id WHERE h.depth < 5 AND e.salary >= 100000 ) SELECT * FROM high_earners ORDER BY depth, id;
WITH RECURSIVE org_levels AS ( SELECT id, 0 AS level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, ol.level + 1 FROM employees e INNER JOIN org_levels ol ON e.manager_id = ol.id ) SELECT level, COUNT(*) AS employee_count FROM org_levels GROUP BY level ORDER BY level;
WITH RECURSIVE team_members AS ( SELECT id, salary FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.salary FROM employees e INNER JOIN team_members tm ON e.manager_id = tm.id ) SELECT SUM(salary) AS total_team_salary FROM team_members;
WITH RECURSIVE org_path AS ( SELECT id, name, CAST(name AS STRING) AS path, 0 AS depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, CONCAT(op.path, ' > ', e.name), op.depth + 1 FROM employees e INNER JOIN org_path op ON e.manager_id = op.id ) SELECT name, path FROM org_path WHERE id = 7 ORDER BY depth DESC;
WITH high_salary_threshold AS ( SELECT AVG(salary) * 1.2 AS threshold FROM employees ), RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT s.name, s.salary, s.level FROM subordinates s, high_salary_threshold hst WHERE s.salary >= hst.threshold ORDER BY s.level;
WITH RECURSIVE traversal AS ( SELECT node_from, node_to, ARRAY[node_from] AS path FROM graph WHERE node_from = 1 UNION ALL SELECT g.node_from, g.node_to, ARRAY_APPEND(t.path, g.node_from) FROM graph g INNER JOIN traversal t ON g.node_from = t.node_to WHERE NOT (g.node_from = ANY(t.path)) ) SELECT * FROM traversal;
WITH RECURSIVE bom_explosion AS ( SELECT b.parent_part_id, b.child_part_id, b.quantity_needed, 1 AS level FROM bom b WHERE parent_part_id = 1 UNION ALL SELECT be.parent_part_id, b.child_part_id, be.quantity_needed * b.quantity_needed, be.level + 1 FROM bom b INNER JOIN bom_explosion be ON b.parent_part_id = be.child_part_id WHERE be.level < 10 ) SELECT child_part_id, SUM(quantity_needed) AS total_quantity FROM bom_explosion GROUP BY child_part_id ORDER BY child_part_id;
WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_5996
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_5997
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_5998
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_5999
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6000
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6001
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6002
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6003
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6004
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 2), (3, 4);
DROP TABLE IF EXISTS parts;
CREATE TABLE parts ( part_id INT64, part_name STRING, quantity INT64 );
DROP TABLE IF EXISTS bom;
CREATE TABLE bom ( parent_part_id INT64, child_part_id INT64, quantity_needed INT64 );
INSERT INTO parts VALUES (1, 'Car', 1), (2, 'Engine', 1), (3, 'Wheel', 4), (4, 'Piston', 4), (5, 'Tire', 1);
INSERT INTO bom VALUES (1, 2, 1), (1, 3, 4), (2, 4, 4), (3, 5, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE high_earners AS ( SELECT id, name, salary, 0 AS depth FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, h.depth + 1 FROM employees e INNER JOIN high_earners h ON e.manager_id = h.id WHERE h.depth < 5 AND e.salary >= 100000 ) SELECT * FROM high_earners ORDER BY depth, id;
WITH RECURSIVE org_levels AS ( SELECT id, 0 AS level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, ol.level + 1 FROM employees e INNER JOIN org_levels ol ON e.manager_id = ol.id ) SELECT level, COUNT(*) AS employee_count FROM org_levels GROUP BY level ORDER BY level;
WITH RECURSIVE team_members AS ( SELECT id, salary FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.salary FROM employees e INNER JOIN team_members tm ON e.manager_id = tm.id ) SELECT SUM(salary) AS total_team_salary FROM team_members;
WITH RECURSIVE org_path AS ( SELECT id, name, CAST(name AS STRING) AS path, 0 AS depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, CONCAT(op.path, ' > ', e.name), op.depth + 1 FROM employees e INNER JOIN org_path op ON e.manager_id = op.id ) SELECT name, path FROM org_path WHERE id = 7 ORDER BY depth DESC;
WITH high_salary_threshold AS ( SELECT AVG(salary) * 1.2 AS threshold FROM employees ), RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT s.name, s.salary, s.level FROM subordinates s, high_salary_threshold hst WHERE s.salary >= hst.threshold ORDER BY s.level;
WITH RECURSIVE traversal AS ( SELECT node_from, node_to, ARRAY[node_from] AS path FROM graph WHERE node_from = 1 UNION ALL SELECT g.node_from, g.node_to, ARRAY_APPEND(t.path, g.node_from) FROM graph g INNER JOIN traversal t ON g.node_from = t.node_to WHERE NOT (g.node_from = ANY(t.path)) ) SELECT * FROM traversal;
WITH RECURSIVE bom_explosion AS ( SELECT b.parent_part_id, b.child_part_id, b.quantity_needed, 1 AS level FROM bom b WHERE parent_part_id = 1 UNION ALL SELECT be.parent_part_id, b.child_part_id, be.quantity_needed * b.quantity_needed, be.level + 1 FROM bom b INNER JOIN bom_explosion be ON b.parent_part_id = be.child_part_id WHERE be.level < 10 ) SELECT child_part_id, SUM(quantity_needed) AS total_quantity FROM bom_explosion GROUP BY child_part_id ORDER BY child_part_id;
WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_6005
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6006
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6007
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6008
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6009
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6010
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6011
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6012
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6013
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 2), (3, 4);
DROP TABLE IF EXISTS parts;
CREATE TABLE parts ( part_id INT64, part_name STRING, quantity INT64 );
DROP TABLE IF EXISTS bom;
CREATE TABLE bom ( parent_part_id INT64, child_part_id INT64, quantity_needed INT64 );
INSERT INTO parts VALUES (1, 'Car', 1), (2, 'Engine', 1), (3, 'Wheel', 4), (4, 'Piston', 4), (5, 'Tire', 1);
INSERT INTO bom VALUES (1, 2, 1), (1, 3, 4), (2, 4, 4), (3, 5, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE org_levels AS ( SELECT id, 0 AS level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, ol.level + 1 FROM employees e INNER JOIN org_levels ol ON e.manager_id = ol.id ) SELECT level, COUNT(*) AS employee_count FROM org_levels GROUP BY level ORDER BY level;
WITH RECURSIVE team_members AS ( SELECT id, salary FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.salary FROM employees e INNER JOIN team_members tm ON e.manager_id = tm.id ) SELECT SUM(salary) AS total_team_salary FROM team_members;
WITH RECURSIVE org_path AS ( SELECT id, name, CAST(name AS STRING) AS path, 0 AS depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, CONCAT(op.path, ' > ', e.name), op.depth + 1 FROM employees e INNER JOIN org_path op ON e.manager_id = op.id ) SELECT name, path FROM org_path WHERE id = 7 ORDER BY depth DESC;
WITH high_salary_threshold AS ( SELECT AVG(salary) * 1.2 AS threshold FROM employees ), RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT s.name, s.salary, s.level FROM subordinates s, high_salary_threshold hst WHERE s.salary >= hst.threshold ORDER BY s.level;
WITH RECURSIVE traversal AS ( SELECT node_from, node_to, ARRAY[node_from] AS path FROM graph WHERE node_from = 1 UNION ALL SELECT g.node_from, g.node_to, ARRAY_APPEND(t.path, g.node_from) FROM graph g INNER JOIN traversal t ON g.node_from = t.node_to WHERE NOT (g.node_from = ANY(t.path)) ) SELECT * FROM traversal;
WITH RECURSIVE bom_explosion AS ( SELECT b.parent_part_id, b.child_part_id, b.quantity_needed, 1 AS level FROM bom b WHERE parent_part_id = 1 UNION ALL SELECT be.parent_part_id, b.child_part_id, be.quantity_needed * b.quantity_needed, be.level + 1 FROM bom b INNER JOIN bom_explosion be ON b.parent_part_id = be.child_part_id WHERE be.level < 10 ) SELECT child_part_id, SUM(quantity_needed) AS total_quantity FROM bom_explosion GROUP BY child_part_id ORDER BY child_part_id;
WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_6014
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6015
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6016
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6017
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6018
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6019
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6020
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6021
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6022
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 2), (3, 4);
DROP TABLE IF EXISTS parts;
CREATE TABLE parts ( part_id INT64, part_name STRING, quantity INT64 );
DROP TABLE IF EXISTS bom;
CREATE TABLE bom ( parent_part_id INT64, child_part_id INT64, quantity_needed INT64 );
INSERT INTO parts VALUES (1, 'Car', 1), (2, 'Engine', 1), (3, 'Wheel', 4), (4, 'Piston', 4), (5, 'Tire', 1);
INSERT INTO bom VALUES (1, 2, 1), (1, 3, 4), (2, 4, 4), (3, 5, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE team_members AS ( SELECT id, salary FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.salary FROM employees e INNER JOIN team_members tm ON e.manager_id = tm.id ) SELECT SUM(salary) AS total_team_salary FROM team_members;
WITH RECURSIVE org_path AS ( SELECT id, name, CAST(name AS STRING) AS path, 0 AS depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, CONCAT(op.path, ' > ', e.name), op.depth + 1 FROM employees e INNER JOIN org_path op ON e.manager_id = op.id ) SELECT name, path FROM org_path WHERE id = 7 ORDER BY depth DESC;
WITH high_salary_threshold AS ( SELECT AVG(salary) * 1.2 AS threshold FROM employees ), RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT s.name, s.salary, s.level FROM subordinates s, high_salary_threshold hst WHERE s.salary >= hst.threshold ORDER BY s.level;
WITH RECURSIVE traversal AS ( SELECT node_from, node_to, ARRAY[node_from] AS path FROM graph WHERE node_from = 1 UNION ALL SELECT g.node_from, g.node_to, ARRAY_APPEND(t.path, g.node_from) FROM graph g INNER JOIN traversal t ON g.node_from = t.node_to WHERE NOT (g.node_from = ANY(t.path)) ) SELECT * FROM traversal;
WITH RECURSIVE bom_explosion AS ( SELECT b.parent_part_id, b.child_part_id, b.quantity_needed, 1 AS level FROM bom b WHERE parent_part_id = 1 UNION ALL SELECT be.parent_part_id, b.child_part_id, be.quantity_needed * b.quantity_needed, be.level + 1 FROM bom b INNER JOIN bom_explosion be ON b.parent_part_id = be.child_part_id WHERE be.level < 10 ) SELECT child_part_id, SUM(quantity_needed) AS total_quantity FROM bom_explosion GROUP BY child_part_id ORDER BY child_part_id;
WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_6023
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6024
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6025
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6026
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6027
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6028
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6029
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6030
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6031
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 2), (3, 4);
DROP TABLE IF EXISTS parts;
CREATE TABLE parts ( part_id INT64, part_name STRING, quantity INT64 );
DROP TABLE IF EXISTS bom;
CREATE TABLE bom ( parent_part_id INT64, child_part_id INT64, quantity_needed INT64 );
INSERT INTO parts VALUES (1, 'Car', 1), (2, 'Engine', 1), (3, 'Wheel', 4), (4, 'Piston', 4), (5, 'Tire', 1);
INSERT INTO bom VALUES (1, 2, 1), (1, 3, 4), (2, 4, 4), (3, 5, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE org_path AS ( SELECT id, name, CAST(name AS STRING) AS path, 0 AS depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, CONCAT(op.path, ' > ', e.name), op.depth + 1 FROM employees e INNER JOIN org_path op ON e.manager_id = op.id ) SELECT name, path FROM org_path WHERE id = 7 ORDER BY depth DESC;
WITH high_salary_threshold AS ( SELECT AVG(salary) * 1.2 AS threshold FROM employees ), RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT s.name, s.salary, s.level FROM subordinates s, high_salary_threshold hst WHERE s.salary >= hst.threshold ORDER BY s.level;
WITH RECURSIVE traversal AS ( SELECT node_from, node_to, ARRAY[node_from] AS path FROM graph WHERE node_from = 1 UNION ALL SELECT g.node_from, g.node_to, ARRAY_APPEND(t.path, g.node_from) FROM graph g INNER JOIN traversal t ON g.node_from = t.node_to WHERE NOT (g.node_from = ANY(t.path)) ) SELECT * FROM traversal;
WITH RECURSIVE bom_explosion AS ( SELECT b.parent_part_id, b.child_part_id, b.quantity_needed, 1 AS level FROM bom b WHERE parent_part_id = 1 UNION ALL SELECT be.parent_part_id, b.child_part_id, be.quantity_needed * b.quantity_needed, be.level + 1 FROM bom b INNER JOIN bom_explosion be ON b.parent_part_id = be.child_part_id WHERE be.level < 10 ) SELECT child_part_id, SUM(quantity_needed) AS total_quantity FROM bom_explosion GROUP BY child_part_id ORDER BY child_part_id;
WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_6032
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6033
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6034
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6035
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6036
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6037
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6038
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6039
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6040
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 2), (3, 4);
DROP TABLE IF EXISTS parts;
CREATE TABLE parts ( part_id INT64, part_name STRING, quantity INT64 );
DROP TABLE IF EXISTS bom;
CREATE TABLE bom ( parent_part_id INT64, child_part_id INT64, quantity_needed INT64 );
INSERT INTO parts VALUES (1, 'Car', 1), (2, 'Engine', 1), (3, 'Wheel', 4), (4, 'Piston', 4), (5, 'Tire', 1);
INSERT INTO bom VALUES (1, 2, 1), (1, 3, 4), (2, 4, 4), (3, 5, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH high_salary_threshold AS ( SELECT AVG(salary) * 1.2 AS threshold FROM employees ), RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT s.name, s.salary, s.level FROM subordinates s, high_salary_threshold hst WHERE s.salary >= hst.threshold ORDER BY s.level;
WITH RECURSIVE traversal AS ( SELECT node_from, node_to, ARRAY[node_from] AS path FROM graph WHERE node_from = 1 UNION ALL SELECT g.node_from, g.node_to, ARRAY_APPEND(t.path, g.node_from) FROM graph g INNER JOIN traversal t ON g.node_from = t.node_to WHERE NOT (g.node_from = ANY(t.path)) ) SELECT * FROM traversal;
WITH RECURSIVE bom_explosion AS ( SELECT b.parent_part_id, b.child_part_id, b.quantity_needed, 1 AS level FROM bom b WHERE parent_part_id = 1 UNION ALL SELECT be.parent_part_id, b.child_part_id, be.quantity_needed * b.quantity_needed, be.level + 1 FROM bom b INNER JOIN bom_explosion be ON b.parent_part_id = be.child_part_id WHERE be.level < 10 ) SELECT child_part_id, SUM(quantity_needed) AS total_quantity FROM bom_explosion GROUP BY child_part_id ORDER BY child_part_id;
WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_6041
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6042
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6043
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6044
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6045
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6046
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6047
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6048
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6049
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (node_from INT64, node_to INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 2), (3, 4);
DROP TABLE IF EXISTS parts;
CREATE TABLE parts ( part_id INT64, part_name STRING, quantity INT64 );
DROP TABLE IF EXISTS bom;
CREATE TABLE bom ( parent_part_id INT64, child_part_id INT64, quantity_needed INT64 );
INSERT INTO parts VALUES (1, 'Car', 1), (2, 'Engine', 1), (3, 'Wheel', 4), (4, 'Piston', 4), (5, 'Tire', 1);
INSERT INTO bom VALUES (1, 2, 1), (1, 3, 4), (2, 4, 4), (3, 5, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE traversal AS ( SELECT node_from, node_to, ARRAY[node_from] AS path FROM graph WHERE node_from = 1 UNION ALL SELECT g.node_from, g.node_to, ARRAY_APPEND(t.path, g.node_from) FROM graph g INNER JOIN traversal t ON g.node_from = t.node_to WHERE NOT (g.node_from = ANY(t.path)) ) SELECT * FROM traversal;
WITH RECURSIVE bom_explosion AS ( SELECT b.parent_part_id, b.child_part_id, b.quantity_needed, 1 AS level FROM bom b WHERE parent_part_id = 1 UNION ALL SELECT be.parent_part_id, b.child_part_id, be.quantity_needed * b.quantity_needed, be.level + 1 FROM bom b INNER JOIN bom_explosion be ON b.parent_part_id = be.child_part_id WHERE be.level < 10 ) SELECT child_part_id, SUM(quantity_needed) AS total_quantity FROM bom_explosion GROUP BY child_part_id ORDER BY child_part_id;
WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_6050
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6051
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6052
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6053
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6054
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6055
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6056
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6057
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6058
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS parts;
CREATE TABLE parts ( part_id INT64, part_name STRING, quantity INT64 );
DROP TABLE IF EXISTS bom;
CREATE TABLE bom ( parent_part_id INT64, child_part_id INT64, quantity_needed INT64 );
INSERT INTO parts VALUES (1, 'Car', 1), (2, 'Engine', 1), (3, 'Wheel', 4), (4, 'Piston', 4), (5, 'Tire', 1);
INSERT INTO bom VALUES (1, 2, 1), (1, 3, 4), (2, 4, 4), (3, 5, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE bom_explosion AS ( SELECT b.parent_part_id, b.child_part_id, b.quantity_needed, 1 AS level FROM bom b WHERE parent_part_id = 1 UNION ALL SELECT be.parent_part_id, b.child_part_id, be.quantity_needed * b.quantity_needed, be.level + 1 FROM bom b INNER JOIN bom_explosion be ON b.parent_part_id = be.child_part_id WHERE be.level < 10 ) SELECT child_part_id, SUM(quantity_needed) AS total_quantity FROM bom_explosion GROUP BY child_part_id ORDER BY child_part_id;
WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_6059
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6060
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6061
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6062
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6063
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6064
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6065
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6066
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6067
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (from_node INT64, to_node INT64, cost INT64);
INSERT INTO edges VALUES (1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 7), (3, 4, 3);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE paths AS ( SELECT from_node, to_node, cost, ARRAY[from_node, to_node] AS path FROM edges WHERE from_node = 1 UNION ALL SELECT p.from_node, e.to_node, p.cost + e.cost, ARRAY_APPEND(p.path, e.to_node) FROM edges e INNER JOIN paths p ON e.from_node = p.to_node WHERE NOT (e.to_node = ANY(p.path)) AND p.cost + e.cost < 100 ) SELECT to_node, MIN(cost) AS min_cost FROM paths WHERE to_node = 4 GROUP BY to_node;
WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_6068
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6069
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6070
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6071
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6072
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6073
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6074
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6075
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6076
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (from_node INT64, to_node INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (1, 4), (4, 3);
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE transitive AS ( SELECT from_node, to_node FROM graph UNION SELECT t1.from_node, t2.to_node FROM transitive t1 INNER JOIN transitive t2 ON t1.to_node = t2.from_node ) SELECT from_node, to_node FROM transitive WHERE from_node = 1 ORDER BY to_node;
WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_6077
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6078
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6079
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6080
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6081
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6082
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6083
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6084
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6085
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE subordinates AS ( SELECT id, name, salary, 0 AS level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.salary, s.level + 1 FROM employees e INNER JOIN subordinates s ON e.manager_id = s.id ) SELECT name, salary, level FROM subordinates WHERE level >= 2 AND salary >= 100000 ORDER BY level, salary DESC;
WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_6086
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6087
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6088
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6089
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6090
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6091
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6092
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6093
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6094
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE numbers AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM numbers WHERE n < 100 ) SELECT n FROM numbers ORDER BY n LIMIT 10 OFFSET 20;
WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_6095
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6096
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6097
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6098
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6099
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6100
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6101
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6102
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6103
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE growth AS ( SELECT 1 AS year, 100.0 AS amount UNION ALL SELECT year + 1, amount * 1.1 FROM growth WHERE year < 5 ) SELECT year, amount FROM growth ORDER BY year;
WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_6104
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6105
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6106
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6107
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6108
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6109
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6110
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6111
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6112
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS nullable_graph;
CREATE TABLE nullable_graph (id INT64, parent_id INT64, value STRING);
INSERT INTO nullable_graph VALUES (1, NULL, 'root'), (2, 1, 'child1'), (3, 1, NULL), (4, 3, 'grandchild');
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE tree AS ( SELECT id, parent_id, value FROM nullable_graph WHERE id = 1 UNION ALL SELECT ng.id, ng.parent_id, ng.value FROM nullable_graph ng INNER JOIN tree t ON ng.parent_id = t.id ) SELECT id, value FROM tree ORDER BY id;
WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_6113
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6114
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6115
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6116
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6117
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6118
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6119
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6120
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6121
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE bad_cte AS ( SELECT 1 AS a, 2 AS b UNION ALL SELECT 3 FROM bad_cte WHERE a < 5 ) SELECT * FROM bad_cte;
WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_6122
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6123
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6124
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6125
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6126
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6127
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6128
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6129
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6130
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE bad_types AS ( SELECT 1 AS num UNION ALL SELECT 'string' FROM bad_types WHERE num < 5 ) SELECT * FROM bad_types;
WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_6131
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6132
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6133
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6134
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6135
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6136
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6137
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6138
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6139
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE deep AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM deep WHERE n < 10000 ) SELECT COUNT(*) AS count FROM deep;
-- Tag: cte_cte_test_select_6140
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6141
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6142
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6143
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6144
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6145
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6146
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6147
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6148
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

-- Tag: cte_cte_test_select_6149
SELECT name, salary FROM employees WHERE id IN ( WITH RECURSIVE team AS ( SELECT id FROM employees WHERE id = 2 UNION ALL SELECT e.id FROM employees e INNER JOIN team t ON e.manager_id = t.id ) SELECT id FROM team ) ORDER BY salary DESC;
WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6150
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6151
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6152
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6153
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6154
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6155
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6156
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6157
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (n INT64);
INSERT INTO nums VALUES (1), (2), (3);
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE seq AS ( SELECT n FROM nums WHERE n = 1 UNION ALL SELECT s.n + 1 FROM seq s WHERE s.n < 10 ) SELECT * FROM seq ORDER BY n;
WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6158
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6159
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6160
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6161
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6162
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6163
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6164
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6165
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE nums AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM nums WHERE n < 3 ) SELECT * FROM nums;
-- Tag: cte_cte_test_select_6166
SELECT * FROM nums;
WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6167
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6168
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6169
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6170
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6171
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6172
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6173
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS sequence;
CREATE TABLE sequence (id INT64);
INSERT INTO sequence VALUES (100);
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE sequence AS ( SELECT 1 AS id UNION ALL SELECT id + 1 FROM sequence WHERE id < 5 ) SELECT * FROM sequence ORDER BY id;
WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6174
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6175
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6176
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6177
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6178
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6179
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6180
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- First base case
-- Second base case
-- Recursive case
-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE multi_base AS (;
-- Tag: cte_cte_test_select_6181
SELECT 1 AS n, 'first' AS source UNION ALL;
-- Tag: cte_cte_test_select_6182
SELECT 2 AS n, 'second' AS source UNION ALL;
-- Tag: cte_cte_test_select_6183
SELECT n + 2, source FROM multi_base WHERE n < 10 ) SELECT * FROM multi_base ORDER BY n;
WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6184
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6185
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6186
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6187
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- Base case with subquery
-- Recursive case
-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS seeds;
CREATE TABLE seeds (val INT64);
INSERT INTO seeds VALUES (1), (5), (10);
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE expanded AS (;
-- Tag: cte_cte_test_select_6188
SELECT val AS n FROM (SELECT MAX(val) AS val FROM seeds) UNION ALL;
-- Tag: cte_cte_test_select_6189
SELECT n + 1 FROM expanded WHERE n < 15 ) SELECT * FROM expanded ORDER BY n;
WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6190
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6191
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

-- Base case should deduplicate to [1, 2]
-- Recursive case
DROP TABLE IF EXISTS starts;
CREATE TABLE starts (n INT64);
INSERT INTO starts VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE deduped AS (;
-- Tag: cte_cte_test_select_6192
SELECT DISTINCT n FROM starts UNION ALL;
-- Tag: cte_cte_test_select_6193
SELECT n + 1 FROM deduped WHERE n < 5 ) SELECT * FROM deduped ORDER BY n;
WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE doubling AS ( SELECT 1 AS n UNION ALL SELECT a.n + b.n FROM doubling a CROSS JOIN doubling b WHERE a.n < 100 AND b.n < 100 AND a.n + b.n <= 100 LIMIT 10 ) SELECT DISTINCT * FROM doubling ORDER BY n;
WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE single AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM single WHERE 1 = 0 ) SELECT * FROM single;
WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE limited AS ( SELECT 1 AS n, 0 AS depth UNION ALL SELECT n + 1, depth + 1 FROM limited WHERE depth = 0 ) SELECT * FROM limited ORDER BY n;
WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE countdown AS ( SELECT 10 AS n UNION ALL SELECT n - 1 FROM countdown WHERE n > 1 ) SELECT * FROM countdown ORDER BY n DESC;
WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE halving AS ( SELECT 1.0 AS val UNION ALL SELECT val / 2.0 FROM halving WHERE val > 0.001 ) SELECT * FROM halving ORDER BY val DESC;
WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS graph;
CREATE TABLE graph (src INT64, dst INT64);
INSERT INTO graph VALUES (1, 2), (2, 3), (3, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE reachable AS ( SELECT 1 AS node UNION ALL SELECT g.dst FROM graph g INNER JOIN reachable r ON g.src = r.node ) SELECT * FROM reachable ORDER BY node;
WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE large AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM large WHERE n < 10000 ) SELECT COUNT(*) as cnt FROM large;
WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE wide AS ( SELECT 1 AS c1, 2 AS c2, 3 AS c3, 4 AS c4, 5 AS c5, 6 AS c6, 7 AS c7, 8 AS c8, 9 AS c9, 10 AS c10 UNION ALL SELECT c1+1, c2+1, c3+1, c4+1, c5+1, c6+1, c7+1, c8+1, c9+1, c10+1 FROM wide WHERE c1 < 100 ) SELECT * FROM wide;
WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE growing AS ( SELECT 1 AS n, 'x' AS str UNION ALL SELECT n + 1, str || 'x' FROM growing WHERE n < 20 ) SELECT n, LENGTH(str) as len FROM growing ORDER BY n;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, 1), (3, 1), (4, 2);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 AS level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n LEFT JOIN tree t ON n.parent_id = t.id WHERE t.id IS NOT NULL ) SELECT * FROM tree ORDER BY id;
WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, dep_id INT64);
DROP TABLE IF EXISTS task_meta;
CREATE TABLE task_meta (task_id INT64, cost INT64);
INSERT INTO tasks VALUES (1, NULL), (2, 1), (3, 2);
INSERT INTO task_meta VALUES (1, 10), (2, 20), (3, 30);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE task_chain AS ( SELECT t.id, t.dep_id, m.cost, 0 AS depth FROM tasks t INNER JOIN task_meta m ON t.id = m.task_id WHERE t.dep_id IS NULL UNION ALL SELECT t.id, t.dep_id, m.cost, tc.depth + 1 FROM tasks t INNER JOIN task_chain tc ON t.dep_id = tc.id INNER JOIN task_meta m ON t.id = m.task_id ) SELECT * FROM task_chain ORDER BY id;
WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (m INT64);
INSERT INTO multipliers VALUES (2), (3);
DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE expanded AS ( SELECT 1 AS n UNION ALL SELECT e.n * mul.m FROM expanded e CROSS JOIN multipliers mul WHERE e.n < 10 LIMIT 20 ) SELECT DISTINCT * FROM expanded ORDER BY n;
WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS limits;
CREATE TABLE limits (max_val INT64);
INSERT INTO limits VALUES (5);
DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE limited AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM limited WHERE n < (SELECT MAX(max_val) FROM limits) ) SELECT * FROM limited;
WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS allowed;
CREATE TABLE allowed (val INT64);
INSERT INTO allowed VALUES (1), (3), (5), (7);
DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE filtered AS ( SELECT 1 AS n UNION ALL SELECT n + 1 FROM filtered WHERE n < 10 AND EXISTS (SELECT 1 FROM allowed WHERE val > n) ) SELECT * FROM filtered ORDER BY n;
WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS valid_steps;
CREATE TABLE valid_steps (step INT64);
INSERT INTO valid_steps VALUES (1), (2);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE steps AS ( SELECT 0 AS pos UNION ALL SELECT pos + s.step FROM steps CROSS JOIN (SELECT step FROM valid_steps) s WHERE pos < 10 LIMIT 30 ) SELECT DISTINCT pos FROM steps ORDER BY pos;
WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE mixed AS ( SELECT 1 AS n UNION ALL SELECT CAST(n AS FLOAT64) * 1.5 FROM mixed WHERE n < 100 LIMIT 10 ) SELECT * FROM mixed;
WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE aliased(value, iteration) AS ( SELECT 1 AS n, 0 AS iter UNION ALL SELECT value + 1, iteration + 1 FROM aliased WHERE value < 5 ) SELECT * FROM aliased ORDER BY value;
WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (val INT64);
INSERT INTO nullable VALUES (1), (NULL), (3);

WITH RECURSIVE nulls AS ( SELECT val FROM nullable UNION ALL SELECT val + 1 FROM nulls WHERE val IS NOT NULL AND val < 5 ) SELECT * FROM nulls ORDER BY val NULLS LAST;

DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP Sales', 1), (3, 'VP Eng', 1), (4, 'Sales Rep', 2), (5, 'Engineer', 3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP Sales', 1), (3, 'VP Eng', 1), (4, 'Sales Rep 1', 2), (5, 'Sales Rep 2', 2), (6, 'Engineer', 3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP Sales', 1), (3, 'Manager', 2), (4, 'Employee', 3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Manager', 2), (4, 'Employee', 3);
DROP TABLE IF EXISTS dependencies;
CREATE TABLE dependencies (module STRING, depends_on STRING);
INSERT INTO dependencies VALUES ('A', 'B'), ('A', 'C'), ('B', 'D'), ('C', 'D'), ('D', 'E');
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 4), (2, 5);
DROP TABLE IF EXISTS files;
CREATE TABLE files (id INT64, name STRING, parent_id INT64, is_dir BOOL);
INSERT INTO files VALUES (1, '/', NULL, true), (2, 'home', 1, true), (3, 'var', 1, true), (4, 'user', 2, true), (5, 'file.txt', 4, false);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Computers', 2), (4, 'Laptops', 3);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Furniture', 1), (4, 'Computers', 2), (5, 'Phones', 2);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1), (2, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64, name STRING);
INSERT INTO nodes VALUES (1, NULL, 'A'), (2, 1, 'B'), (3, 1, 'C'), (4, 2, 'D');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE numbers AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM numbers WHERE n < 10 ) SELECT * FROM numbers;
WITH RECURSIVE fibonacci AS ( SELECT 0 as fib, 1 as next_fib, 1 as n UNION ALL SELECT next_fib, fib + next_fib, n + 1 FROM fibonacci WHERE n < 10 ) SELECT fib FROM fibonacci;
WITH RECURSIVE factorial AS ( SELECT 1 as n, 1 as fact UNION ALL SELECT n + 1, fact * (n + 1) FROM factorial WHERE n < 5 ) SELECT n, fact FROM factorial ORDER BY n;
WITH RECURSIVE org_tree AS ( SELECT id, name, manager_id, 0 as level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id, t.level + 1 FROM employees e JOIN org_tree t ON e.manager_id = t.id ) SELECT * FROM org_tree ORDER BY level, id;
WITH RECURSIVE subordinates AS ( SELECT id, name, manager_id FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN subordinates s ON e.manager_id = s.id ) SELECT * FROM subordinates;
WITH RECURSIVE managers AS ( SELECT id, name, manager_id FROM employees WHERE id = 4 UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN managers m ON e.id = m.manager_id ) SELECT name FROM managers WHERE id != 4 ORDER BY id;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, 0 as depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id, h.depth + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT name, depth FROM hierarchy ORDER BY depth;
WITH RECURSIVE all_deps AS ( SELECT module, depends_on, 1 as level FROM dependencies WHERE module = 'A' UNION ALL SELECT d.module, d.depends_on, a.level + 1 FROM dependencies d JOIN all_deps a ON d.module = a.depends_on ) SELECT DISTINCT depends_on FROM all_deps;
WITH RECURSIVE reachable AS ( SELECT src, dst FROM edges WHERE src = 1 UNION SELECT e.src, e.dst FROM edges e JOIN reachable r ON e.src = r.dst ) SELECT * FROM reachable;
WITH RECURSIVE tree AS ( SELECT id, name, parent_id, 0 as depth, name as path FROM files WHERE parent_id IS NULL UNION ALL SELECT f.id, f.name, f.parent_id, t.depth + 1, t.path || '/' || f.name FROM files f JOIN tree t ON f.parent_id = t.id ) SELECT name, depth, path FROM tree ORDER BY path;
WITH RECURSIVE ancestors AS ( SELECT id, name, parent_id FROM categories WHERE id = 4 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN ancestors a ON c.id = a.parent_id ) SELECT name FROM ancestors ORDER BY id;
WITH RECURSIVE descendants AS ( SELECT id, name, parent_id FROM categories WHERE id = 1 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN descendants d ON c.parent_id = d.id ) SELECT * FROM descendants;
WITH RECURSIVE paths AS ( SELECT src, dst, 1 as depth FROM edges WHERE src = 1 UNION SELECT e.src, e.dst, p.depth + 1 FROM edges e JOIN paths p ON e.src = p.dst WHERE p.depth < 10 ) SELECT * FROM paths;
WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums;
WITH RECURSIVE paths AS ( SELECT src, dst, ARRAY[src] as path, false as has_cycle FROM edges WHERE src = 1 UNION ALL SELECT e.src, e.dst, ARRAY_APPEND(p.path, e.src), ARRAY_POSITION(p.path, e.dst) > 0 as has_cycle FROM edges e JOIN paths p ON e.src = p.dst WHERE NOT p.has_cycle AND ARRAY_LENGTH(p.path) < 10 ) SELECT * FROM paths WHERE has_cycle = true;
WITH RECURSIVE paths AS ( SELECT id, name, name as path FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.name, p.path || '->' || n.name FROM nodes n JOIN paths p ON n.parent_id = p.id ) SELECT name, path FROM paths ORDER BY id;
WITH RECURSIVE evens AS ( SELECT 0 as n UNION ALL SELECT n + 2 FROM evens WHERE n < 10 ), odds AS ( SELECT 1 as n UNION ALL SELECT n + 2 FROM odds WHERE n < 10 ) SELECT 'even' as type, n FROM evens UNION ALL SELECT 'odd' as type, n FROM odds ORDER BY n;
WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6194
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP Sales', 1), (3, 'VP Eng', 1), (4, 'Sales Rep', 2), (5, 'Engineer', 3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP Sales', 1), (3, 'VP Eng', 1), (4, 'Sales Rep 1', 2), (5, 'Sales Rep 2', 2), (6, 'Engineer', 3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP Sales', 1), (3, 'Manager', 2), (4, 'Employee', 3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Manager', 2), (4, 'Employee', 3);
DROP TABLE IF EXISTS dependencies;
CREATE TABLE dependencies (module STRING, depends_on STRING);
INSERT INTO dependencies VALUES ('A', 'B'), ('A', 'C'), ('B', 'D'), ('C', 'D'), ('D', 'E');
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 4), (2, 5);
DROP TABLE IF EXISTS files;
CREATE TABLE files (id INT64, name STRING, parent_id INT64, is_dir BOOL);
INSERT INTO files VALUES (1, '/', NULL, true), (2, 'home', 1, true), (3, 'var', 1, true), (4, 'user', 2, true), (5, 'file.txt', 4, false);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Computers', 2), (4, 'Laptops', 3);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Furniture', 1), (4, 'Computers', 2), (5, 'Phones', 2);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1), (2, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64, name STRING);
INSERT INTO nodes VALUES (1, NULL, 'A'), (2, 1, 'B'), (3, 1, 'C'), (4, 2, 'D');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE fibonacci AS ( SELECT 0 as fib, 1 as next_fib, 1 as n UNION ALL SELECT next_fib, fib + next_fib, n + 1 FROM fibonacci WHERE n < 10 ) SELECT fib FROM fibonacci;
WITH RECURSIVE factorial AS ( SELECT 1 as n, 1 as fact UNION ALL SELECT n + 1, fact * (n + 1) FROM factorial WHERE n < 5 ) SELECT n, fact FROM factorial ORDER BY n;
WITH RECURSIVE org_tree AS ( SELECT id, name, manager_id, 0 as level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id, t.level + 1 FROM employees e JOIN org_tree t ON e.manager_id = t.id ) SELECT * FROM org_tree ORDER BY level, id;
WITH RECURSIVE subordinates AS ( SELECT id, name, manager_id FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN subordinates s ON e.manager_id = s.id ) SELECT * FROM subordinates;
WITH RECURSIVE managers AS ( SELECT id, name, manager_id FROM employees WHERE id = 4 UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN managers m ON e.id = m.manager_id ) SELECT name FROM managers WHERE id != 4 ORDER BY id;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, 0 as depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id, h.depth + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT name, depth FROM hierarchy ORDER BY depth;
WITH RECURSIVE all_deps AS ( SELECT module, depends_on, 1 as level FROM dependencies WHERE module = 'A' UNION ALL SELECT d.module, d.depends_on, a.level + 1 FROM dependencies d JOIN all_deps a ON d.module = a.depends_on ) SELECT DISTINCT depends_on FROM all_deps;
WITH RECURSIVE reachable AS ( SELECT src, dst FROM edges WHERE src = 1 UNION SELECT e.src, e.dst FROM edges e JOIN reachable r ON e.src = r.dst ) SELECT * FROM reachable;
WITH RECURSIVE tree AS ( SELECT id, name, parent_id, 0 as depth, name as path FROM files WHERE parent_id IS NULL UNION ALL SELECT f.id, f.name, f.parent_id, t.depth + 1, t.path || '/' || f.name FROM files f JOIN tree t ON f.parent_id = t.id ) SELECT name, depth, path FROM tree ORDER BY path;
WITH RECURSIVE ancestors AS ( SELECT id, name, parent_id FROM categories WHERE id = 4 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN ancestors a ON c.id = a.parent_id ) SELECT name FROM ancestors ORDER BY id;
WITH RECURSIVE descendants AS ( SELECT id, name, parent_id FROM categories WHERE id = 1 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN descendants d ON c.parent_id = d.id ) SELECT * FROM descendants;
WITH RECURSIVE paths AS ( SELECT src, dst, 1 as depth FROM edges WHERE src = 1 UNION SELECT e.src, e.dst, p.depth + 1 FROM edges e JOIN paths p ON e.src = p.dst WHERE p.depth < 10 ) SELECT * FROM paths;
WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums;
WITH RECURSIVE paths AS ( SELECT src, dst, ARRAY[src] as path, false as has_cycle FROM edges WHERE src = 1 UNION ALL SELECT e.src, e.dst, ARRAY_APPEND(p.path, e.src), ARRAY_POSITION(p.path, e.dst) > 0 as has_cycle FROM edges e JOIN paths p ON e.src = p.dst WHERE NOT p.has_cycle AND ARRAY_LENGTH(p.path) < 10 ) SELECT * FROM paths WHERE has_cycle = true;
WITH RECURSIVE paths AS ( SELECT id, name, name as path FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.name, p.path || '->' || n.name FROM nodes n JOIN paths p ON n.parent_id = p.id ) SELECT name, path FROM paths ORDER BY id;
WITH RECURSIVE evens AS ( SELECT 0 as n UNION ALL SELECT n + 2 FROM evens WHERE n < 10 ), odds AS ( SELECT 1 as n UNION ALL SELECT n + 2 FROM odds WHERE n < 10 ) SELECT 'even' as type, n FROM evens UNION ALL SELECT 'odd' as type, n FROM odds ORDER BY n;
WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6195
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP Sales', 1), (3, 'VP Eng', 1), (4, 'Sales Rep', 2), (5, 'Engineer', 3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP Sales', 1), (3, 'VP Eng', 1), (4, 'Sales Rep 1', 2), (5, 'Sales Rep 2', 2), (6, 'Engineer', 3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP Sales', 1), (3, 'Manager', 2), (4, 'Employee', 3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Manager', 2), (4, 'Employee', 3);
DROP TABLE IF EXISTS dependencies;
CREATE TABLE dependencies (module STRING, depends_on STRING);
INSERT INTO dependencies VALUES ('A', 'B'), ('A', 'C'), ('B', 'D'), ('C', 'D'), ('D', 'E');
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 4), (2, 5);
DROP TABLE IF EXISTS files;
CREATE TABLE files (id INT64, name STRING, parent_id INT64, is_dir BOOL);
INSERT INTO files VALUES (1, '/', NULL, true), (2, 'home', 1, true), (3, 'var', 1, true), (4, 'user', 2, true), (5, 'file.txt', 4, false);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Computers', 2), (4, 'Laptops', 3);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Furniture', 1), (4, 'Computers', 2), (5, 'Phones', 2);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1), (2, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64, name STRING);
INSERT INTO nodes VALUES (1, NULL, 'A'), (2, 1, 'B'), (3, 1, 'C'), (4, 2, 'D');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE factorial AS ( SELECT 1 as n, 1 as fact UNION ALL SELECT n + 1, fact * (n + 1) FROM factorial WHERE n < 5 ) SELECT n, fact FROM factorial ORDER BY n;
WITH RECURSIVE org_tree AS ( SELECT id, name, manager_id, 0 as level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id, t.level + 1 FROM employees e JOIN org_tree t ON e.manager_id = t.id ) SELECT * FROM org_tree ORDER BY level, id;
WITH RECURSIVE subordinates AS ( SELECT id, name, manager_id FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN subordinates s ON e.manager_id = s.id ) SELECT * FROM subordinates;
WITH RECURSIVE managers AS ( SELECT id, name, manager_id FROM employees WHERE id = 4 UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN managers m ON e.id = m.manager_id ) SELECT name FROM managers WHERE id != 4 ORDER BY id;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, 0 as depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id, h.depth + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT name, depth FROM hierarchy ORDER BY depth;
WITH RECURSIVE all_deps AS ( SELECT module, depends_on, 1 as level FROM dependencies WHERE module = 'A' UNION ALL SELECT d.module, d.depends_on, a.level + 1 FROM dependencies d JOIN all_deps a ON d.module = a.depends_on ) SELECT DISTINCT depends_on FROM all_deps;
WITH RECURSIVE reachable AS ( SELECT src, dst FROM edges WHERE src = 1 UNION SELECT e.src, e.dst FROM edges e JOIN reachable r ON e.src = r.dst ) SELECT * FROM reachable;
WITH RECURSIVE tree AS ( SELECT id, name, parent_id, 0 as depth, name as path FROM files WHERE parent_id IS NULL UNION ALL SELECT f.id, f.name, f.parent_id, t.depth + 1, t.path || '/' || f.name FROM files f JOIN tree t ON f.parent_id = t.id ) SELECT name, depth, path FROM tree ORDER BY path;
WITH RECURSIVE ancestors AS ( SELECT id, name, parent_id FROM categories WHERE id = 4 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN ancestors a ON c.id = a.parent_id ) SELECT name FROM ancestors ORDER BY id;
WITH RECURSIVE descendants AS ( SELECT id, name, parent_id FROM categories WHERE id = 1 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN descendants d ON c.parent_id = d.id ) SELECT * FROM descendants;
WITH RECURSIVE paths AS ( SELECT src, dst, 1 as depth FROM edges WHERE src = 1 UNION SELECT e.src, e.dst, p.depth + 1 FROM edges e JOIN paths p ON e.src = p.dst WHERE p.depth < 10 ) SELECT * FROM paths;
WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums;
WITH RECURSIVE paths AS ( SELECT src, dst, ARRAY[src] as path, false as has_cycle FROM edges WHERE src = 1 UNION ALL SELECT e.src, e.dst, ARRAY_APPEND(p.path, e.src), ARRAY_POSITION(p.path, e.dst) > 0 as has_cycle FROM edges e JOIN paths p ON e.src = p.dst WHERE NOT p.has_cycle AND ARRAY_LENGTH(p.path) < 10 ) SELECT * FROM paths WHERE has_cycle = true;
WITH RECURSIVE paths AS ( SELECT id, name, name as path FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.name, p.path || '->' || n.name FROM nodes n JOIN paths p ON n.parent_id = p.id ) SELECT name, path FROM paths ORDER BY id;
WITH RECURSIVE evens AS ( SELECT 0 as n UNION ALL SELECT n + 2 FROM evens WHERE n < 10 ), odds AS ( SELECT 1 as n UNION ALL SELECT n + 2 FROM odds WHERE n < 10 ) SELECT 'even' as type, n FROM evens UNION ALL SELECT 'odd' as type, n FROM odds ORDER BY n;
WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6196
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP Sales', 1), (3, 'VP Eng', 1), (4, 'Sales Rep', 2), (5, 'Engineer', 3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP Sales', 1), (3, 'VP Eng', 1), (4, 'Sales Rep 1', 2), (5, 'Sales Rep 2', 2), (6, 'Engineer', 3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP Sales', 1), (3, 'Manager', 2), (4, 'Employee', 3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Manager', 2), (4, 'Employee', 3);
DROP TABLE IF EXISTS dependencies;
CREATE TABLE dependencies (module STRING, depends_on STRING);
INSERT INTO dependencies VALUES ('A', 'B'), ('A', 'C'), ('B', 'D'), ('C', 'D'), ('D', 'E');
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 4), (2, 5);
DROP TABLE IF EXISTS files;
CREATE TABLE files (id INT64, name STRING, parent_id INT64, is_dir BOOL);
INSERT INTO files VALUES (1, '/', NULL, true), (2, 'home', 1, true), (3, 'var', 1, true), (4, 'user', 2, true), (5, 'file.txt', 4, false);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Computers', 2), (4, 'Laptops', 3);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Furniture', 1), (4, 'Computers', 2), (5, 'Phones', 2);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1), (2, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64, name STRING);
INSERT INTO nodes VALUES (1, NULL, 'A'), (2, 1, 'B'), (3, 1, 'C'), (4, 2, 'D');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE org_tree AS ( SELECT id, name, manager_id, 0 as level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id, t.level + 1 FROM employees e JOIN org_tree t ON e.manager_id = t.id ) SELECT * FROM org_tree ORDER BY level, id;
WITH RECURSIVE subordinates AS ( SELECT id, name, manager_id FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN subordinates s ON e.manager_id = s.id ) SELECT * FROM subordinates;
WITH RECURSIVE managers AS ( SELECT id, name, manager_id FROM employees WHERE id = 4 UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN managers m ON e.id = m.manager_id ) SELECT name FROM managers WHERE id != 4 ORDER BY id;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, 0 as depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id, h.depth + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT name, depth FROM hierarchy ORDER BY depth;
WITH RECURSIVE all_deps AS ( SELECT module, depends_on, 1 as level FROM dependencies WHERE module = 'A' UNION ALL SELECT d.module, d.depends_on, a.level + 1 FROM dependencies d JOIN all_deps a ON d.module = a.depends_on ) SELECT DISTINCT depends_on FROM all_deps;
WITH RECURSIVE reachable AS ( SELECT src, dst FROM edges WHERE src = 1 UNION SELECT e.src, e.dst FROM edges e JOIN reachable r ON e.src = r.dst ) SELECT * FROM reachable;
WITH RECURSIVE tree AS ( SELECT id, name, parent_id, 0 as depth, name as path FROM files WHERE parent_id IS NULL UNION ALL SELECT f.id, f.name, f.parent_id, t.depth + 1, t.path || '/' || f.name FROM files f JOIN tree t ON f.parent_id = t.id ) SELECT name, depth, path FROM tree ORDER BY path;
WITH RECURSIVE ancestors AS ( SELECT id, name, parent_id FROM categories WHERE id = 4 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN ancestors a ON c.id = a.parent_id ) SELECT name FROM ancestors ORDER BY id;
WITH RECURSIVE descendants AS ( SELECT id, name, parent_id FROM categories WHERE id = 1 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN descendants d ON c.parent_id = d.id ) SELECT * FROM descendants;
WITH RECURSIVE paths AS ( SELECT src, dst, 1 as depth FROM edges WHERE src = 1 UNION SELECT e.src, e.dst, p.depth + 1 FROM edges e JOIN paths p ON e.src = p.dst WHERE p.depth < 10 ) SELECT * FROM paths;
WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums;
WITH RECURSIVE paths AS ( SELECT src, dst, ARRAY[src] as path, false as has_cycle FROM edges WHERE src = 1 UNION ALL SELECT e.src, e.dst, ARRAY_APPEND(p.path, e.src), ARRAY_POSITION(p.path, e.dst) > 0 as has_cycle FROM edges e JOIN paths p ON e.src = p.dst WHERE NOT p.has_cycle AND ARRAY_LENGTH(p.path) < 10 ) SELECT * FROM paths WHERE has_cycle = true;
WITH RECURSIVE paths AS ( SELECT id, name, name as path FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.name, p.path || '->' || n.name FROM nodes n JOIN paths p ON n.parent_id = p.id ) SELECT name, path FROM paths ORDER BY id;
WITH RECURSIVE evens AS ( SELECT 0 as n UNION ALL SELECT n + 2 FROM evens WHERE n < 10 ), odds AS ( SELECT 1 as n UNION ALL SELECT n + 2 FROM odds WHERE n < 10 ) SELECT 'even' as type, n FROM evens UNION ALL SELECT 'odd' as type, n FROM odds ORDER BY n;
WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6197
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP Sales', 1), (3, 'VP Eng', 1), (4, 'Sales Rep 1', 2), (5, 'Sales Rep 2', 2), (6, 'Engineer', 3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP Sales', 1), (3, 'Manager', 2), (4, 'Employee', 3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Manager', 2), (4, 'Employee', 3);
DROP TABLE IF EXISTS dependencies;
CREATE TABLE dependencies (module STRING, depends_on STRING);
INSERT INTO dependencies VALUES ('A', 'B'), ('A', 'C'), ('B', 'D'), ('C', 'D'), ('D', 'E');
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 4), (2, 5);
DROP TABLE IF EXISTS files;
CREATE TABLE files (id INT64, name STRING, parent_id INT64, is_dir BOOL);
INSERT INTO files VALUES (1, '/', NULL, true), (2, 'home', 1, true), (3, 'var', 1, true), (4, 'user', 2, true), (5, 'file.txt', 4, false);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Computers', 2), (4, 'Laptops', 3);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Furniture', 1), (4, 'Computers', 2), (5, 'Phones', 2);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1), (2, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64, name STRING);
INSERT INTO nodes VALUES (1, NULL, 'A'), (2, 1, 'B'), (3, 1, 'C'), (4, 2, 'D');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE subordinates AS ( SELECT id, name, manager_id FROM employees WHERE id = 2 UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN subordinates s ON e.manager_id = s.id ) SELECT * FROM subordinates;
WITH RECURSIVE managers AS ( SELECT id, name, manager_id FROM employees WHERE id = 4 UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN managers m ON e.id = m.manager_id ) SELECT name FROM managers WHERE id != 4 ORDER BY id;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, 0 as depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id, h.depth + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT name, depth FROM hierarchy ORDER BY depth;
WITH RECURSIVE all_deps AS ( SELECT module, depends_on, 1 as level FROM dependencies WHERE module = 'A' UNION ALL SELECT d.module, d.depends_on, a.level + 1 FROM dependencies d JOIN all_deps a ON d.module = a.depends_on ) SELECT DISTINCT depends_on FROM all_deps;
WITH RECURSIVE reachable AS ( SELECT src, dst FROM edges WHERE src = 1 UNION SELECT e.src, e.dst FROM edges e JOIN reachable r ON e.src = r.dst ) SELECT * FROM reachable;
WITH RECURSIVE tree AS ( SELECT id, name, parent_id, 0 as depth, name as path FROM files WHERE parent_id IS NULL UNION ALL SELECT f.id, f.name, f.parent_id, t.depth + 1, t.path || '/' || f.name FROM files f JOIN tree t ON f.parent_id = t.id ) SELECT name, depth, path FROM tree ORDER BY path;
WITH RECURSIVE ancestors AS ( SELECT id, name, parent_id FROM categories WHERE id = 4 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN ancestors a ON c.id = a.parent_id ) SELECT name FROM ancestors ORDER BY id;
WITH RECURSIVE descendants AS ( SELECT id, name, parent_id FROM categories WHERE id = 1 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN descendants d ON c.parent_id = d.id ) SELECT * FROM descendants;
WITH RECURSIVE paths AS ( SELECT src, dst, 1 as depth FROM edges WHERE src = 1 UNION SELECT e.src, e.dst, p.depth + 1 FROM edges e JOIN paths p ON e.src = p.dst WHERE p.depth < 10 ) SELECT * FROM paths;
WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums;
WITH RECURSIVE paths AS ( SELECT src, dst, ARRAY[src] as path, false as has_cycle FROM edges WHERE src = 1 UNION ALL SELECT e.src, e.dst, ARRAY_APPEND(p.path, e.src), ARRAY_POSITION(p.path, e.dst) > 0 as has_cycle FROM edges e JOIN paths p ON e.src = p.dst WHERE NOT p.has_cycle AND ARRAY_LENGTH(p.path) < 10 ) SELECT * FROM paths WHERE has_cycle = true;
WITH RECURSIVE paths AS ( SELECT id, name, name as path FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.name, p.path || '->' || n.name FROM nodes n JOIN paths p ON n.parent_id = p.id ) SELECT name, path FROM paths ORDER BY id;
WITH RECURSIVE evens AS ( SELECT 0 as n UNION ALL SELECT n + 2 FROM evens WHERE n < 10 ), odds AS ( SELECT 1 as n UNION ALL SELECT n + 2 FROM odds WHERE n < 10 ) SELECT 'even' as type, n FROM evens UNION ALL SELECT 'odd' as type, n FROM odds ORDER BY n;
WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6198
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP Sales', 1), (3, 'Manager', 2), (4, 'Employee', 3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Manager', 2), (4, 'Employee', 3);
DROP TABLE IF EXISTS dependencies;
CREATE TABLE dependencies (module STRING, depends_on STRING);
INSERT INTO dependencies VALUES ('A', 'B'), ('A', 'C'), ('B', 'D'), ('C', 'D'), ('D', 'E');
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 4), (2, 5);
DROP TABLE IF EXISTS files;
CREATE TABLE files (id INT64, name STRING, parent_id INT64, is_dir BOOL);
INSERT INTO files VALUES (1, '/', NULL, true), (2, 'home', 1, true), (3, 'var', 1, true), (4, 'user', 2, true), (5, 'file.txt', 4, false);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Computers', 2), (4, 'Laptops', 3);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Furniture', 1), (4, 'Computers', 2), (5, 'Phones', 2);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1), (2, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64, name STRING);
INSERT INTO nodes VALUES (1, NULL, 'A'), (2, 1, 'B'), (3, 1, 'C'), (4, 2, 'D');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE managers AS ( SELECT id, name, manager_id FROM employees WHERE id = 4 UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN managers m ON e.id = m.manager_id ) SELECT name FROM managers WHERE id != 4 ORDER BY id;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, 0 as depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id, h.depth + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT name, depth FROM hierarchy ORDER BY depth;
WITH RECURSIVE all_deps AS ( SELECT module, depends_on, 1 as level FROM dependencies WHERE module = 'A' UNION ALL SELECT d.module, d.depends_on, a.level + 1 FROM dependencies d JOIN all_deps a ON d.module = a.depends_on ) SELECT DISTINCT depends_on FROM all_deps;
WITH RECURSIVE reachable AS ( SELECT src, dst FROM edges WHERE src = 1 UNION SELECT e.src, e.dst FROM edges e JOIN reachable r ON e.src = r.dst ) SELECT * FROM reachable;
WITH RECURSIVE tree AS ( SELECT id, name, parent_id, 0 as depth, name as path FROM files WHERE parent_id IS NULL UNION ALL SELECT f.id, f.name, f.parent_id, t.depth + 1, t.path || '/' || f.name FROM files f JOIN tree t ON f.parent_id = t.id ) SELECT name, depth, path FROM tree ORDER BY path;
WITH RECURSIVE ancestors AS ( SELECT id, name, parent_id FROM categories WHERE id = 4 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN ancestors a ON c.id = a.parent_id ) SELECT name FROM ancestors ORDER BY id;
WITH RECURSIVE descendants AS ( SELECT id, name, parent_id FROM categories WHERE id = 1 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN descendants d ON c.parent_id = d.id ) SELECT * FROM descendants;
WITH RECURSIVE paths AS ( SELECT src, dst, 1 as depth FROM edges WHERE src = 1 UNION SELECT e.src, e.dst, p.depth + 1 FROM edges e JOIN paths p ON e.src = p.dst WHERE p.depth < 10 ) SELECT * FROM paths;
WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums;
WITH RECURSIVE paths AS ( SELECT src, dst, ARRAY[src] as path, false as has_cycle FROM edges WHERE src = 1 UNION ALL SELECT e.src, e.dst, ARRAY_APPEND(p.path, e.src), ARRAY_POSITION(p.path, e.dst) > 0 as has_cycle FROM edges e JOIN paths p ON e.src = p.dst WHERE NOT p.has_cycle AND ARRAY_LENGTH(p.path) < 10 ) SELECT * FROM paths WHERE has_cycle = true;
WITH RECURSIVE paths AS ( SELECT id, name, name as path FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.name, p.path || '->' || n.name FROM nodes n JOIN paths p ON n.parent_id = p.id ) SELECT name, path FROM paths ORDER BY id;
WITH RECURSIVE evens AS ( SELECT 0 as n UNION ALL SELECT n + 2 FROM evens WHERE n < 10 ), odds AS ( SELECT 1 as n UNION ALL SELECT n + 2 FROM odds WHERE n < 10 ) SELECT 'even' as type, n FROM evens UNION ALL SELECT 'odd' as type, n FROM odds ORDER BY n;
WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6199
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Manager', 2), (4, 'Employee', 3);
DROP TABLE IF EXISTS dependencies;
CREATE TABLE dependencies (module STRING, depends_on STRING);
INSERT INTO dependencies VALUES ('A', 'B'), ('A', 'C'), ('B', 'D'), ('C', 'D'), ('D', 'E');
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 4), (2, 5);
DROP TABLE IF EXISTS files;
CREATE TABLE files (id INT64, name STRING, parent_id INT64, is_dir BOOL);
INSERT INTO files VALUES (1, '/', NULL, true), (2, 'home', 1, true), (3, 'var', 1, true), (4, 'user', 2, true), (5, 'file.txt', 4, false);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Computers', 2), (4, 'Laptops', 3);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Furniture', 1), (4, 'Computers', 2), (5, 'Phones', 2);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1), (2, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64, name STRING);
INSERT INTO nodes VALUES (1, NULL, 'A'), (2, 1, 'B'), (3, 1, 'C'), (4, 2, 'D');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, 0 as depth FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id, h.depth + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT name, depth FROM hierarchy ORDER BY depth;
WITH RECURSIVE all_deps AS ( SELECT module, depends_on, 1 as level FROM dependencies WHERE module = 'A' UNION ALL SELECT d.module, d.depends_on, a.level + 1 FROM dependencies d JOIN all_deps a ON d.module = a.depends_on ) SELECT DISTINCT depends_on FROM all_deps;
WITH RECURSIVE reachable AS ( SELECT src, dst FROM edges WHERE src = 1 UNION SELECT e.src, e.dst FROM edges e JOIN reachable r ON e.src = r.dst ) SELECT * FROM reachable;
WITH RECURSIVE tree AS ( SELECT id, name, parent_id, 0 as depth, name as path FROM files WHERE parent_id IS NULL UNION ALL SELECT f.id, f.name, f.parent_id, t.depth + 1, t.path || '/' || f.name FROM files f JOIN tree t ON f.parent_id = t.id ) SELECT name, depth, path FROM tree ORDER BY path;
WITH RECURSIVE ancestors AS ( SELECT id, name, parent_id FROM categories WHERE id = 4 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN ancestors a ON c.id = a.parent_id ) SELECT name FROM ancestors ORDER BY id;
WITH RECURSIVE descendants AS ( SELECT id, name, parent_id FROM categories WHERE id = 1 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN descendants d ON c.parent_id = d.id ) SELECT * FROM descendants;
WITH RECURSIVE paths AS ( SELECT src, dst, 1 as depth FROM edges WHERE src = 1 UNION SELECT e.src, e.dst, p.depth + 1 FROM edges e JOIN paths p ON e.src = p.dst WHERE p.depth < 10 ) SELECT * FROM paths;
WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums;
WITH RECURSIVE paths AS ( SELECT src, dst, ARRAY[src] as path, false as has_cycle FROM edges WHERE src = 1 UNION ALL SELECT e.src, e.dst, ARRAY_APPEND(p.path, e.src), ARRAY_POSITION(p.path, e.dst) > 0 as has_cycle FROM edges e JOIN paths p ON e.src = p.dst WHERE NOT p.has_cycle AND ARRAY_LENGTH(p.path) < 10 ) SELECT * FROM paths WHERE has_cycle = true;
WITH RECURSIVE paths AS ( SELECT id, name, name as path FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.name, p.path || '->' || n.name FROM nodes n JOIN paths p ON n.parent_id = p.id ) SELECT name, path FROM paths ORDER BY id;
WITH RECURSIVE evens AS ( SELECT 0 as n UNION ALL SELECT n + 2 FROM evens WHERE n < 10 ), odds AS ( SELECT 1 as n UNION ALL SELECT n + 2 FROM odds WHERE n < 10 ) SELECT 'even' as type, n FROM evens UNION ALL SELECT 'odd' as type, n FROM odds ORDER BY n;
WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6200
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS dependencies;
CREATE TABLE dependencies (module STRING, depends_on STRING);
INSERT INTO dependencies VALUES ('A', 'B'), ('A', 'C'), ('B', 'D'), ('C', 'D'), ('D', 'E');
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 4), (2, 5);
DROP TABLE IF EXISTS files;
CREATE TABLE files (id INT64, name STRING, parent_id INT64, is_dir BOOL);
INSERT INTO files VALUES (1, '/', NULL, true), (2, 'home', 1, true), (3, 'var', 1, true), (4, 'user', 2, true), (5, 'file.txt', 4, false);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Computers', 2), (4, 'Laptops', 3);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Furniture', 1), (4, 'Computers', 2), (5, 'Phones', 2);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1), (2, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64, name STRING);
INSERT INTO nodes VALUES (1, NULL, 'A'), (2, 1, 'B'), (3, 1, 'C'), (4, 2, 'D');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE all_deps AS ( SELECT module, depends_on, 1 as level FROM dependencies WHERE module = 'A' UNION ALL SELECT d.module, d.depends_on, a.level + 1 FROM dependencies d JOIN all_deps a ON d.module = a.depends_on ) SELECT DISTINCT depends_on FROM all_deps;
WITH RECURSIVE reachable AS ( SELECT src, dst FROM edges WHERE src = 1 UNION SELECT e.src, e.dst FROM edges e JOIN reachable r ON e.src = r.dst ) SELECT * FROM reachable;
WITH RECURSIVE tree AS ( SELECT id, name, parent_id, 0 as depth, name as path FROM files WHERE parent_id IS NULL UNION ALL SELECT f.id, f.name, f.parent_id, t.depth + 1, t.path || '/' || f.name FROM files f JOIN tree t ON f.parent_id = t.id ) SELECT name, depth, path FROM tree ORDER BY path;
WITH RECURSIVE ancestors AS ( SELECT id, name, parent_id FROM categories WHERE id = 4 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN ancestors a ON c.id = a.parent_id ) SELECT name FROM ancestors ORDER BY id;
WITH RECURSIVE descendants AS ( SELECT id, name, parent_id FROM categories WHERE id = 1 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN descendants d ON c.parent_id = d.id ) SELECT * FROM descendants;
WITH RECURSIVE paths AS ( SELECT src, dst, 1 as depth FROM edges WHERE src = 1 UNION SELECT e.src, e.dst, p.depth + 1 FROM edges e JOIN paths p ON e.src = p.dst WHERE p.depth < 10 ) SELECT * FROM paths;
WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums;
WITH RECURSIVE paths AS ( SELECT src, dst, ARRAY[src] as path, false as has_cycle FROM edges WHERE src = 1 UNION ALL SELECT e.src, e.dst, ARRAY_APPEND(p.path, e.src), ARRAY_POSITION(p.path, e.dst) > 0 as has_cycle FROM edges e JOIN paths p ON e.src = p.dst WHERE NOT p.has_cycle AND ARRAY_LENGTH(p.path) < 10 ) SELECT * FROM paths WHERE has_cycle = true;
WITH RECURSIVE paths AS ( SELECT id, name, name as path FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.name, p.path || '->' || n.name FROM nodes n JOIN paths p ON n.parent_id = p.id ) SELECT name, path FROM paths ORDER BY id;
WITH RECURSIVE evens AS ( SELECT 0 as n UNION ALL SELECT n + 2 FROM evens WHERE n < 10 ), odds AS ( SELECT 1 as n UNION ALL SELECT n + 2 FROM odds WHERE n < 10 ) SELECT 'even' as type, n FROM evens UNION ALL SELECT 'odd' as type, n FROM odds ORDER BY n;
WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6201
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 4), (2, 5);
DROP TABLE IF EXISTS files;
CREATE TABLE files (id INT64, name STRING, parent_id INT64, is_dir BOOL);
INSERT INTO files VALUES (1, '/', NULL, true), (2, 'home', 1, true), (3, 'var', 1, true), (4, 'user', 2, true), (5, 'file.txt', 4, false);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Computers', 2), (4, 'Laptops', 3);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Furniture', 1), (4, 'Computers', 2), (5, 'Phones', 2);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1), (2, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64, name STRING);
INSERT INTO nodes VALUES (1, NULL, 'A'), (2, 1, 'B'), (3, 1, 'C'), (4, 2, 'D');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE reachable AS ( SELECT src, dst FROM edges WHERE src = 1 UNION SELECT e.src, e.dst FROM edges e JOIN reachable r ON e.src = r.dst ) SELECT * FROM reachable;
WITH RECURSIVE tree AS ( SELECT id, name, parent_id, 0 as depth, name as path FROM files WHERE parent_id IS NULL UNION ALL SELECT f.id, f.name, f.parent_id, t.depth + 1, t.path || '/' || f.name FROM files f JOIN tree t ON f.parent_id = t.id ) SELECT name, depth, path FROM tree ORDER BY path;
WITH RECURSIVE ancestors AS ( SELECT id, name, parent_id FROM categories WHERE id = 4 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN ancestors a ON c.id = a.parent_id ) SELECT name FROM ancestors ORDER BY id;
WITH RECURSIVE descendants AS ( SELECT id, name, parent_id FROM categories WHERE id = 1 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN descendants d ON c.parent_id = d.id ) SELECT * FROM descendants;
WITH RECURSIVE paths AS ( SELECT src, dst, 1 as depth FROM edges WHERE src = 1 UNION SELECT e.src, e.dst, p.depth + 1 FROM edges e JOIN paths p ON e.src = p.dst WHERE p.depth < 10 ) SELECT * FROM paths;
WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums;
WITH RECURSIVE paths AS ( SELECT src, dst, ARRAY[src] as path, false as has_cycle FROM edges WHERE src = 1 UNION ALL SELECT e.src, e.dst, ARRAY_APPEND(p.path, e.src), ARRAY_POSITION(p.path, e.dst) > 0 as has_cycle FROM edges e JOIN paths p ON e.src = p.dst WHERE NOT p.has_cycle AND ARRAY_LENGTH(p.path) < 10 ) SELECT * FROM paths WHERE has_cycle = true;
WITH RECURSIVE paths AS ( SELECT id, name, name as path FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.name, p.path || '->' || n.name FROM nodes n JOIN paths p ON n.parent_id = p.id ) SELECT name, path FROM paths ORDER BY id;
WITH RECURSIVE evens AS ( SELECT 0 as n UNION ALL SELECT n + 2 FROM evens WHERE n < 10 ), odds AS ( SELECT 1 as n UNION ALL SELECT n + 2 FROM odds WHERE n < 10 ) SELECT 'even' as type, n FROM evens UNION ALL SELECT 'odd' as type, n FROM odds ORDER BY n;
WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6202
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS files;
CREATE TABLE files (id INT64, name STRING, parent_id INT64, is_dir BOOL);
INSERT INTO files VALUES (1, '/', NULL, true), (2, 'home', 1, true), (3, 'var', 1, true), (4, 'user', 2, true), (5, 'file.txt', 4, false);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Computers', 2), (4, 'Laptops', 3);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Furniture', 1), (4, 'Computers', 2), (5, 'Phones', 2);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1), (2, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64, name STRING);
INSERT INTO nodes VALUES (1, NULL, 'A'), (2, 1, 'B'), (3, 1, 'C'), (4, 2, 'D');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE tree AS ( SELECT id, name, parent_id, 0 as depth, name as path FROM files WHERE parent_id IS NULL UNION ALL SELECT f.id, f.name, f.parent_id, t.depth + 1, t.path || '/' || f.name FROM files f JOIN tree t ON f.parent_id = t.id ) SELECT name, depth, path FROM tree ORDER BY path;
WITH RECURSIVE ancestors AS ( SELECT id, name, parent_id FROM categories WHERE id = 4 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN ancestors a ON c.id = a.parent_id ) SELECT name FROM ancestors ORDER BY id;
WITH RECURSIVE descendants AS ( SELECT id, name, parent_id FROM categories WHERE id = 1 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN descendants d ON c.parent_id = d.id ) SELECT * FROM descendants;
WITH RECURSIVE paths AS ( SELECT src, dst, 1 as depth FROM edges WHERE src = 1 UNION SELECT e.src, e.dst, p.depth + 1 FROM edges e JOIN paths p ON e.src = p.dst WHERE p.depth < 10 ) SELECT * FROM paths;
WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums;
WITH RECURSIVE paths AS ( SELECT src, dst, ARRAY[src] as path, false as has_cycle FROM edges WHERE src = 1 UNION ALL SELECT e.src, e.dst, ARRAY_APPEND(p.path, e.src), ARRAY_POSITION(p.path, e.dst) > 0 as has_cycle FROM edges e JOIN paths p ON e.src = p.dst WHERE NOT p.has_cycle AND ARRAY_LENGTH(p.path) < 10 ) SELECT * FROM paths WHERE has_cycle = true;
WITH RECURSIVE paths AS ( SELECT id, name, name as path FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.name, p.path || '->' || n.name FROM nodes n JOIN paths p ON n.parent_id = p.id ) SELECT name, path FROM paths ORDER BY id;
WITH RECURSIVE evens AS ( SELECT 0 as n UNION ALL SELECT n + 2 FROM evens WHERE n < 10 ), odds AS ( SELECT 1 as n UNION ALL SELECT n + 2 FROM odds WHERE n < 10 ) SELECT 'even' as type, n FROM evens UNION ALL SELECT 'odd' as type, n FROM odds ORDER BY n;
WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6203
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Computers', 2), (4, 'Laptops', 3);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Furniture', 1), (4, 'Computers', 2), (5, 'Phones', 2);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1), (2, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64, name STRING);
INSERT INTO nodes VALUES (1, NULL, 'A'), (2, 1, 'B'), (3, 1, 'C'), (4, 2, 'D');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE ancestors AS ( SELECT id, name, parent_id FROM categories WHERE id = 4 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN ancestors a ON c.id = a.parent_id ) SELECT name FROM ancestors ORDER BY id;
WITH RECURSIVE descendants AS ( SELECT id, name, parent_id FROM categories WHERE id = 1 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN descendants d ON c.parent_id = d.id ) SELECT * FROM descendants;
WITH RECURSIVE paths AS ( SELECT src, dst, 1 as depth FROM edges WHERE src = 1 UNION SELECT e.src, e.dst, p.depth + 1 FROM edges e JOIN paths p ON e.src = p.dst WHERE p.depth < 10 ) SELECT * FROM paths;
WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums;
WITH RECURSIVE paths AS ( SELECT src, dst, ARRAY[src] as path, false as has_cycle FROM edges WHERE src = 1 UNION ALL SELECT e.src, e.dst, ARRAY_APPEND(p.path, e.src), ARRAY_POSITION(p.path, e.dst) > 0 as has_cycle FROM edges e JOIN paths p ON e.src = p.dst WHERE NOT p.has_cycle AND ARRAY_LENGTH(p.path) < 10 ) SELECT * FROM paths WHERE has_cycle = true;
WITH RECURSIVE paths AS ( SELECT id, name, name as path FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.name, p.path || '->' || n.name FROM nodes n JOIN paths p ON n.parent_id = p.id ) SELECT name, path FROM paths ORDER BY id;
WITH RECURSIVE evens AS ( SELECT 0 as n UNION ALL SELECT n + 2 FROM evens WHERE n < 10 ), odds AS ( SELECT 1 as n UNION ALL SELECT n + 2 FROM odds WHERE n < 10 ) SELECT 'even' as type, n FROM evens UNION ALL SELECT 'odd' as type, n FROM odds ORDER BY n;
WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6204
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING, parent_id INT64);
INSERT INTO categories VALUES (1, 'Products', NULL), (2, 'Electronics', 1), (3, 'Furniture', 1), (4, 'Computers', 2), (5, 'Phones', 2);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1), (2, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64, name STRING);
INSERT INTO nodes VALUES (1, NULL, 'A'), (2, 1, 'B'), (3, 1, 'C'), (4, 2, 'D');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE descendants AS ( SELECT id, name, parent_id FROM categories WHERE id = 1 UNION ALL SELECT c.id, c.name, c.parent_id FROM categories c JOIN descendants d ON c.parent_id = d.id ) SELECT * FROM descendants;
WITH RECURSIVE paths AS ( SELECT src, dst, 1 as depth FROM edges WHERE src = 1 UNION SELECT e.src, e.dst, p.depth + 1 FROM edges e JOIN paths p ON e.src = p.dst WHERE p.depth < 10 ) SELECT * FROM paths;
WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums;
WITH RECURSIVE paths AS ( SELECT src, dst, ARRAY[src] as path, false as has_cycle FROM edges WHERE src = 1 UNION ALL SELECT e.src, e.dst, ARRAY_APPEND(p.path, e.src), ARRAY_POSITION(p.path, e.dst) > 0 as has_cycle FROM edges e JOIN paths p ON e.src = p.dst WHERE NOT p.has_cycle AND ARRAY_LENGTH(p.path) < 10 ) SELECT * FROM paths WHERE has_cycle = true;
WITH RECURSIVE paths AS ( SELECT id, name, name as path FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.name, p.path || '->' || n.name FROM nodes n JOIN paths p ON n.parent_id = p.id ) SELECT name, path FROM paths ORDER BY id;
WITH RECURSIVE evens AS ( SELECT 0 as n UNION ALL SELECT n + 2 FROM evens WHERE n < 10 ), odds AS ( SELECT 1 as n UNION ALL SELECT n + 2 FROM odds WHERE n < 10 ) SELECT 'even' as type, n FROM evens UNION ALL SELECT 'odd' as type, n FROM odds ORDER BY n;
WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6205
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1);
DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1), (2, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64, name STRING);
INSERT INTO nodes VALUES (1, NULL, 'A'), (2, 1, 'B'), (3, 1, 'C'), (4, 2, 'D');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE paths AS ( SELECT src, dst, 1 as depth FROM edges WHERE src = 1 UNION SELECT e.src, e.dst, p.depth + 1 FROM edges e JOIN paths p ON e.src = p.dst WHERE p.depth < 10 ) SELECT * FROM paths;
WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums;
WITH RECURSIVE paths AS ( SELECT src, dst, ARRAY[src] as path, false as has_cycle FROM edges WHERE src = 1 UNION ALL SELECT e.src, e.dst, ARRAY_APPEND(p.path, e.src), ARRAY_POSITION(p.path, e.dst) > 0 as has_cycle FROM edges e JOIN paths p ON e.src = p.dst WHERE NOT p.has_cycle AND ARRAY_LENGTH(p.path) < 10 ) SELECT * FROM paths WHERE has_cycle = true;
WITH RECURSIVE paths AS ( SELECT id, name, name as path FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.name, p.path || '->' || n.name FROM nodes n JOIN paths p ON n.parent_id = p.id ) SELECT name, path FROM paths ORDER BY id;
WITH RECURSIVE evens AS ( SELECT 0 as n UNION ALL SELECT n + 2 FROM evens WHERE n < 10 ), odds AS ( SELECT 1 as n UNION ALL SELECT n + 2 FROM odds WHERE n < 10 ) SELECT 'even' as type, n FROM evens UNION ALL SELECT 'odd' as type, n FROM odds ORDER BY n;
WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6206
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1), (2, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64, name STRING);
INSERT INTO nodes VALUES (1, NULL, 'A'), (2, 1, 'B'), (3, 1, 'C'), (4, 2, 'D');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums;
WITH RECURSIVE paths AS ( SELECT src, dst, ARRAY[src] as path, false as has_cycle FROM edges WHERE src = 1 UNION ALL SELECT e.src, e.dst, ARRAY_APPEND(p.path, e.src), ARRAY_POSITION(p.path, e.dst) > 0 as has_cycle FROM edges e JOIN paths p ON e.src = p.dst WHERE NOT p.has_cycle AND ARRAY_LENGTH(p.path) < 10 ) SELECT * FROM paths WHERE has_cycle = true;
WITH RECURSIVE paths AS ( SELECT id, name, name as path FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.name, p.path || '->' || n.name FROM nodes n JOIN paths p ON n.parent_id = p.id ) SELECT name, path FROM paths ORDER BY id;
WITH RECURSIVE evens AS ( SELECT 0 as n UNION ALL SELECT n + 2 FROM evens WHERE n < 10 ), odds AS ( SELECT 1 as n UNION ALL SELECT n + 2 FROM odds WHERE n < 10 ) SELECT 'even' as type, n FROM evens UNION ALL SELECT 'odd' as type, n FROM odds ORDER BY n;
WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6207
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS edges;
CREATE TABLE edges (src INT64, dst INT64);
INSERT INTO edges VALUES (1, 2), (2, 3), (3, 1), (2, 4);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64, name STRING);
INSERT INTO nodes VALUES (1, NULL, 'A'), (2, 1, 'B'), (3, 1, 'C'), (4, 2, 'D');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE paths AS ( SELECT src, dst, ARRAY[src] as path, false as has_cycle FROM edges WHERE src = 1 UNION ALL SELECT e.src, e.dst, ARRAY_APPEND(p.path, e.src), ARRAY_POSITION(p.path, e.dst) > 0 as has_cycle FROM edges e JOIN paths p ON e.src = p.dst WHERE NOT p.has_cycle AND ARRAY_LENGTH(p.path) < 10 ) SELECT * FROM paths WHERE has_cycle = true;
WITH RECURSIVE paths AS ( SELECT id, name, name as path FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.name, p.path || '->' || n.name FROM nodes n JOIN paths p ON n.parent_id = p.id ) SELECT name, path FROM paths ORDER BY id;
WITH RECURSIVE evens AS ( SELECT 0 as n UNION ALL SELECT n + 2 FROM evens WHERE n < 10 ), odds AS ( SELECT 1 as n UNION ALL SELECT n + 2 FROM odds WHERE n < 10 ) SELECT 'even' as type, n FROM evens UNION ALL SELECT 'odd' as type, n FROM odds ORDER BY n;
WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6208
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64, name STRING);
INSERT INTO nodes VALUES (1, NULL, 'A'), (2, 1, 'B'), (3, 1, 'C'), (4, 2, 'D');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE paths AS ( SELECT id, name, name as path FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.name, p.path || '->' || n.name FROM nodes n JOIN paths p ON n.parent_id = p.id ) SELECT name, path FROM paths ORDER BY id;
WITH RECURSIVE evens AS ( SELECT 0 as n UNION ALL SELECT n + 2 FROM evens WHERE n < 10 ), odds AS ( SELECT 1 as n UNION ALL SELECT n + 2 FROM odds WHERE n < 10 ) SELECT 'even' as type, n FROM evens UNION ALL SELECT 'odd' as type, n FROM odds ORDER BY n;
WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6209
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE evens AS ( SELECT 0 as n UNION ALL SELECT n + 2 FROM evens WHERE n < 10 ), odds AS ( SELECT 1 as n UNION ALL SELECT n + 2 FROM odds WHERE n < 10 ) SELECT 'even' as type, n FROM evens UNION ALL SELECT 'odd' as type, n FROM odds ORDER BY n;
WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6210
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE cte1 AS ( SELECT 1 as n, 'A' as label UNION ALL SELECT n + 1, 'A' FROM cte1 WHERE n < 3 ), cte2 AS ( SELECT n, label FROM cte1 UNION ALL SELECT n + 10, 'B' FROM cte2 WHERE n < 20 AND label = 'A' ) SELECT * FROM cte2;
WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6211
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE deep AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM deep WHERE n < 1000 ) SELECT MAX(n) as max_depth FROM deep;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6212
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 'CEO', NULL, 100000), (2, 'VP', 1, 80000), (3, 'Manager', 2, 60000), (4, 'Employee', 3, 40000);
DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id, salary, 0 as level FROM employees WHERE id = 1 UNION ALL SELECT e.id, e.name, e.manager_id, e.salary, h.level + 1 FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT level, SUM(salary) as total_salary FROM hierarchy GROUP BY level ORDER BY level;
WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6213
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS empty_table;
CREATE TABLE empty_table (id INT64);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE rec AS ( SELECT id FROM empty_table UNION ALL SELECT id + 1 FROM rec WHERE id < 5 ) SELECT * FROM rec;
WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6214
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL);
DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE tree AS ( SELECT id, parent_id FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6215
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS nodes;
CREATE TABLE nodes (id INT64, parent_id INT64);
INSERT INTO nodes VALUES (1, NULL), (2, NULL), (3, 1), (4, 2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE tree AS ( SELECT id, parent_id, 0 as level FROM nodes WHERE parent_id IS NULL UNION ALL SELECT n.id, n.parent_id, t.level + 1 FROM nodes n JOIN tree t ON n.parent_id = t.id ) SELECT * FROM tree;
WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6216
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, active BOOL);
INSERT INTO employees VALUES (1, 'CEO', NULL, true), (2, 'VP', 1, true), (3, 'Manager', 2, false), (4, 'Employee', 3, true);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE active_tree AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN active_tree t ON e.manager_id = t.id WHERE e.active = true ) SELECT * FROM active_tree;
WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6217
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE infinite AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM infinite ) SELECT * FROM infinite LIMIT 10;
WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6218
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (employee_id INT64, dept STRING);
INSERT INTO employees VALUES (1, 'CEO', NULL), (2, 'VP', 1), (3, 'Employee', 2);
INSERT INTO departments VALUES (1, 'Executive'), (2, 'Sales'), (3, 'Sales');

WITH RECURSIVE hierarchy AS ( SELECT id, name, manager_id FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.id, e.name, e.manager_id FROM employees e JOIN hierarchy h ON e.manager_id = h.id ) SELECT h.name, d.dept FROM hierarchy h JOIN departments d ON h.id = d.employee_id ORDER BY h.id;
-- Tag: cte_cte_test_select_6219
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

-- Tag: cte_cte_test_select_6220
SELECT * FROM ( WITH RECURSIVE nums AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM nums WHERE n < 5 ) SELECT * FROM nums ) as subquery WHERE n > 2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, val STRING);
INSERT INTO t1 VALUES (1, 'a');
INSERT INTO t1 VALUES (2, 'b');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, val STRING);
INSERT INTO t2 VALUES (2, 'b');
INSERT INTO t2 VALUES (3, 'c');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6221
SELECT id, val FROM t1 UNION ALL SELECT id, val FROM t2 ORDER BY id, val;
-- Tag: cte_cte_test_select_6222
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6223
SELECT val FROM t1 UNION SELECT val FROM t2;
-- Tag: cte_cte_test_select_6224
SELECT id FROM t1 UNION ALL SELECT id FROM t2 ORDER BY id;
-- Tag: cte_cte_test_select_6225
SELECT id FROM t1 UNION ALL SELECT id FROM t2 ORDER BY id;
-- Tag: cte_cte_test_select_6226
SELECT id FROM t1 UNION ALL SELECT id FROM t2;
-- Tag: cte_cte_test_select_6227
SELECT val FROM t UNION ALL SELECT val FROM t UNION ALL SELECT val FROM t;
-- Tag: cte_cte_test_select_6228
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6229
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6230
SELECT val FROM t1 INTERSECT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6231
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6232
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6233
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6234
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6235
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6236
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6237
SELECT val FROM t1 EXCEPT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6238
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6239
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6240
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6241
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6242
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6243
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6244
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6245
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6246
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6247
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6248
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6249
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6250
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6251
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6252
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6253
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6254
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6255
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6256
SELECT val FROM t1 UNION SELECT val FROM t2;
-- Tag: cte_cte_test_select_6257
SELECT id FROM t1 UNION ALL SELECT id FROM t2 ORDER BY id;
-- Tag: cte_cte_test_select_6258
SELECT id FROM t1 UNION ALL SELECT id FROM t2 ORDER BY id;
-- Tag: cte_cte_test_select_6259
SELECT id FROM t1 UNION ALL SELECT id FROM t2;
-- Tag: cte_cte_test_select_6260
SELECT val FROM t UNION ALL SELECT val FROM t UNION ALL SELECT val FROM t;
-- Tag: cte_cte_test_select_6261
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6262
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6263
SELECT val FROM t1 INTERSECT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6264
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6265
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6266
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6267
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6268
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6269
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6270
SELECT val FROM t1 EXCEPT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6271
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6272
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6273
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6274
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6275
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6276
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6277
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6278
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6279
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6280
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6281
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6282
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6283
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6284
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6285
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6286
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6287
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6288
SELECT id FROM t1 UNION ALL SELECT id FROM t2 ORDER BY id;
-- Tag: cte_cte_test_select_6289
SELECT id FROM t1 UNION ALL SELECT id FROM t2 ORDER BY id;
-- Tag: cte_cte_test_select_6290
SELECT id FROM t1 UNION ALL SELECT id FROM t2;
-- Tag: cte_cte_test_select_6291
SELECT val FROM t UNION ALL SELECT val FROM t UNION ALL SELECT val FROM t;
-- Tag: cte_cte_test_select_6292
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6293
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6294
SELECT val FROM t1 INTERSECT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6295
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6296
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6297
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6298
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6299
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6300
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6301
SELECT val FROM t1 EXCEPT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6302
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6303
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6304
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6305
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6306
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6307
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6308
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6309
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6310
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6311
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6312
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6313
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6314
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6315
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6316
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6317
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6318
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6319
SELECT id FROM t1 UNION ALL SELECT id FROM t2 ORDER BY id;
-- Tag: cte_cte_test_select_6320
SELECT id FROM t1 UNION ALL SELECT id FROM t2;
-- Tag: cte_cte_test_select_6321
SELECT val FROM t UNION ALL SELECT val FROM t UNION ALL SELECT val FROM t;
-- Tag: cte_cte_test_select_6322
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6323
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6324
SELECT val FROM t1 INTERSECT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6325
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6326
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6327
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6328
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6329
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6330
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6331
SELECT val FROM t1 EXCEPT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6332
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6333
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6334
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6335
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6336
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6337
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6338
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6339
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6340
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6341
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6342
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6343
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6344
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6345
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6346
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6347
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6348
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6349
SELECT id FROM t1 UNION ALL SELECT id FROM t2;
-- Tag: cte_cte_test_select_6350
SELECT val FROM t UNION ALL SELECT val FROM t UNION ALL SELECT val FROM t;
-- Tag: cte_cte_test_select_6351
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6352
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6353
SELECT val FROM t1 INTERSECT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6354
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6355
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6356
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6357
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6358
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6359
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6360
SELECT val FROM t1 EXCEPT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6361
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6362
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6363
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6364
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6365
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6366
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6367
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6368
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6369
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6370
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6371
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6372
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6373
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6374
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6375
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6376
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6377
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6378
SELECT val FROM t UNION ALL SELECT val FROM t UNION ALL SELECT val FROM t;
-- Tag: cte_cte_test_select_6379
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6380
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6381
SELECT val FROM t1 INTERSECT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6382
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6383
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6384
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6385
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6386
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6387
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6388
SELECT val FROM t1 EXCEPT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6389
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6390
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6391
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6392
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6393
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6394
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6395
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6396
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6397
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6398
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6399
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6400
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6401
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6402
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6403
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6404
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6405
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6406
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6407
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6408
SELECT val FROM t1 INTERSECT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6409
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6410
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6411
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6412
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6413
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6414
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6415
SELECT val FROM t1 EXCEPT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6416
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6417
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6418
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6419
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6420
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6421
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6422
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6423
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6424
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6425
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6426
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6427
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6428
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6429
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6430
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6431
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6432
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6433
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6434
SELECT val FROM t1 INTERSECT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6435
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6436
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6437
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6438
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6439
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6440
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6441
SELECT val FROM t1 EXCEPT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6442
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6443
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6444
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6445
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6446
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6447
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6448
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6449
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6450
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6451
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6452
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6453
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6454
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6455
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6456
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6457
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6458
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6459
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6460
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6461
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6462
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6463
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6464
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6465
SELECT val FROM t1 EXCEPT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6466
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6467
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6468
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6469
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6470
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6471
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6472
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6473
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6474
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6475
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6476
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6477
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6478
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6479
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6480
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6481
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6482
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6483
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6484
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6485
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6486
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6487
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6488
SELECT val FROM t1 EXCEPT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6489
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6490
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6491
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6492
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6493
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6494
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6495
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6496
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6497
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6498
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6499
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6500
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6501
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6502
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6503
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6504
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6505
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6506
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6507
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6508
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6509
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6510
SELECT val FROM t1 EXCEPT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6511
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6512
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6513
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6514
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6515
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6516
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6517
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6518
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6519
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6520
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6521
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6522
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6523
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6524
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6525
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6526
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6527
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6528
SELECT val FROM t1 INTERSECT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6529
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6530
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6531
SELECT val FROM t1 EXCEPT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6532
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6533
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6534
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6535
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6536
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6537
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6538
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6539
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6540
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6541
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6542
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6543
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6544
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6545
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6546
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6547
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6548
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (1), (1), (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6549
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6550
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6551
SELECT val FROM t1 EXCEPT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6552
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6553
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6554
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6555
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6556
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6557
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6558
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6559
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6560
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6561
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6562
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6563
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6564
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6565
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6566
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6567
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6568
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1), (2), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2), (2), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6569
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6570
SELECT val FROM t1 EXCEPT SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6571
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6572
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6573
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6574
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6575
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6576
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6577
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6578
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6579
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6580
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6581
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6582
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6583
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6584
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6585
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6586
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6587
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (1), (1), (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6588
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6589
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6590
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6591
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6592
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6593
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6594
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6595
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6596
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6597
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6598
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6599
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6600
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6601
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6602
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6603
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6604
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6605
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6606
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6607
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6608
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6609
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6610
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6611
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6612
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6613
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6614
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6615
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6616
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6617
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6618
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6619
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6620
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6621
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6622
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6623
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6624
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6625
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6626
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6627
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6628
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6629
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6630
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6631
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6632
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6633
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6634
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6635
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (1), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6636
SELECT val FROM t1 EXCEPT ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6637
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6638
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6639
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6640
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6641
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6642
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6643
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6644
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6645
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6646
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6647
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6648
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6649
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6650
SELECT val FROM t1 UNION ALL SELECT val FROM t2 UNION ALL SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6651
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6652
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6653
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6654
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6655
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6656
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6657
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6658
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6659
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6660
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6661
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6662
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6663
SELECT val FROM t1 UNION SELECT val FROM t2 INTERSECT SELECT val FROM t3;
(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6664
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6665
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6666
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6667
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6668
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6669
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6670
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6671
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6672
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6673
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6674
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (2), (3);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t3 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

(SELECT val FROM t1 UNION ALL SELECT val FROM t2) EXCEPT SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_6675
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6676
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6677
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6678
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6679
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6680
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6681
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6682
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6683
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6684
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6685
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (3), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6686
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6687
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6688
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6689
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6690
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6691
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6692
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6693
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6694
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6695
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6696
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6697
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val DESC;
-- Tag: cte_cte_test_select_6698
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6699
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6700
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6701
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6702
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6703
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6704
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6705
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6706
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
INSERT INTO t1 VALUES (1, 'z'), (2, 'a');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64, b STRING);
INSERT INTO t2 VALUES (1, 'a'), (2, 'z');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6707
SELECT a, b FROM t1 UNION ALL SELECT a, b FROM t2 ORDER BY a, b;
-- Tag: cte_cte_test_select_6708
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6709
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6710
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6711
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6712
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6713
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6714
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6715
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (col1 INT64);
INSERT INTO t1 VALUES (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (col2 INT64);
INSERT INTO t2 VALUES (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6716
SELECT col1 as first_name FROM t1 UNION ALL SELECT col2 FROM t2;
-- Tag: cte_cte_test_select_6717
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6718
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6719
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6720
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6721
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6722
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6723
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
INSERT INTO t1 VALUES (1, 2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t2 VALUES (1);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6724
SELECT a, b FROM t1 UNION ALL SELECT a FROM t2;
-- Tag: cte_cte_test_select_6725
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6726
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6727
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6728
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6729
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6730
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (10);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t2 VALUES (3.14);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6731
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_6732
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6733
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6734
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6735
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6736
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
INSERT INTO t1 VALUES ('hello');
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

-- Tag: cte_cte_test_select_6737
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6738
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6739
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6740
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6741
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (1), (2), (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2), (3);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (4), (5), (6);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (2);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (3), (4);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (1), (NULL);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (2);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
INSERT INTO t1 VALUES (NULL), (NULL), (1);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t2 VALUES (NULL), (1);

WITH evens AS (SELECT val FROM t WHERE val % 2 = 0), odds AS (SELECT val FROM t WHERE val % 2 = 1) SELECT val FROM evens UNION ALL SELECT val FROM odds ORDER BY val;
-- Tag: cte_cte_test_select_6742
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_6743
SELECT val FROM t1 UNION ALL SELECT val FROM t2 ORDER BY val OFFSET 2;
-- Tag: cte_cte_test_select_6744
SELECT val FROM t1 UNION ALL SELECT val FROM t2;
-- Tag: cte_cte_test_select_6745
SELECT val FROM t1 UNION SELECT val FROM t2;

DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, name STRING);
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO departments VALUES (2, 'Sales');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, name STRING);
INSERT INTO employees VALUES (1, 1, 'Alice');
INSERT INTO employees VALUES (2, 1, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, 'test');
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS all_users;
CREATE TABLE all_users (id INT64, name STRING);
INSERT INTO all_users VALUES (1, 'Alice');
INSERT INTO all_users VALUES (2, 'Bob');
INSERT INTO all_users VALUES (3, 'Charlie');
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (user_id INT64);
INSERT INTO active_users VALUES (1);
INSERT INTO active_users VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_6746
SELECT 'found' WHERE EXISTS (SELECT 1 FROM users WHERE id = 1);
-- Tag: cte_cte_test_select_6747
SELECT 'found' WHERE EXISTS (SELECT 1 FROM users WHERE id = 999);
-- Tag: cte_cte_test_select_6748
SELECT 'found' WHERE EXISTS (SELECT 1 FROM large_table);
-- Tag: cte_cte_test_select_6749
SELECT name FROM departments d \ WHERE EXISTS (SELECT 1 FROM employees e WHERE e.dept_id = d.id);
-- Tag: cte_cte_test_select_6750
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data);
-- Tag: cte_cte_test_select_6751
SELECT 'found' WHERE EXISTS (SELECT * FROM data);
-- Tag: cte_cte_test_select_6752
SELECT 'found' WHERE EXISTS (SELECT id, value FROM data);
-- Tag: cte_cte_test_select_6753
SELECT 'found' WHERE EXISTS (SELECT value FROM data);
-- Tag: cte_cte_test_select_6754
SELECT 'empty' WHERE NOT EXISTS (SELECT 1 FROM users);
-- Tag: cte_cte_test_select_6755
SELECT 'empty' WHERE NOT EXISTS (SELECT 1 FROM users);
-- Tag: cte_cte_test_select_6756
SELECT name FROM all_users u \ WHERE NOT EXISTS (SELECT 1 FROM active_users a WHERE a.user_id = u.id);
-- Tag: cte_cte_test_select_6757
SELECT 'found' WHERE 20 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6758
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6759
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6760
SELECT 'found' WHERE 10 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6761
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6762
SELECT 'found' WHERE 15 > ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6763
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6764
SELECT 'found' WHERE 5 = SOME (SELECT value FROM data);
-- Tag: cte_cte_test_select_6765
SELECT 'found' WHERE 35 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6766
SELECT 'found' WHERE 25 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6767
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6768
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6769
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6770
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_6771
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_6772
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_6773
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_6774
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_6775
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_6776
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_6777
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_6778
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_6779
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_6780
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_6781
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6782
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6783
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6784
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6785
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6786
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6787
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_6788
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_6789
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6790
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_6791
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_6792
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, name STRING);
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO departments VALUES (2, 'Sales');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, name STRING);
INSERT INTO employees VALUES (1, 1, 'Alice');
INSERT INTO employees VALUES (2, 1, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, 'test');
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS all_users;
CREATE TABLE all_users (id INT64, name STRING);
INSERT INTO all_users VALUES (1, 'Alice');
INSERT INTO all_users VALUES (2, 'Bob');
INSERT INTO all_users VALUES (3, 'Charlie');
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (user_id INT64);
INSERT INTO active_users VALUES (1);
INSERT INTO active_users VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_6793
SELECT 'found' WHERE EXISTS (SELECT 1 FROM users WHERE id = 999);
-- Tag: cte_cte_test_select_6794
SELECT 'found' WHERE EXISTS (SELECT 1 FROM large_table);
-- Tag: cte_cte_test_select_6795
SELECT name FROM departments d \ WHERE EXISTS (SELECT 1 FROM employees e WHERE e.dept_id = d.id);
-- Tag: cte_cte_test_select_6796
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data);
-- Tag: cte_cte_test_select_6797
SELECT 'found' WHERE EXISTS (SELECT * FROM data);
-- Tag: cte_cte_test_select_6798
SELECT 'found' WHERE EXISTS (SELECT id, value FROM data);
-- Tag: cte_cte_test_select_6799
SELECT 'found' WHERE EXISTS (SELECT value FROM data);
-- Tag: cte_cte_test_select_6800
SELECT 'empty' WHERE NOT EXISTS (SELECT 1 FROM users);
-- Tag: cte_cte_test_select_6801
SELECT 'empty' WHERE NOT EXISTS (SELECT 1 FROM users);
-- Tag: cte_cte_test_select_6802
SELECT name FROM all_users u \ WHERE NOT EXISTS (SELECT 1 FROM active_users a WHERE a.user_id = u.id);
-- Tag: cte_cte_test_select_6803
SELECT 'found' WHERE 20 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6804
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6805
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6806
SELECT 'found' WHERE 10 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6807
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6808
SELECT 'found' WHERE 15 > ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6809
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6810
SELECT 'found' WHERE 5 = SOME (SELECT value FROM data);
-- Tag: cte_cte_test_select_6811
SELECT 'found' WHERE 35 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6812
SELECT 'found' WHERE 25 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6813
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6814
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6815
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6816
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_6817
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_6818
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_6819
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_6820
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_6821
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_6822
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_6823
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_6824
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_6825
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_6826
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_6827
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6828
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6829
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6830
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6831
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6832
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6833
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_6834
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_6835
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6836
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_6837
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_6838
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, name STRING);
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO departments VALUES (2, 'Sales');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, name STRING);
INSERT INTO employees VALUES (1, 1, 'Alice');
INSERT INTO employees VALUES (2, 1, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, 'test');
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS all_users;
CREATE TABLE all_users (id INT64, name STRING);
INSERT INTO all_users VALUES (1, 'Alice');
INSERT INTO all_users VALUES (2, 'Bob');
INSERT INTO all_users VALUES (3, 'Charlie');
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (user_id INT64);
INSERT INTO active_users VALUES (1);
INSERT INTO active_users VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_6839
SELECT 'found' WHERE EXISTS (SELECT 1 FROM large_table);
-- Tag: cte_cte_test_select_6840
SELECT name FROM departments d \ WHERE EXISTS (SELECT 1 FROM employees e WHERE e.dept_id = d.id);
-- Tag: cte_cte_test_select_6841
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data);
-- Tag: cte_cte_test_select_6842
SELECT 'found' WHERE EXISTS (SELECT * FROM data);
-- Tag: cte_cte_test_select_6843
SELECT 'found' WHERE EXISTS (SELECT id, value FROM data);
-- Tag: cte_cte_test_select_6844
SELECT 'found' WHERE EXISTS (SELECT value FROM data);
-- Tag: cte_cte_test_select_6845
SELECT 'empty' WHERE NOT EXISTS (SELECT 1 FROM users);
-- Tag: cte_cte_test_select_6846
SELECT 'empty' WHERE NOT EXISTS (SELECT 1 FROM users);
-- Tag: cte_cte_test_select_6847
SELECT name FROM all_users u \ WHERE NOT EXISTS (SELECT 1 FROM active_users a WHERE a.user_id = u.id);
-- Tag: cte_cte_test_select_6848
SELECT 'found' WHERE 20 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6849
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6850
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6851
SELECT 'found' WHERE 10 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6852
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6853
SELECT 'found' WHERE 15 > ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6854
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6855
SELECT 'found' WHERE 5 = SOME (SELECT value FROM data);
-- Tag: cte_cte_test_select_6856
SELECT 'found' WHERE 35 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6857
SELECT 'found' WHERE 25 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6858
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6859
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6860
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6861
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_6862
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_6863
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_6864
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_6865
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_6866
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_6867
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_6868
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_6869
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_6870
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_6871
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_6872
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6873
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6874
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6875
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6876
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6877
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6878
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_6879
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_6880
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6881
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_6882
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_6883
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, name STRING);
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO departments VALUES (2, 'Sales');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, name STRING);
INSERT INTO employees VALUES (1, 1, 'Alice');
INSERT INTO employees VALUES (2, 1, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, 'test');
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS all_users;
CREATE TABLE all_users (id INT64, name STRING);
INSERT INTO all_users VALUES (1, 'Alice');
INSERT INTO all_users VALUES (2, 'Bob');
INSERT INTO all_users VALUES (3, 'Charlie');
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (user_id INT64);
INSERT INTO active_users VALUES (1);
INSERT INTO active_users VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_6884
SELECT name FROM departments d \ WHERE EXISTS (SELECT 1 FROM employees e WHERE e.dept_id = d.id);
-- Tag: cte_cte_test_select_6885
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data);
-- Tag: cte_cte_test_select_6886
SELECT 'found' WHERE EXISTS (SELECT * FROM data);
-- Tag: cte_cte_test_select_6887
SELECT 'found' WHERE EXISTS (SELECT id, value FROM data);
-- Tag: cte_cte_test_select_6888
SELECT 'found' WHERE EXISTS (SELECT value FROM data);
-- Tag: cte_cte_test_select_6889
SELECT 'empty' WHERE NOT EXISTS (SELECT 1 FROM users);
-- Tag: cte_cte_test_select_6890
SELECT 'empty' WHERE NOT EXISTS (SELECT 1 FROM users);
-- Tag: cte_cte_test_select_6891
SELECT name FROM all_users u \ WHERE NOT EXISTS (SELECT 1 FROM active_users a WHERE a.user_id = u.id);
-- Tag: cte_cte_test_select_6892
SELECT 'found' WHERE 20 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6893
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6894
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6895
SELECT 'found' WHERE 10 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6896
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6897
SELECT 'found' WHERE 15 > ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6898
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6899
SELECT 'found' WHERE 5 = SOME (SELECT value FROM data);
-- Tag: cte_cte_test_select_6900
SELECT 'found' WHERE 35 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6901
SELECT 'found' WHERE 25 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6902
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6903
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6904
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6905
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_6906
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_6907
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_6908
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_6909
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_6910
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_6911
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_6912
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_6913
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_6914
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_6915
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_6916
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6917
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6918
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6919
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6920
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6921
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6922
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_6923
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_6924
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6925
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_6926
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_6927
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, 'test');
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS all_users;
CREATE TABLE all_users (id INT64, name STRING);
INSERT INTO all_users VALUES (1, 'Alice');
INSERT INTO all_users VALUES (2, 'Bob');
INSERT INTO all_users VALUES (3, 'Charlie');
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (user_id INT64);
INSERT INTO active_users VALUES (1);
INSERT INTO active_users VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_6928
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data);
-- Tag: cte_cte_test_select_6929
SELECT 'found' WHERE EXISTS (SELECT * FROM data);
-- Tag: cte_cte_test_select_6930
SELECT 'found' WHERE EXISTS (SELECT id, value FROM data);
-- Tag: cte_cte_test_select_6931
SELECT 'found' WHERE EXISTS (SELECT value FROM data);
-- Tag: cte_cte_test_select_6932
SELECT 'empty' WHERE NOT EXISTS (SELECT 1 FROM users);
-- Tag: cte_cte_test_select_6933
SELECT 'empty' WHERE NOT EXISTS (SELECT 1 FROM users);
-- Tag: cte_cte_test_select_6934
SELECT name FROM all_users u \ WHERE NOT EXISTS (SELECT 1 FROM active_users a WHERE a.user_id = u.id);
-- Tag: cte_cte_test_select_6935
SELECT 'found' WHERE 20 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6936
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6937
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6938
SELECT 'found' WHERE 10 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6939
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6940
SELECT 'found' WHERE 15 > ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6941
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6942
SELECT 'found' WHERE 5 = SOME (SELECT value FROM data);
-- Tag: cte_cte_test_select_6943
SELECT 'found' WHERE 35 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6944
SELECT 'found' WHERE 25 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6945
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6946
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6947
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6948
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_6949
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_6950
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_6951
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_6952
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_6953
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_6954
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_6955
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_6956
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_6957
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_6958
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_6959
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6960
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6961
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6962
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6963
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6964
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6965
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_6966
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_6967
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_6968
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_6969
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_6970
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS all_users;
CREATE TABLE all_users (id INT64, name STRING);
INSERT INTO all_users VALUES (1, 'Alice');
INSERT INTO all_users VALUES (2, 'Bob');
INSERT INTO all_users VALUES (3, 'Charlie');
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (user_id INT64);
INSERT INTO active_users VALUES (1);
INSERT INTO active_users VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_6971
SELECT 'found' WHERE EXISTS (SELECT value FROM data);
-- Tag: cte_cte_test_select_6972
SELECT 'empty' WHERE NOT EXISTS (SELECT 1 FROM users);
-- Tag: cte_cte_test_select_6973
SELECT 'empty' WHERE NOT EXISTS (SELECT 1 FROM users);
-- Tag: cte_cte_test_select_6974
SELECT name FROM all_users u \ WHERE NOT EXISTS (SELECT 1 FROM active_users a WHERE a.user_id = u.id);
-- Tag: cte_cte_test_select_6975
SELECT 'found' WHERE 20 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6976
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6977
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6978
SELECT 'found' WHERE 10 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6979
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6980
SELECT 'found' WHERE 15 > ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6981
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_6982
SELECT 'found' WHERE 5 = SOME (SELECT value FROM data);
-- Tag: cte_cte_test_select_6983
SELECT 'found' WHERE 35 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6984
SELECT 'found' WHERE 25 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6985
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6986
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6987
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_6988
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_6989
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_6990
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_6991
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_6992
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_6993
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_6994
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_6995
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_6996
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_6997
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_6998
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_6999
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7000
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7001
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7002
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7003
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7004
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7005
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7006
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7007
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7008
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7009
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7010
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS all_users;
CREATE TABLE all_users (id INT64, name STRING);
INSERT INTO all_users VALUES (1, 'Alice');
INSERT INTO all_users VALUES (2, 'Bob');
INSERT INTO all_users VALUES (3, 'Charlie');
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (user_id INT64);
INSERT INTO active_users VALUES (1);
INSERT INTO active_users VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7011
SELECT 'empty' WHERE NOT EXISTS (SELECT 1 FROM users);
-- Tag: cte_cte_test_select_7012
SELECT 'empty' WHERE NOT EXISTS (SELECT 1 FROM users);
-- Tag: cte_cte_test_select_7013
SELECT name FROM all_users u \ WHERE NOT EXISTS (SELECT 1 FROM active_users a WHERE a.user_id = u.id);
-- Tag: cte_cte_test_select_7014
SELECT 'found' WHERE 20 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7015
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7016
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7017
SELECT 'found' WHERE 10 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7018
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7019
SELECT 'found' WHERE 15 > ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7020
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7021
SELECT 'found' WHERE 5 = SOME (SELECT value FROM data);
-- Tag: cte_cte_test_select_7022
SELECT 'found' WHERE 35 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7023
SELECT 'found' WHERE 25 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7024
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7025
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7026
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7027
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_7028
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_7029
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_7030
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7031
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7032
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7033
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7034
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7035
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7036
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7037
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7038
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7039
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7040
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7041
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7042
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7043
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7044
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7045
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7046
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7047
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7048
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7049
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS all_users;
CREATE TABLE all_users (id INT64, name STRING);
INSERT INTO all_users VALUES (1, 'Alice');
INSERT INTO all_users VALUES (2, 'Bob');
INSERT INTO all_users VALUES (3, 'Charlie');
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (user_id INT64);
INSERT INTO active_users VALUES (1);
INSERT INTO active_users VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7050
SELECT 'empty' WHERE NOT EXISTS (SELECT 1 FROM users);
-- Tag: cte_cte_test_select_7051
SELECT name FROM all_users u \ WHERE NOT EXISTS (SELECT 1 FROM active_users a WHERE a.user_id = u.id);
-- Tag: cte_cte_test_select_7052
SELECT 'found' WHERE 20 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7053
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7054
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7055
SELECT 'found' WHERE 10 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7056
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7057
SELECT 'found' WHERE 15 > ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7058
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7059
SELECT 'found' WHERE 5 = SOME (SELECT value FROM data);
-- Tag: cte_cte_test_select_7060
SELECT 'found' WHERE 35 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7061
SELECT 'found' WHERE 25 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7062
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7063
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7064
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7065
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_7066
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_7067
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_7068
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7069
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7070
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7071
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7072
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7073
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7074
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7075
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7076
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7077
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7078
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7079
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7080
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7081
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7082
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7083
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7084
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7085
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7086
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7087
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS all_users;
CREATE TABLE all_users (id INT64, name STRING);
INSERT INTO all_users VALUES (1, 'Alice');
INSERT INTO all_users VALUES (2, 'Bob');
INSERT INTO all_users VALUES (3, 'Charlie');
DROP TABLE IF EXISTS active_users;
CREATE TABLE active_users (user_id INT64);
INSERT INTO active_users VALUES (1);
INSERT INTO active_users VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7088
SELECT name FROM all_users u \ WHERE NOT EXISTS (SELECT 1 FROM active_users a WHERE a.user_id = u.id);
-- Tag: cte_cte_test_select_7089
SELECT 'found' WHERE 20 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7090
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7091
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7092
SELECT 'found' WHERE 10 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7093
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7094
SELECT 'found' WHERE 15 > ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7095
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7096
SELECT 'found' WHERE 5 = SOME (SELECT value FROM data);
-- Tag: cte_cte_test_select_7097
SELECT 'found' WHERE 35 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7098
SELECT 'found' WHERE 25 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7099
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7100
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7101
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7102
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_7103
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_7104
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_7105
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7106
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7107
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7108
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7109
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7110
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7111
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7112
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7113
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7114
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7115
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7116
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7117
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7118
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7119
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7120
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7121
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7122
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7123
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7124
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7125
SELECT 'found' WHERE 20 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7126
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7127
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7128
SELECT 'found' WHERE 10 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7129
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7130
SELECT 'found' WHERE 15 > ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7131
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7132
SELECT 'found' WHERE 5 = SOME (SELECT value FROM data);
-- Tag: cte_cte_test_select_7133
SELECT 'found' WHERE 35 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7134
SELECT 'found' WHERE 25 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7135
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7136
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7137
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7138
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_7139
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_7140
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_7141
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7142
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7143
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7144
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7145
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7146
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7147
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7148
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7149
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7150
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7151
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7152
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7153
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7154
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7155
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7156
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7157
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7158
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7159
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7160
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7161
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7162
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7163
SELECT 'found' WHERE 10 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7164
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7165
SELECT 'found' WHERE 15 > ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7166
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7167
SELECT 'found' WHERE 5 = SOME (SELECT value FROM data);
-- Tag: cte_cte_test_select_7168
SELECT 'found' WHERE 35 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7169
SELECT 'found' WHERE 25 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7170
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7171
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7172
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7173
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_7174
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_7175
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_7176
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7177
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7178
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7179
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7180
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7181
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7182
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7183
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7184
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7185
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7186
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7187
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7188
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7189
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7190
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7191
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7192
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7193
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7194
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7195
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7196
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7197
SELECT 'found' WHERE 10 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7198
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7199
SELECT 'found' WHERE 15 > ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7200
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7201
SELECT 'found' WHERE 5 = SOME (SELECT value FROM data);
-- Tag: cte_cte_test_select_7202
SELECT 'found' WHERE 35 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7203
SELECT 'found' WHERE 25 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7204
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7205
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7206
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7207
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_7208
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_7209
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_7210
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7211
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7212
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7213
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7214
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7215
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7216
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7217
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7218
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7219
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7220
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7221
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7222
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7223
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7224
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7225
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7226
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7227
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7228
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7229
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7230
SELECT 'found' WHERE 10 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7231
SELECT 'found' WHERE 99 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7232
SELECT 'found' WHERE 15 > ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7233
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7234
SELECT 'found' WHERE 5 = SOME (SELECT value FROM data);
-- Tag: cte_cte_test_select_7235
SELECT 'found' WHERE 35 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7236
SELECT 'found' WHERE 25 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7237
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7238
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7239
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7240
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_7241
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_7242
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_7243
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7244
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7245
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7246
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7247
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7248
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7249
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7250
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7251
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7252
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7253
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7254
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7255
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7256
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7257
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7258
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7259
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7260
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7261
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7262
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7263
SELECT 'found' WHERE 15 > ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7264
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7265
SELECT 'found' WHERE 5 = SOME (SELECT value FROM data);
-- Tag: cte_cte_test_select_7266
SELECT 'found' WHERE 35 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7267
SELECT 'found' WHERE 25 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7268
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7269
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7270
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7271
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_7272
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_7273
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_7274
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7275
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7276
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7277
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7278
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7279
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7280
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7281
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7282
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7283
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7284
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7285
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7286
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7287
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7288
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7289
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7290
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7291
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7292
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7293
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7294
SELECT 'found' WHERE 5 = ANY (SELECT value FROM data);
-- Tag: cte_cte_test_select_7295
SELECT 'found' WHERE 5 = SOME (SELECT value FROM data);
-- Tag: cte_cte_test_select_7296
SELECT 'found' WHERE 35 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7297
SELECT 'found' WHERE 25 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7298
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7299
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7300
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7301
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_7302
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_7303
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_7304
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7305
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7306
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7307
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7308
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7309
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7310
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7311
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7312
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7313
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7314
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7315
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7316
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7317
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7318
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7319
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7320
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7321
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7322
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7323
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7324
SELECT 'found' WHERE 35 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7325
SELECT 'found' WHERE 25 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7326
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7327
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7328
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7329
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_7330
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_7331
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_7332
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7333
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7334
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7335
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7336
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7337
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7338
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7339
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7340
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7341
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7342
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7343
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7344
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7345
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7346
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7347
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7348
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7349
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7350
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7351
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (20);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7352
SELECT 'found' WHERE 25 > ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7353
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7354
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7355
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7356
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_7357
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_7358
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_7359
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7360
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7361
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7362
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7363
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7364
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7365
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7366
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7367
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7368
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7369
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7370
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7371
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7372
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7373
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7374
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7375
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7376
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7377
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7378
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7379
SELECT 'found' WHERE 5 <> ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7380
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7381
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7382
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_7383
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_7384
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_7385
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7386
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7387
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7388
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7389
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7390
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7391
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7392
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7393
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7394
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7395
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7396
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7397
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7398
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7399
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7400
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7401
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7402
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7403
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7404
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (10);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (30);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7405
SELECT 'found' WHERE 5 < ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7406
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7407
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_7408
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_7409
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_7410
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7411
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7412
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7413
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7414
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7415
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7416
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7417
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7418
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7419
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7420
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7421
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7422
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7423
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7424
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7425
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7426
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7427
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7428
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7429
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
INSERT INTO data VALUES (5);
DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7430
SELECT 'found' WHERE 5 = ALL (SELECT value FROM data);
-- Tag: cte_cte_test_select_7431
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_7432
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_7433
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_7434
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7435
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7436
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7437
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7438
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7439
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7440
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7441
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7442
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7443
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7444
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7445
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7446
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7447
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7448
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7449
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7450
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7451
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7452
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7453
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS config;
CREATE TABLE config (max_value INT64);
INSERT INTO config VALUES (100);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7454
SELECT (SELECT max_value FROM config) as result;
-- Tag: cte_cte_test_select_7455
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_7456
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_7457
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7458
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7459
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7460
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7461
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7462
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7463
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7464
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7465
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7466
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7467
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7468
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7469
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7470
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7471
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7472
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7473
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7474
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7475
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7476
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7477
SELECT (SELECT value FROM data WHERE value > 100) as result;
-- Tag: cte_cte_test_select_7478
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_7479
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7480
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7481
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7482
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7483
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7484
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7485
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7486
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7487
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7488
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7489
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7490
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7491
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7492
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7493
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7494
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7495
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7496
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7497
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7498
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7499
SELECT (SELECT value FROM data) as result;
-- Tag: cte_cte_test_select_7500
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7501
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7502
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7503
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7504
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7505
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7506
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7507
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7508
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7509
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7510
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7511
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7512
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7513
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7514
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7515
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7516
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7517
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7518
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7519
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (amount FLOAT64);
INSERT INTO sales VALUES (100.0);
INSERT INTO sales VALUES (200.0);
INSERT INTO sales VALUES (150.0);
DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7520
SELECT (SELECT SUM(amount) FROM sales) as total;
-- Tag: cte_cte_test_select_7521
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7522
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7523
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7524
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7525
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7526
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7527
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7528
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7529
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7530
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7531
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7532
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7533
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7534
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7535
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7536
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7537
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7538
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7539
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS config;
CREATE TABLE config (multiplier INT64);
INSERT INTO config VALUES (10);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7540
SELECT 5 * (SELECT multiplier FROM config) as result;
-- Tag: cte_cte_test_select_7541
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7542
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7543
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7544
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7545
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7546
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7547
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7548
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7549
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7550
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7551
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7552
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7553
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7554
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7555
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7556
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7557
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7558
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
INSERT INTO products VALUES (2, 200.0);
INSERT INTO products VALUES (3, 150.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7559
SELECT id FROM products WHERE price > (SELECT AVG(price) FROM products);
-- Tag: cte_cte_test_select_7560
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7561
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7562
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7563
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7564
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7565
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7566
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7567
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7568
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7569
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7570
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7571
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7572
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7573
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7574
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7575
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7576
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, salary INT64);
INSERT INTO employees VALUES (1, 10, 50000);
INSERT INTO employees VALUES (2, 10, 60000);
INSERT INTO employees VALUES (3, 20, 55000);
INSERT INTO employees VALUES (4, 20, 70000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7577
SELECT id FROM employees e1 \ WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);
-- Tag: cte_cte_test_select_7578
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7579
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7580
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7581
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7582
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7583
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7584
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7585
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7586
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7587
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7588
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7589
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7590
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7591
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7592
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7593
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, product_id INT64, quantity INT64);
INSERT INTO orders VALUES (1, 100, 1, 5);
INSERT INTO orders VALUES (2, 100, 1, 3);
INSERT INTO orders VALUES (3, 100, 2, 10);
INSERT INTO orders VALUES (4, 200, 1, 7);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7594
SELECT id FROM orders o1 \ WHERE quantity > (SELECT AVG(quantity) FROM orders o2 \ WHERE o2.customer_id = o1.customer_id \ AND o2.product_id = o1.product_id);
-- Tag: cte_cte_test_select_7595
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7596
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7597
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7598
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7599
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7600
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7601
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7602
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7603
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7604
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7605
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7606
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7607
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7608
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7609
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
INSERT INTO orders VALUES (2, 50.0);
DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7610
SELECT name, \ (SELECT SUM(amount) FROM orders WHERE customer_id = c.id) as total \ FROM customers c;
-- Tag: cte_cte_test_select_7611
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7612
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7613
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7614
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7615
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7616
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7617
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7618
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7619
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7620
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7621
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7622
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7623
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7624
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS level1;
CREATE TABLE level1 (value INT64);
INSERT INTO level1 VALUES (1);
DROP TABLE IF EXISTS level2;
CREATE TABLE level2 (value INT64);
INSERT INTO level2 VALUES (2);
DROP TABLE IF EXISTS level3;
CREATE TABLE level3 (value INT64);
INSERT INTO level3 VALUES (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7625
SELECT * FROM level1 \ WHERE value < (SELECT value FROM level2 \ WHERE value < (SELECT value FROM level3));
-- Tag: cte_cte_test_select_7626
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7627
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7628
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7629
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7630
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7631
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7632
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7633
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7634
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7635
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7636
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7637
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7638
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
INSERT INTO users VALUES (1);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, total FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_total FLOAT64);
INSERT INTO thresholds VALUES (50.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7639
SELECT * FROM users u \ WHERE EXISTS (SELECT 1 FROM orders o \ WHERE o.user_id = u.id \ AND o.total > (SELECT min_total FROM thresholds));
-- Tag: cte_cte_test_select_7640
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7641
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7642
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7643
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7644
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7645
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7646
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7647
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7648
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7649
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7650
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7651
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7652
SELECT 'found' WHERE NULL IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7653
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7654
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7655
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7656
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7657
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7658
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7659
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7660
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7661
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7662
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7663
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
INSERT INTO data VALUES (3);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7664
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7665
SELECT 'found' WHERE 2 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7666
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7667
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7668
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7669
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7670
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7671
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7672
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7673
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7674
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7675
SELECT 'found' WHERE 2 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7676
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7677
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7678
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7679
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7680
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7681
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7682
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7683
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7684
SELECT 'found' WHERE 5 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7685
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7686
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7687
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7688
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7689
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7690
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7691
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7692
SELECT 'found' WHERE 5 NOT IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7693
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7694
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7695
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7696
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7697
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7698
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7699
SELECT * FROM data WHERE value IN (SELECT value FROM data ORDER BY value LIMIT 5);
-- Tag: cte_cte_test_select_7700
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7701
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7702
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7703
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7704
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (1);
DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7705
SELECT 'found' WHERE EXISTS (SELECT 1 FROM data WHERE value = 1);
-- Tag: cte_cte_test_select_7706
SELECT 'found' WHERE 1 IN (SELECT value FROM data);
-- Tag: cte_cte_test_select_7707
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7708
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7709
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS outer_table;
CREATE TABLE outer_table (id INT64, category INT64);
DROP TABLE IF EXISTS inner_table;
CREATE TABLE inner_table (id INT64, outer_id INT64, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7710
SELECT id FROM outer_table o \ WHERE (SELECT COUNT(*) FROM inner_table i WHERE i.outer_id = o.id) > 5;
-- Tag: cte_cte_test_select_7711
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7712
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (user_id INT64, amount FLOAT64);
INSERT INTO orders VALUES (1, 100.0);
INSERT INTO orders VALUES (1, 200.0);
DROP TABLE IF EXISTS thresholds;
CREATE TABLE thresholds (min_amount FLOAT64);
INSERT INTO thresholds VALUES (150.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7713
SELECT u.name FROM users u \ JOIN orders o ON u.id = o.user_id \ WHERE o.amount > (SELECT min_amount FROM thresholds);
-- Tag: cte_cte_test_select_7714
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 100.0);
INSERT INTO sales VALUES (1, 200.0);
INSERT INTO sales VALUES (2, 50.0);
INSERT INTO sales VALUES (2, 75.0);
DROP TABLE IF EXISTS targets;
CREATE TABLE targets (min_total FLOAT64);
INSERT INTO targets VALUES (200.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

-- Tag: cte_cte_test_select_7715
SELECT product_id FROM sales \ GROUP BY product_id \ HAVING SUM(amount) > (SELECT min_total FROM targets);
WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1);
INSERT INTO data VALUES (2);
INSERT INTO data VALUES (3);

WITH filtered AS ( SELECT * FROM data WHERE value > (SELECT MIN(value) FROM data) ) SELECT COUNT(*) FROM filtered;

DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES ('A', 10.5), ('A', 12.3), ('A', 11.1), ('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES (1, 10.0), (1, 20.0), (1, 30.0), (2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

-- Tag: cte_cte_test_select_7716
SELECT year, month FROM processed_events;
-- Tag: cte_cte_test_select_7717
SELECT first_col, second_col, sum_col FROM dest;
-- Tag: cte_cte_test_select_7718
SELECT * FROM sensor_stats WHERE sensor = 'A';
-- Tag: cte_cte_test_select_7719
SELECT value FROM dest;
-- Tag: cte_cte_test_select_7720
SELECT hypotenuse FROM computed ORDER BY x;

DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES ('A', 10.5), ('A', 12.3), ('A', 11.1), ('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES (1, 10.0), (1, 20.0), (1, 30.0), (2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

-- Tag: cte_cte_test_select_7721
SELECT first_col, second_col, sum_col FROM dest;
-- Tag: cte_cte_test_select_7722
SELECT * FROM sensor_stats WHERE sensor = 'A';
-- Tag: cte_cte_test_select_7723
SELECT value FROM dest;
-- Tag: cte_cte_test_select_7724
SELECT hypotenuse FROM computed ORDER BY x;

DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES ('A', 10.5), ('A', 12.3), ('A', 11.1), ('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES (1, 10.0), (1, 20.0), (1, 30.0), (2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

-- Tag: cte_cte_test_select_7725
SELECT * FROM sensor_stats WHERE sensor = 'A';
-- Tag: cte_cte_test_select_7726
SELECT value FROM dest;
-- Tag: cte_cte_test_select_7727
SELECT hypotenuse FROM computed ORDER BY x;

CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES (1, 10.0), (1, 20.0), (1, 30.0), (2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

-- Tag: cte_cte_test_select_7728
SELECT value FROM dest;
-- Tag: cte_cte_test_select_7729
SELECT hypotenuse FROM computed ORDER BY x;

DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES (1, 10.0), (1, 20.0), (1, 30.0), (2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

-- Tag: cte_cte_test_select_7730
SELECT value FROM dest;
-- Tag: cte_cte_test_select_7731
SELECT hypotenuse FROM computed ORDER BY x;

DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES (1, 10.0), (1, 20.0), (1, 30.0), (2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

-- Tag: cte_cte_test_select_7732
SELECT hypotenuse FROM computed ORDER BY x;

DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

-- Tag: cte_cte_test_select_7733
SELECT hypotenuse FROM computed ORDER BY x;

CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

-- Tag: cte_cte_test_select_7734
SELECT hypotenuse FROM computed ORDER BY x;

DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

-- Tag: cte_cte_test_select_7735
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
-- Tag: cte_cte_test_select_7736
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
-- Tag: cte_cte_test_select_7737
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
-- Tag: cte_cte_test_select_7738
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
-- Tag: cte_cte_test_select_7739
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
-- Tag: cte_cte_test_select_7740
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
-- Tag: cte_cte_test_select_7741
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
-- Tag: cte_cte_test_select_7742
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
-- Tag: cte_cte_test_select_7743
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
-- Tag: cte_cte_test_select_7744
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
-- Tag: cte_cte_test_select_7745
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7746
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
-- Tag: cte_cte_test_select_7747
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7748
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
-- Tag: cte_cte_test_select_7749
SELECT CURRENT_TIMESTAMP AS now;
-- Tag: cte_cte_test_select_7750
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
-- Tag: cte_cte_test_select_7751
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

-- Tag: cte_cte_test_select_7752
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
-- Tag: cte_cte_test_select_7753
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
-- Tag: cte_cte_test_select_7754
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
-- Tag: cte_cte_test_select_7755
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
-- Tag: cte_cte_test_select_7756
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
-- Tag: cte_cte_test_select_7757
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
-- Tag: cte_cte_test_select_7758
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
-- Tag: cte_cte_test_select_7759
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
-- Tag: cte_cte_test_select_7760
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
-- Tag: cte_cte_test_select_7761
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7762
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
-- Tag: cte_cte_test_select_7763
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7764
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
-- Tag: cte_cte_test_select_7765
SELECT CURRENT_TIMESTAMP AS now;
-- Tag: cte_cte_test_select_7766
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
-- Tag: cte_cte_test_select_7767
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

-- Tag: cte_cte_test_select_7768
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
-- Tag: cte_cte_test_select_7769
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
-- Tag: cte_cte_test_select_7770
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
-- Tag: cte_cte_test_select_7771
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
-- Tag: cte_cte_test_select_7772
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
-- Tag: cte_cte_test_select_7773
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
-- Tag: cte_cte_test_select_7774
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
-- Tag: cte_cte_test_select_7775
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
-- Tag: cte_cte_test_select_7776
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7777
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
-- Tag: cte_cte_test_select_7778
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7779
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
-- Tag: cte_cte_test_select_7780
SELECT CURRENT_TIMESTAMP AS now;
-- Tag: cte_cte_test_select_7781
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
-- Tag: cte_cte_test_select_7782
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

-- Tag: cte_cte_test_select_7783
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
-- Tag: cte_cte_test_select_7784
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
-- Tag: cte_cte_test_select_7785
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
-- Tag: cte_cte_test_select_7786
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
-- Tag: cte_cte_test_select_7787
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
-- Tag: cte_cte_test_select_7788
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
-- Tag: cte_cte_test_select_7789
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
-- Tag: cte_cte_test_select_7790
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7791
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
-- Tag: cte_cte_test_select_7792
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7793
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
-- Tag: cte_cte_test_select_7794
SELECT CURRENT_TIMESTAMP AS now;
-- Tag: cte_cte_test_select_7795
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
-- Tag: cte_cte_test_select_7796
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

-- Tag: cte_cte_test_select_7797
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
-- Tag: cte_cte_test_select_7798
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
-- Tag: cte_cte_test_select_7799
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
-- Tag: cte_cte_test_select_7800
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
-- Tag: cte_cte_test_select_7801
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
-- Tag: cte_cte_test_select_7802
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
-- Tag: cte_cte_test_select_7803
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7804
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
-- Tag: cte_cte_test_select_7805
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7806
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
-- Tag: cte_cte_test_select_7807
SELECT CURRENT_TIMESTAMP AS now;
-- Tag: cte_cte_test_select_7808
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
-- Tag: cte_cte_test_select_7809
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

-- Tag: cte_cte_test_select_7810
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
-- Tag: cte_cte_test_select_7811
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
-- Tag: cte_cte_test_select_7812
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
-- Tag: cte_cte_test_select_7813
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
-- Tag: cte_cte_test_select_7814
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
-- Tag: cte_cte_test_select_7815
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7816
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
-- Tag: cte_cte_test_select_7817
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7818
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
-- Tag: cte_cte_test_select_7819
SELECT CURRENT_TIMESTAMP AS now;
-- Tag: cte_cte_test_select_7820
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
-- Tag: cte_cte_test_select_7821
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

-- Tag: cte_cte_test_select_7822
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
-- Tag: cte_cte_test_select_7823
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
-- Tag: cte_cte_test_select_7824
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
-- Tag: cte_cte_test_select_7825
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
-- Tag: cte_cte_test_select_7826
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7827
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
-- Tag: cte_cte_test_select_7828
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7829
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
-- Tag: cte_cte_test_select_7830
SELECT CURRENT_TIMESTAMP AS now;
-- Tag: cte_cte_test_select_7831
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
-- Tag: cte_cte_test_select_7832
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

-- Tag: cte_cte_test_select_7833
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
-- Tag: cte_cte_test_select_7834
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
-- Tag: cte_cte_test_select_7835
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
-- Tag: cte_cte_test_select_7836
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7837
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
-- Tag: cte_cte_test_select_7838
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7839
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
-- Tag: cte_cte_test_select_7840
SELECT CURRENT_TIMESTAMP AS now;
-- Tag: cte_cte_test_select_7841
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
-- Tag: cte_cte_test_select_7842
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

-- Tag: cte_cte_test_select_7843
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
-- Tag: cte_cte_test_select_7844
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
-- Tag: cte_cte_test_select_7845
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7846
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
-- Tag: cte_cte_test_select_7847
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7848
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
-- Tag: cte_cte_test_select_7849
SELECT CURRENT_TIMESTAMP AS now;
-- Tag: cte_cte_test_select_7850
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
-- Tag: cte_cte_test_select_7851
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- Tag: cte_cte_test_select_7852
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
-- Tag: cte_cte_test_select_7853
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7854
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
-- Tag: cte_cte_test_select_7855
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7856
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
-- Tag: cte_cte_test_select_7857
SELECT CURRENT_TIMESTAMP AS now;
-- Tag: cte_cte_test_select_7858
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
-- Tag: cte_cte_test_select_7859
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- Tag: cte_cte_test_select_7860
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7861
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
-- Tag: cte_cte_test_select_7862
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7863
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
-- Tag: cte_cte_test_select_7864
SELECT CURRENT_TIMESTAMP AS now;
-- Tag: cte_cte_test_select_7865
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
-- Tag: cte_cte_test_select_7866
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- Tag: cte_cte_test_select_7867
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
-- Tag: cte_cte_test_select_7868
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7869
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
-- Tag: cte_cte_test_select_7870
SELECT CURRENT_TIMESTAMP AS now;
-- Tag: cte_cte_test_select_7871
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
-- Tag: cte_cte_test_select_7872
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- Tag: cte_cte_test_select_7873
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
-- Tag: cte_cte_test_select_7874
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
-- Tag: cte_cte_test_select_7875
SELECT CURRENT_TIMESTAMP AS now;
-- Tag: cte_cte_test_select_7876
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
-- Tag: cte_cte_test_select_7877
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- Tag: cte_cte_test_select_7878
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
-- Tag: cte_cte_test_select_7879
SELECT CURRENT_TIMESTAMP AS now;
-- Tag: cte_cte_test_select_7880
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
-- Tag: cte_cte_test_select_7881
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- Tag: cte_cte_test_select_7882
SELECT CURRENT_TIMESTAMP AS now;
-- Tag: cte_cte_test_select_7883
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
-- Tag: cte_cte_test_select_7884
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- Tag: cte_cte_test_select_7885
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
-- Tag: cte_cte_test_select_7886
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- Tag: cte_cte_test_select_7887
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

DROP TABLE IF EXISTS ints;
CREATE TABLE ints (val INT64);
DROP TABLE IF EXISTS floats;
CREATE TABLE floats (val FLOAT64);
INSERT INTO ints VALUES (1), (2), (3);
INSERT INTO floats VALUES (3.5), (4.5);
DROP TABLE IF EXISTS ints;
CREATE TABLE ints (val INT64);
DROP TABLE IF EXISTS floats;
CREATE TABLE floats (val FLOAT64);
INSERT INTO ints VALUES (1), (2);
INSERT INTO floats VALUES (3.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (first_name STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (second_name STRING);
INSERT INTO t1 VALUES ('Alice');
INSERT INTO t2 VALUES ('Bob');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2.5);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (NULL);
INSERT INTO t2 VALUES (2.5), (NULL);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (10);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val FLOAT64);
INSERT INTO t VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t1 VALUES ('hello');
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t1 VALUES (1, 2);
INSERT INTO t2 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (5), (1), (3);
INSERT INTO t2 VALUES (2.5), (4.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (threshold FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);
INSERT INTO t3 VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2), (3);
INSERT INTO t2 VALUES (4.5), (5.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (9007199254740991);
INSERT INTO t2 VALUES (1.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (-5), (0), (5);
INSERT INTO t2 VALUES (-2.5), (0.0), (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a FLOAT64, b STRING);
INSERT INTO t1 VALUES (1, 'foo'), (2, 'bar');
INSERT INTO t2 VALUES (3.5, 'baz');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);

-- Tag: cte_cte_test_select_7888
SELECT val FROM ints UNION SELECT val FROM floats ORDER BY val;
-- Tag: cte_cte_test_select_7889
SELECT val FROM ints UNION ALL SELECT val FROM floats;
-- Tag: cte_cte_test_select_7890
SELECT first_name FROM t1 UNION SELECT second_name FROM t2;
-- Tag: cte_cte_test_select_7891
SELECT val FROM t1 UNION SELECT val FROM t2 UNION SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_7892
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7893
SELECT val * 2 FROM t UNION SELECT val / 3.0 FROM t;
-- Tag: cte_cte_test_select_7894
SELECT CEIL(val) FROM t UNION SELECT FLOOR(val) FROM t;
-- Tag: cte_cte_test_select_7895
SELECT val FROM t1 UNION SELECT val FROM t2;
-- Tag: cte_cte_test_select_7896
SELECT a, b FROM t1 UNION SELECT a FROM t2;
-- Tag: cte_cte_test_select_7897
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_7898
SELECT * FROM t3 WHERE threshold < ( SELECT MAX(val) FROM ( SELECT val FROM t1 UNION SELECT val FROM t2 ) AS combined );
-- Tag: cte_cte_test_select_7899
SELECT AVG(val) as avg_val FROM ( SELECT val FROM t1 UNION ALL SELECT val FROM t2 ) AS combined;
-- Tag: cte_cte_test_select_7900
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7901
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7902
SELECT a, b FROM t1 UNION SELECT a, b FROM t2 ORDER BY a;
WITH combined AS ( SELECT val FROM t1 UNION SELECT val FROM t2 ) SELECT * FROM combined ORDER BY val;

DROP TABLE IF EXISTS ints;
CREATE TABLE ints (val INT64);
DROP TABLE IF EXISTS floats;
CREATE TABLE floats (val FLOAT64);
INSERT INTO ints VALUES (1), (2);
INSERT INTO floats VALUES (3.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (first_name STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (second_name STRING);
INSERT INTO t1 VALUES ('Alice');
INSERT INTO t2 VALUES ('Bob');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2.5);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (NULL);
INSERT INTO t2 VALUES (2.5), (NULL);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (10);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val FLOAT64);
INSERT INTO t VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t1 VALUES ('hello');
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t1 VALUES (1, 2);
INSERT INTO t2 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (5), (1), (3);
INSERT INTO t2 VALUES (2.5), (4.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (threshold FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);
INSERT INTO t3 VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2), (3);
INSERT INTO t2 VALUES (4.5), (5.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (9007199254740991);
INSERT INTO t2 VALUES (1.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (-5), (0), (5);
INSERT INTO t2 VALUES (-2.5), (0.0), (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a FLOAT64, b STRING);
INSERT INTO t1 VALUES (1, 'foo'), (2, 'bar');
INSERT INTO t2 VALUES (3.5, 'baz');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);

-- Tag: cte_cte_test_select_7903
SELECT val FROM ints UNION ALL SELECT val FROM floats;
-- Tag: cte_cte_test_select_7904
SELECT first_name FROM t1 UNION SELECT second_name FROM t2;
-- Tag: cte_cte_test_select_7905
SELECT val FROM t1 UNION SELECT val FROM t2 UNION SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_7906
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7907
SELECT val * 2 FROM t UNION SELECT val / 3.0 FROM t;
-- Tag: cte_cte_test_select_7908
SELECT CEIL(val) FROM t UNION SELECT FLOOR(val) FROM t;
-- Tag: cte_cte_test_select_7909
SELECT val FROM t1 UNION SELECT val FROM t2;
-- Tag: cte_cte_test_select_7910
SELECT a, b FROM t1 UNION SELECT a FROM t2;
-- Tag: cte_cte_test_select_7911
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_7912
SELECT * FROM t3 WHERE threshold < ( SELECT MAX(val) FROM ( SELECT val FROM t1 UNION SELECT val FROM t2 ) AS combined );
-- Tag: cte_cte_test_select_7913
SELECT AVG(val) as avg_val FROM ( SELECT val FROM t1 UNION ALL SELECT val FROM t2 ) AS combined;
-- Tag: cte_cte_test_select_7914
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7915
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7916
SELECT a, b FROM t1 UNION SELECT a, b FROM t2 ORDER BY a;
WITH combined AS ( SELECT val FROM t1 UNION SELECT val FROM t2 ) SELECT * FROM combined ORDER BY val;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (first_name STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (second_name STRING);
INSERT INTO t1 VALUES ('Alice');
INSERT INTO t2 VALUES ('Bob');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2.5);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (NULL);
INSERT INTO t2 VALUES (2.5), (NULL);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (10);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val FLOAT64);
INSERT INTO t VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t1 VALUES ('hello');
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t1 VALUES (1, 2);
INSERT INTO t2 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (5), (1), (3);
INSERT INTO t2 VALUES (2.5), (4.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (threshold FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);
INSERT INTO t3 VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2), (3);
INSERT INTO t2 VALUES (4.5), (5.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (9007199254740991);
INSERT INTO t2 VALUES (1.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (-5), (0), (5);
INSERT INTO t2 VALUES (-2.5), (0.0), (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a FLOAT64, b STRING);
INSERT INTO t1 VALUES (1, 'foo'), (2, 'bar');
INSERT INTO t2 VALUES (3.5, 'baz');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);

-- Tag: cte_cte_test_select_7917
SELECT first_name FROM t1 UNION SELECT second_name FROM t2;
-- Tag: cte_cte_test_select_7918
SELECT val FROM t1 UNION SELECT val FROM t2 UNION SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_7919
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7920
SELECT val * 2 FROM t UNION SELECT val / 3.0 FROM t;
-- Tag: cte_cte_test_select_7921
SELECT CEIL(val) FROM t UNION SELECT FLOOR(val) FROM t;
-- Tag: cte_cte_test_select_7922
SELECT val FROM t1 UNION SELECT val FROM t2;
-- Tag: cte_cte_test_select_7923
SELECT a, b FROM t1 UNION SELECT a FROM t2;
-- Tag: cte_cte_test_select_7924
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_7925
SELECT * FROM t3 WHERE threshold < ( SELECT MAX(val) FROM ( SELECT val FROM t1 UNION SELECT val FROM t2 ) AS combined );
-- Tag: cte_cte_test_select_7926
SELECT AVG(val) as avg_val FROM ( SELECT val FROM t1 UNION ALL SELECT val FROM t2 ) AS combined;
-- Tag: cte_cte_test_select_7927
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7928
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7929
SELECT a, b FROM t1 UNION SELECT a, b FROM t2 ORDER BY a;
WITH combined AS ( SELECT val FROM t1 UNION SELECT val FROM t2 ) SELECT * FROM combined ORDER BY val;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (val INT64);
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2.5);
INSERT INTO t3 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (NULL);
INSERT INTO t2 VALUES (2.5), (NULL);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (10);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val FLOAT64);
INSERT INTO t VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t1 VALUES ('hello');
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t1 VALUES (1, 2);
INSERT INTO t2 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (5), (1), (3);
INSERT INTO t2 VALUES (2.5), (4.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (threshold FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);
INSERT INTO t3 VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2), (3);
INSERT INTO t2 VALUES (4.5), (5.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (9007199254740991);
INSERT INTO t2 VALUES (1.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (-5), (0), (5);
INSERT INTO t2 VALUES (-2.5), (0.0), (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a FLOAT64, b STRING);
INSERT INTO t1 VALUES (1, 'foo'), (2, 'bar');
INSERT INTO t2 VALUES (3.5, 'baz');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);

-- Tag: cte_cte_test_select_7930
SELECT val FROM t1 UNION SELECT val FROM t2 UNION SELECT val FROM t3 ORDER BY val;
-- Tag: cte_cte_test_select_7931
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7932
SELECT val * 2 FROM t UNION SELECT val / 3.0 FROM t;
-- Tag: cte_cte_test_select_7933
SELECT CEIL(val) FROM t UNION SELECT FLOOR(val) FROM t;
-- Tag: cte_cte_test_select_7934
SELECT val FROM t1 UNION SELECT val FROM t2;
-- Tag: cte_cte_test_select_7935
SELECT a, b FROM t1 UNION SELECT a FROM t2;
-- Tag: cte_cte_test_select_7936
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_7937
SELECT * FROM t3 WHERE threshold < ( SELECT MAX(val) FROM ( SELECT val FROM t1 UNION SELECT val FROM t2 ) AS combined );
-- Tag: cte_cte_test_select_7938
SELECT AVG(val) as avg_val FROM ( SELECT val FROM t1 UNION ALL SELECT val FROM t2 ) AS combined;
-- Tag: cte_cte_test_select_7939
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7940
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7941
SELECT a, b FROM t1 UNION SELECT a, b FROM t2 ORDER BY a;
WITH combined AS ( SELECT val FROM t1 UNION SELECT val FROM t2 ) SELECT * FROM combined ORDER BY val;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (NULL);
INSERT INTO t2 VALUES (2.5), (NULL);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (10);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val FLOAT64);
INSERT INTO t VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t1 VALUES ('hello');
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t1 VALUES (1, 2);
INSERT INTO t2 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (5), (1), (3);
INSERT INTO t2 VALUES (2.5), (4.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (threshold FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);
INSERT INTO t3 VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2), (3);
INSERT INTO t2 VALUES (4.5), (5.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (9007199254740991);
INSERT INTO t2 VALUES (1.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (-5), (0), (5);
INSERT INTO t2 VALUES (-2.5), (0.0), (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a FLOAT64, b STRING);
INSERT INTO t1 VALUES (1, 'foo'), (2, 'bar');
INSERT INTO t2 VALUES (3.5, 'baz');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);

-- Tag: cte_cte_test_select_7942
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7943
SELECT val * 2 FROM t UNION SELECT val / 3.0 FROM t;
-- Tag: cte_cte_test_select_7944
SELECT CEIL(val) FROM t UNION SELECT FLOOR(val) FROM t;
-- Tag: cte_cte_test_select_7945
SELECT val FROM t1 UNION SELECT val FROM t2;
-- Tag: cte_cte_test_select_7946
SELECT a, b FROM t1 UNION SELECT a FROM t2;
-- Tag: cte_cte_test_select_7947
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_7948
SELECT * FROM t3 WHERE threshold < ( SELECT MAX(val) FROM ( SELECT val FROM t1 UNION SELECT val FROM t2 ) AS combined );
-- Tag: cte_cte_test_select_7949
SELECT AVG(val) as avg_val FROM ( SELECT val FROM t1 UNION ALL SELECT val FROM t2 ) AS combined;
-- Tag: cte_cte_test_select_7950
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7951
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7952
SELECT a, b FROM t1 UNION SELECT a, b FROM t2 ORDER BY a;
WITH combined AS ( SELECT val FROM t1 UNION SELECT val FROM t2 ) SELECT * FROM combined ORDER BY val;

DROP TABLE IF EXISTS t;
CREATE TABLE t (val INT64);
INSERT INTO t VALUES (10);
DROP TABLE IF EXISTS t;
CREATE TABLE t (val FLOAT64);
INSERT INTO t VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t1 VALUES ('hello');
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t1 VALUES (1, 2);
INSERT INTO t2 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (5), (1), (3);
INSERT INTO t2 VALUES (2.5), (4.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (threshold FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);
INSERT INTO t3 VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2), (3);
INSERT INTO t2 VALUES (4.5), (5.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (9007199254740991);
INSERT INTO t2 VALUES (1.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (-5), (0), (5);
INSERT INTO t2 VALUES (-2.5), (0.0), (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a FLOAT64, b STRING);
INSERT INTO t1 VALUES (1, 'foo'), (2, 'bar');
INSERT INTO t2 VALUES (3.5, 'baz');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);

-- Tag: cte_cte_test_select_7953
SELECT val * 2 FROM t UNION SELECT val / 3.0 FROM t;
-- Tag: cte_cte_test_select_7954
SELECT CEIL(val) FROM t UNION SELECT FLOOR(val) FROM t;
-- Tag: cte_cte_test_select_7955
SELECT val FROM t1 UNION SELECT val FROM t2;
-- Tag: cte_cte_test_select_7956
SELECT a, b FROM t1 UNION SELECT a FROM t2;
-- Tag: cte_cte_test_select_7957
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_7958
SELECT * FROM t3 WHERE threshold < ( SELECT MAX(val) FROM ( SELECT val FROM t1 UNION SELECT val FROM t2 ) AS combined );
-- Tag: cte_cte_test_select_7959
SELECT AVG(val) as avg_val FROM ( SELECT val FROM t1 UNION ALL SELECT val FROM t2 ) AS combined;
-- Tag: cte_cte_test_select_7960
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7961
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7962
SELECT a, b FROM t1 UNION SELECT a, b FROM t2 ORDER BY a;
WITH combined AS ( SELECT val FROM t1 UNION SELECT val FROM t2 ) SELECT * FROM combined ORDER BY val;

DROP TABLE IF EXISTS t;
CREATE TABLE t (val FLOAT64);
INSERT INTO t VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t1 VALUES ('hello');
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t1 VALUES (1, 2);
INSERT INTO t2 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (5), (1), (3);
INSERT INTO t2 VALUES (2.5), (4.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (threshold FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);
INSERT INTO t3 VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2), (3);
INSERT INTO t2 VALUES (4.5), (5.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (9007199254740991);
INSERT INTO t2 VALUES (1.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (-5), (0), (5);
INSERT INTO t2 VALUES (-2.5), (0.0), (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a FLOAT64, b STRING);
INSERT INTO t1 VALUES (1, 'foo'), (2, 'bar');
INSERT INTO t2 VALUES (3.5, 'baz');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);

-- Tag: cte_cte_test_select_7963
SELECT CEIL(val) FROM t UNION SELECT FLOOR(val) FROM t;
-- Tag: cte_cte_test_select_7964
SELECT val FROM t1 UNION SELECT val FROM t2;
-- Tag: cte_cte_test_select_7965
SELECT a, b FROM t1 UNION SELECT a FROM t2;
-- Tag: cte_cte_test_select_7966
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_7967
SELECT * FROM t3 WHERE threshold < ( SELECT MAX(val) FROM ( SELECT val FROM t1 UNION SELECT val FROM t2 ) AS combined );
-- Tag: cte_cte_test_select_7968
SELECT AVG(val) as avg_val FROM ( SELECT val FROM t1 UNION ALL SELECT val FROM t2 ) AS combined;
-- Tag: cte_cte_test_select_7969
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7970
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7971
SELECT a, b FROM t1 UNION SELECT a, b FROM t2 ORDER BY a;
WITH combined AS ( SELECT val FROM t1 UNION SELECT val FROM t2 ) SELECT * FROM combined ORDER BY val;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val INT64);
INSERT INTO t1 VALUES ('hello');
INSERT INTO t2 VALUES (42);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t1 VALUES (1, 2);
INSERT INTO t2 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (5), (1), (3);
INSERT INTO t2 VALUES (2.5), (4.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (threshold FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);
INSERT INTO t3 VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2), (3);
INSERT INTO t2 VALUES (4.5), (5.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (9007199254740991);
INSERT INTO t2 VALUES (1.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (-5), (0), (5);
INSERT INTO t2 VALUES (-2.5), (0.0), (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a FLOAT64, b STRING);
INSERT INTO t1 VALUES (1, 'foo'), (2, 'bar');
INSERT INTO t2 VALUES (3.5, 'baz');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);

-- Tag: cte_cte_test_select_7972
SELECT val FROM t1 UNION SELECT val FROM t2;
-- Tag: cte_cte_test_select_7973
SELECT a, b FROM t1 UNION SELECT a FROM t2;
-- Tag: cte_cte_test_select_7974
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_7975
SELECT * FROM t3 WHERE threshold < ( SELECT MAX(val) FROM ( SELECT val FROM t1 UNION SELECT val FROM t2 ) AS combined );
-- Tag: cte_cte_test_select_7976
SELECT AVG(val) as avg_val FROM ( SELECT val FROM t1 UNION ALL SELECT val FROM t2 ) AS combined;
-- Tag: cte_cte_test_select_7977
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7978
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7979
SELECT a, b FROM t1 UNION SELECT a, b FROM t2 ORDER BY a;
WITH combined AS ( SELECT val FROM t1 UNION SELECT val FROM t2 ) SELECT * FROM combined ORDER BY val;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a INT64);
INSERT INTO t1 VALUES (1, 2);
INSERT INTO t2 VALUES (3);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (5), (1), (3);
INSERT INTO t2 VALUES (2.5), (4.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (threshold FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);
INSERT INTO t3 VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2), (3);
INSERT INTO t2 VALUES (4.5), (5.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (9007199254740991);
INSERT INTO t2 VALUES (1.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (-5), (0), (5);
INSERT INTO t2 VALUES (-2.5), (0.0), (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a FLOAT64, b STRING);
INSERT INTO t1 VALUES (1, 'foo'), (2, 'bar');
INSERT INTO t2 VALUES (3.5, 'baz');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);

-- Tag: cte_cte_test_select_7980
SELECT a, b FROM t1 UNION SELECT a FROM t2;
-- Tag: cte_cte_test_select_7981
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_7982
SELECT * FROM t3 WHERE threshold < ( SELECT MAX(val) FROM ( SELECT val FROM t1 UNION SELECT val FROM t2 ) AS combined );
-- Tag: cte_cte_test_select_7983
SELECT AVG(val) as avg_val FROM ( SELECT val FROM t1 UNION ALL SELECT val FROM t2 ) AS combined;
-- Tag: cte_cte_test_select_7984
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7985
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7986
SELECT a, b FROM t1 UNION SELECT a, b FROM t2 ORDER BY a;
WITH combined AS ( SELECT val FROM t1 UNION SELECT val FROM t2 ) SELECT * FROM combined ORDER BY val;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (5), (1), (3);
INSERT INTO t2 VALUES (2.5), (4.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (threshold FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);
INSERT INTO t3 VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2), (3);
INSERT INTO t2 VALUES (4.5), (5.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (9007199254740991);
INSERT INTO t2 VALUES (1.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (-5), (0), (5);
INSERT INTO t2 VALUES (-2.5), (0.0), (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a FLOAT64, b STRING);
INSERT INTO t1 VALUES (1, 'foo'), (2, 'bar');
INSERT INTO t2 VALUES (3.5, 'baz');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);

-- Tag: cte_cte_test_select_7987
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val LIMIT 3;
-- Tag: cte_cte_test_select_7988
SELECT * FROM t3 WHERE threshold < ( SELECT MAX(val) FROM ( SELECT val FROM t1 UNION SELECT val FROM t2 ) AS combined );
-- Tag: cte_cte_test_select_7989
SELECT AVG(val) as avg_val FROM ( SELECT val FROM t1 UNION ALL SELECT val FROM t2 ) AS combined;
-- Tag: cte_cte_test_select_7990
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7991
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7992
SELECT a, b FROM t1 UNION SELECT a, b FROM t2 ORDER BY a;
WITH combined AS ( SELECT val FROM t1 UNION SELECT val FROM t2 ) SELECT * FROM combined ORDER BY val;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (threshold FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);
INSERT INTO t3 VALUES (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2), (3);
INSERT INTO t2 VALUES (4.5), (5.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (9007199254740991);
INSERT INTO t2 VALUES (1.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (-5), (0), (5);
INSERT INTO t2 VALUES (-2.5), (0.0), (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a FLOAT64, b STRING);
INSERT INTO t1 VALUES (1, 'foo'), (2, 'bar');
INSERT INTO t2 VALUES (3.5, 'baz');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);

-- Tag: cte_cte_test_select_7993
SELECT * FROM t3 WHERE threshold < ( SELECT MAX(val) FROM ( SELECT val FROM t1 UNION SELECT val FROM t2 ) AS combined );
-- Tag: cte_cte_test_select_7994
SELECT AVG(val) as avg_val FROM ( SELECT val FROM t1 UNION ALL SELECT val FROM t2 ) AS combined;
-- Tag: cte_cte_test_select_7995
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7996
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_7997
SELECT a, b FROM t1 UNION SELECT a, b FROM t2 ORDER BY a;
WITH combined AS ( SELECT val FROM t1 UNION SELECT val FROM t2 ) SELECT * FROM combined ORDER BY val;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2), (3);
INSERT INTO t2 VALUES (4.5), (5.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (9007199254740991);
INSERT INTO t2 VALUES (1.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (-5), (0), (5);
INSERT INTO t2 VALUES (-2.5), (0.0), (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a FLOAT64, b STRING);
INSERT INTO t1 VALUES (1, 'foo'), (2, 'bar');
INSERT INTO t2 VALUES (3.5, 'baz');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);

-- Tag: cte_cte_test_select_7998
SELECT AVG(val) as avg_val FROM ( SELECT val FROM t1 UNION ALL SELECT val FROM t2 ) AS combined;
-- Tag: cte_cte_test_select_7999
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_8000
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_8001
SELECT a, b FROM t1 UNION SELECT a, b FROM t2 ORDER BY a;
WITH combined AS ( SELECT val FROM t1 UNION SELECT val FROM t2 ) SELECT * FROM combined ORDER BY val;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (9007199254740991);
INSERT INTO t2 VALUES (1.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (-5), (0), (5);
INSERT INTO t2 VALUES (-2.5), (0.0), (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a FLOAT64, b STRING);
INSERT INTO t1 VALUES (1, 'foo'), (2, 'bar');
INSERT INTO t2 VALUES (3.5, 'baz');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);

-- Tag: cte_cte_test_select_8002
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_8003
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_8004
SELECT a, b FROM t1 UNION SELECT a, b FROM t2 ORDER BY a;
WITH combined AS ( SELECT val FROM t1 UNION SELECT val FROM t2 ) SELECT * FROM combined ORDER BY val;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (-5), (0), (5);
INSERT INTO t2 VALUES (-2.5), (0.0), (2.5);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a FLOAT64, b STRING);
INSERT INTO t1 VALUES (1, 'foo'), (2, 'bar');
INSERT INTO t2 VALUES (3.5, 'baz');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);

-- Tag: cte_cte_test_select_8005
SELECT val FROM t1 UNION SELECT val FROM t2 ORDER BY val;
-- Tag: cte_cte_test_select_8006
SELECT a, b FROM t1 UNION SELECT a, b FROM t2 ORDER BY a;
WITH combined AS ( SELECT val FROM t1 UNION SELECT val FROM t2 ) SELECT * FROM combined ORDER BY val;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (a INT64, b STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (a FLOAT64, b STRING);
INSERT INTO t1 VALUES (1, 'foo'), (2, 'bar');
INSERT INTO t2 VALUES (3.5, 'baz');
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);

-- Tag: cte_cte_test_select_8007
SELECT a, b FROM t1 UNION SELECT a, b FROM t2 ORDER BY a;
WITH combined AS ( SELECT val FROM t1 UNION SELECT val FROM t2 ) SELECT * FROM combined ORDER BY val;

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (val INT64);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (val FLOAT64);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (3.5);

WITH combined AS ( SELECT val FROM t1 UNION SELECT val FROM t2 ) SELECT * FROM combined ORDER BY val;
