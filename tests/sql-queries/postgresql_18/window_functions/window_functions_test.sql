-- ============================================================================
-- Window Functions - PostgreSQL 18
-- ============================================================================
-- Source: Migrated from complex_integration_scenarios_tdd.rs, date_functions_comprehensive_tdd.rs, delete_enhancements_advanced_tdd.rs, join_based_dml_comprehensive_tdd.rs, materialized_views_comprehensive_tdd.rs, merge_statement_comprehensive_tdd.rs, table_ddl_enhancements_comprehensive_tdd.rs, update_enhancements_advanced_tdd.rs
-- Description: Window function operations
--
-- PostgreSQL: Full support
-- BigQuery: Limited or no support
-- SQL Standard: PostgreSQL 18 specific
-- ============================================================================

DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, month INT64, amount INT64);
INSERT INTO sales VALUES ('A', 1, 100), ('A', 2, 200), ('A', 3, 150);
INSERT INTO sales VALUES ('B', 1, 50), ('B', 2, 60), ('B', 3, 70);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount INT64);
INSERT INTO orders VALUES (1, 1, 100), (2, 2, 200), (3, 1, 150), (4, 3, 50);
DROP TABLE IF EXISTS products;
CREATE TABLE products (name STRING, category STRING, price FLOAT64);
INSERT INTO products VALUES ('Apple', 'Fruit', 1.5), ('APPLE PIE', 'Dessert', 5.0);
INSERT INTO products VALUES ('Banana', 'Fruit', 0.5), ('Orange', 'Fruit', 2.0);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, start_date DATE, end_date DATE);
INSERT INTO events VALUES (1, DATE '2024-01-01', DATE '2024-01-10');
INSERT INTO events VALUES (2, DATE '2024-01-01', DATE '2024-01-31');
INSERT INTO events VALUES (3, DATE '2024-01-01', DATE '2024-02-15');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, date DATE, amount FLOAT64);
INSERT INTO transactions VALUES (1, DATE '2024-01-15', 100.0);
INSERT INTO transactions VALUES (2, DATE '2024-01-20', 150.0);
INSERT INTO transactions VALUES (3, DATE '2024-02-10', 200.0);
INSERT INTO transactions VALUES (4, DATE '2024-02-25', 250.0);
DROP TABLE IF EXISTS shipments;
CREATE TABLE shipments (id INT64, ship_date DATE);
DROP TABLE IF EXISTS deliveries;
CREATE TABLE deliveries (id INT64, delivery_date DATE);
INSERT INTO shipments VALUES (1, DATE '2024-01-01'), (2, DATE '2024-01-10');
INSERT INTO deliveries VALUES (1, DATE '2024-01-08'), (2, DATE '2024-01-15');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, department STRING, salary INT64);
INSERT INTO employees VALUES (1, 'Sales', 50000), (2, 'Sales', 60000), (3, 'Engineering', 80000);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'A', 10.0), (2, 'A', 20.0), (3, 'B', 15.0);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (product STRING, date DATE, price FLOAT64);
INSERT INTO prices VALUES ('A', DATE '2024-01-01', 10.0);
INSERT INTO prices VALUES ('A', DATE '2024-01-15', 15.0);
INSERT INTO prices VALUES ('B', DATE '2024-01-01', 20.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, number INT64);
INSERT INTO data VALUES (1, 12345), (2, 67890), (3, 11111);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount STRING);
INSERT INTO sales VALUES ('A', '100.50'), ('B', '200.75'), ('A', '150.25');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, '10'), (2, '20'), (3, '30'), (4, '40');
DROP TABLE IF EXISTS daily_sales;
CREATE TABLE daily_sales (date DATE, product STRING, amount INT64);
DROP TABLE IF EXISTS monthly_summary;
CREATE TABLE monthly_summary (month INT64, product STRING, total INT64);
INSERT INTO daily_sales VALUES (DATE '2024-01-05', 'A', 100);
INSERT INTO daily_sales VALUES (DATE '2024-01-15', 'A', 150);
INSERT INTO daily_sales VALUES (DATE '2024-02-10', 'A', 200);
INSERT INTO monthly_summary SELECT EXTRACT(MONTH FROM date), product, SUM(amount) FROM daily_sales GROUP BY EXTRACT(MONTH FROM date), product;
DROP TABLE IF EXISTS computed;
CREATE TABLE computed (id INT64, value INT64, squared INT64);
INSERT INTO computed VALUES (1, 5, 5 * 5), (2, 10, 10 * 10), (3, 15, 15 * 15);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, value INT64);
INSERT INTO dest SELECT * FROM source WHERE value > 500 ORDER BY value DESC LIMIT 10;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
ALTER TABLE users ADD COLUMN status STRING DEFAULT 'active';
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 30);
ALTER TABLE data ALTER COLUMN value SET NOT NULL;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount INT64);
ALTER TABLE orders ADD CONSTRAINT check_customer CHECK (customer_id > 0);
ALTER TABLE orders DROP COLUMN customer_id;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, NULL, 100000);
INSERT INTO employees VALUES (2, 1, 80000), (3, 1, 90000);
INSERT INTO employees VALUES (4, 2, 60000), (5, 2, 70000);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, data STRING);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Apple', 1.5), (2, 'Banana', 0.5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('West', 'A', 100), ('West', 'B', 200);
INSERT INTO sales VALUES ('East', 'A', 150), ('East', 'B', 250);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (date DATE, price FLOAT64);
INSERT INTO prices VALUES (DATE '2024-01-01', 10.0);
INSERT INTO prices VALUES (DATE '2024-01-02', 11.0);
INSERT INTO prices VALUES (DATE '2024-01-03', NULL);
INSERT INTO prices VALUES (DATE '2024-01-04', 12.0);
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, user_id INT64, date DATE, amount FLOAT64, category STRING);
INSERT INTO transactions VALUES (1, 1, DATE '2024-01-05', 100.0, 'Food');
INSERT INTO transactions VALUES (2, 1, DATE '2024-01-15', 50.0, 'Transport');
INSERT INTO transactions VALUES (3, 2, DATE '2024-01-10', 200.0, 'Food');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, product STRING, quantity INT64, price FLOAT64);
INSERT INTO orders VALUES (1, 'A', 5, 10.0), (1, 'B', 3, 20.0);
INSERT INTO orders VALUES (2, 'A', 10, 10.0), (2, 'B', 1, 20.0);
DROP TABLE IF EXISTS sales_2023;
CREATE TABLE sales_2023 (product STRING, amount INT64);
DROP TABLE IF EXISTS sales_2024;
CREATE TABLE sales_2024 (product STRING, amount INT64);
INSERT INTO sales_2023 VALUES ('A', 100), ('B', 200);
INSERT INTO sales_2024 VALUES ('A', 150), ('B', 250);

SELECT product, SUM(amount) as total FROM sales GROUP BY product HAVING SUM(amount) BETWEEN 100 AND 500;
SELECT * FROM orders WHERE customer_id IN (SELECT customer_id FROM orders GROUP BY customer_id HAVING COUNT(*) > 1);
SELECT COUNT(*), AVG(price) FROM products WHERE name ILIKE '%apple%';
SELECT * FROM events WHERE DATE_DIFF(end_date, start_date, DAY) BETWEEN 10 AND 40;
SELECT EXTRACT(MONTH FROM date) as month, SUM(amount) as total FROM transactions GROUP BY EXTRACT(MONTH FROM date) ORDER BY month;
SELECT s.id FROM shipments s INNER JOIN deliveries d ON s.id = d.id AND d.delivery_date <= DATE_ADD(s.ship_date, INTERVAL 7 DAY);
SELECT * FROM products WHERE price > ANY (SELECT price FROM products WHERE category = 'A');
SELECT * FROM data WHERE CAST(number AS STRING) LIKE '1%';
SELECT product, SUM(CAST(amount AS FLOAT64)) as total FROM sales GROUP BY product ORDER BY product;
SELECT * FROM data WHERE CAST(value AS INT64) BETWEEN 15 AND 35;
SELECT COUNT(*) FROM monthly_summary;
SELECT * FROM computed ORDER BY id;
SELECT COUNT(*) FROM dest;
SELECT * FROM users WHERE status = 'active';
SELECT * FROM events WHERE JSON_EXTRACT(data, '$.type') = 'click';
SELECT JSON_ARRAYAGG(name) as products FROM products;
SELECT *, RANK() OVER (PARTITION BY region ORDER BY amount DESC) as rank FROM sales;
SELECT date, price, LAG(price, 1, 0.0) OVER (ORDER BY date) as prev_price FROM prices ORDER BY date;
SELECT DISTINCT product FROM prices p1
WHERE (SELECT price FROM prices p2 WHERE p2.product = p1.product ORDER BY date DESC LIMIT 1) BETWEEN 12.0 AND 18.0;

-- ============================================================================
-- Test: test_in_operator_with_aggregation_subquery
-- Source: complex_integration_scenarios_tdd.rs:44
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount INT64);
INSERT INTO orders VALUES (1, 1, 100), (2, 2, 200), (3, 1, 150), (4, 3, 50);
DROP TABLE IF EXISTS products;
CREATE TABLE products (name STRING, category STRING, price FLOAT64);
INSERT INTO products VALUES ('Apple', 'Fruit', 1.5), ('APPLE PIE', 'Dessert', 5.0);
INSERT INTO products VALUES ('Banana', 'Fruit', 0.5), ('Orange', 'Fruit', 2.0);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, start_date DATE, end_date DATE);
INSERT INTO events VALUES (1, DATE '2024-01-01', DATE '2024-01-10');
INSERT INTO events VALUES (2, DATE '2024-01-01', DATE '2024-01-31');
INSERT INTO events VALUES (3, DATE '2024-01-01', DATE '2024-02-15');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, date DATE, amount FLOAT64);
INSERT INTO transactions VALUES (1, DATE '2024-01-15', 100.0);
INSERT INTO transactions VALUES (2, DATE '2024-01-20', 150.0);
INSERT INTO transactions VALUES (3, DATE '2024-02-10', 200.0);
INSERT INTO transactions VALUES (4, DATE '2024-02-25', 250.0);
DROP TABLE IF EXISTS shipments;
CREATE TABLE shipments (id INT64, ship_date DATE);
DROP TABLE IF EXISTS deliveries;
CREATE TABLE deliveries (id INT64, delivery_date DATE);
INSERT INTO shipments VALUES (1, DATE '2024-01-01'), (2, DATE '2024-01-10');
INSERT INTO deliveries VALUES (1, DATE '2024-01-08'), (2, DATE '2024-01-15');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, department STRING, salary INT64);
INSERT INTO employees VALUES (1, 'Sales', 50000), (2, 'Sales', 60000), (3, 'Engineering', 80000);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'A', 10.0), (2, 'A', 20.0), (3, 'B', 15.0);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (product STRING, date DATE, price FLOAT64);
INSERT INTO prices VALUES ('A', DATE '2024-01-01', 10.0);
INSERT INTO prices VALUES ('A', DATE '2024-01-15', 15.0);
INSERT INTO prices VALUES ('B', DATE '2024-01-01', 20.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, number INT64);
INSERT INTO data VALUES (1, 12345), (2, 67890), (3, 11111);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount STRING);
INSERT INTO sales VALUES ('A', '100.50'), ('B', '200.75'), ('A', '150.25');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, '10'), (2, '20'), (3, '30'), (4, '40');
DROP TABLE IF EXISTS daily_sales;
CREATE TABLE daily_sales (date DATE, product STRING, amount INT64);
DROP TABLE IF EXISTS monthly_summary;
CREATE TABLE monthly_summary (month INT64, product STRING, total INT64);
INSERT INTO daily_sales VALUES (DATE '2024-01-05', 'A', 100);
INSERT INTO daily_sales VALUES (DATE '2024-01-15', 'A', 150);
INSERT INTO daily_sales VALUES (DATE '2024-02-10', 'A', 200);
INSERT INTO monthly_summary SELECT EXTRACT(MONTH FROM date), product, SUM(amount) FROM daily_sales GROUP BY EXTRACT(MONTH FROM date), product;
DROP TABLE IF EXISTS computed;
CREATE TABLE computed (id INT64, value INT64, squared INT64);
INSERT INTO computed VALUES (1, 5, 5 * 5), (2, 10, 10 * 10), (3, 15, 15 * 15);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, value INT64);
INSERT INTO dest SELECT * FROM source WHERE value > 500 ORDER BY value DESC LIMIT 10;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
ALTER TABLE users ADD COLUMN status STRING DEFAULT 'active';
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 30);
ALTER TABLE data ALTER COLUMN value SET NOT NULL;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount INT64);
ALTER TABLE orders ADD CONSTRAINT check_customer CHECK (customer_id > 0);
ALTER TABLE orders DROP COLUMN customer_id;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, NULL, 100000);
INSERT INTO employees VALUES (2, 1, 80000), (3, 1, 90000);
INSERT INTO employees VALUES (4, 2, 60000), (5, 2, 70000);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, data STRING);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Apple', 1.5), (2, 'Banana', 0.5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('West', 'A', 100), ('West', 'B', 200);
INSERT INTO sales VALUES ('East', 'A', 150), ('East', 'B', 250);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (date DATE, price FLOAT64);
INSERT INTO prices VALUES (DATE '2024-01-01', 10.0);
INSERT INTO prices VALUES (DATE '2024-01-02', 11.0);
INSERT INTO prices VALUES (DATE '2024-01-03', NULL);
INSERT INTO prices VALUES (DATE '2024-01-04', 12.0);
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, user_id INT64, date DATE, amount FLOAT64, category STRING);
INSERT INTO transactions VALUES (1, 1, DATE '2024-01-05', 100.0, 'Food');
INSERT INTO transactions VALUES (2, 1, DATE '2024-01-15', 50.0, 'Transport');
INSERT INTO transactions VALUES (3, 2, DATE '2024-01-10', 200.0, 'Food');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, product STRING, quantity INT64, price FLOAT64);
INSERT INTO orders VALUES (1, 'A', 5, 10.0), (1, 'B', 3, 20.0);
INSERT INTO orders VALUES (2, 'A', 10, 10.0), (2, 'B', 1, 20.0);
DROP TABLE IF EXISTS sales_2023;
CREATE TABLE sales_2023 (product STRING, amount INT64);
DROP TABLE IF EXISTS sales_2024;
CREATE TABLE sales_2024 (product STRING, amount INT64);
INSERT INTO sales_2023 VALUES ('A', 100), ('B', 200);
INSERT INTO sales_2024 VALUES ('A', 150), ('B', 250);

SELECT * FROM orders WHERE customer_id IN (SELECT customer_id FROM orders GROUP BY customer_id HAVING COUNT(*) > 1);
SELECT COUNT(*), AVG(price) FROM products WHERE name ILIKE '%apple%';
SELECT * FROM events WHERE DATE_DIFF(end_date, start_date, DAY) BETWEEN 10 AND 40;
SELECT EXTRACT(MONTH FROM date) as month, SUM(amount) as total FROM transactions GROUP BY EXTRACT(MONTH FROM date) ORDER BY month;
SELECT s.id FROM shipments s INNER JOIN deliveries d ON s.id = d.id AND d.delivery_date <= DATE_ADD(s.ship_date, INTERVAL 7 DAY);
SELECT * FROM products WHERE price > ANY (SELECT price FROM products WHERE category = 'A');
SELECT * FROM data WHERE CAST(number AS STRING) LIKE '1%';
SELECT product, SUM(CAST(amount AS FLOAT64)) as total FROM sales GROUP BY product ORDER BY product;
SELECT * FROM data WHERE CAST(value AS INT64) BETWEEN 15 AND 35;
SELECT COUNT(*) FROM monthly_summary;
SELECT * FROM computed ORDER BY id;
SELECT COUNT(*) FROM dest;
SELECT * FROM users WHERE status = 'active';
SELECT * FROM events WHERE JSON_EXTRACT(data, '$.type') = 'click';
SELECT JSON_ARRAYAGG(name) as products FROM products;
SELECT *, RANK() OVER (PARTITION BY region ORDER BY amount DESC) as rank FROM sales;
SELECT date, price, LAG(price, 1, 0.0) OVER (ORDER BY date) as prev_price FROM prices ORDER BY date;
SELECT DISTINCT product FROM prices p1
WHERE (SELECT price FROM prices p2 WHERE p2.product = p1.product ORDER BY date DESC LIMIT 1) BETWEEN 12.0 AND 18.0;

-- ============================================================================
-- Test: test_like_with_case_insensitive_aggregation
-- Source: complex_integration_scenarios_tdd.rs:64
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (name STRING, category STRING, price FLOAT64);
INSERT INTO products VALUES ('Apple', 'Fruit', 1.5), ('APPLE PIE', 'Dessert', 5.0);
INSERT INTO products VALUES ('Banana', 'Fruit', 0.5), ('Orange', 'Fruit', 2.0);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, start_date DATE, end_date DATE);
INSERT INTO events VALUES (1, DATE '2024-01-01', DATE '2024-01-10');
INSERT INTO events VALUES (2, DATE '2024-01-01', DATE '2024-01-31');
INSERT INTO events VALUES (3, DATE '2024-01-01', DATE '2024-02-15');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, date DATE, amount FLOAT64);
INSERT INTO transactions VALUES (1, DATE '2024-01-15', 100.0);
INSERT INTO transactions VALUES (2, DATE '2024-01-20', 150.0);
INSERT INTO transactions VALUES (3, DATE '2024-02-10', 200.0);
INSERT INTO transactions VALUES (4, DATE '2024-02-25', 250.0);
DROP TABLE IF EXISTS shipments;
CREATE TABLE shipments (id INT64, ship_date DATE);
DROP TABLE IF EXISTS deliveries;
CREATE TABLE deliveries (id INT64, delivery_date DATE);
INSERT INTO shipments VALUES (1, DATE '2024-01-01'), (2, DATE '2024-01-10');
INSERT INTO deliveries VALUES (1, DATE '2024-01-08'), (2, DATE '2024-01-15');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, department STRING, salary INT64);
INSERT INTO employees VALUES (1, 'Sales', 50000), (2, 'Sales', 60000), (3, 'Engineering', 80000);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'A', 10.0), (2, 'A', 20.0), (3, 'B', 15.0);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (product STRING, date DATE, price FLOAT64);
INSERT INTO prices VALUES ('A', DATE '2024-01-01', 10.0);
INSERT INTO prices VALUES ('A', DATE '2024-01-15', 15.0);
INSERT INTO prices VALUES ('B', DATE '2024-01-01', 20.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, number INT64);
INSERT INTO data VALUES (1, 12345), (2, 67890), (3, 11111);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount STRING);
INSERT INTO sales VALUES ('A', '100.50'), ('B', '200.75'), ('A', '150.25');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, '10'), (2, '20'), (3, '30'), (4, '40');
DROP TABLE IF EXISTS daily_sales;
CREATE TABLE daily_sales (date DATE, product STRING, amount INT64);
DROP TABLE IF EXISTS monthly_summary;
CREATE TABLE monthly_summary (month INT64, product STRING, total INT64);
INSERT INTO daily_sales VALUES (DATE '2024-01-05', 'A', 100);
INSERT INTO daily_sales VALUES (DATE '2024-01-15', 'A', 150);
INSERT INTO daily_sales VALUES (DATE '2024-02-10', 'A', 200);
INSERT INTO monthly_summary SELECT EXTRACT(MONTH FROM date), product, SUM(amount) FROM daily_sales GROUP BY EXTRACT(MONTH FROM date), product;
DROP TABLE IF EXISTS computed;
CREATE TABLE computed (id INT64, value INT64, squared INT64);
INSERT INTO computed VALUES (1, 5, 5 * 5), (2, 10, 10 * 10), (3, 15, 15 * 15);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, value INT64);
INSERT INTO dest SELECT * FROM source WHERE value > 500 ORDER BY value DESC LIMIT 10;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
ALTER TABLE users ADD COLUMN status STRING DEFAULT 'active';
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 30);
ALTER TABLE data ALTER COLUMN value SET NOT NULL;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount INT64);
ALTER TABLE orders ADD CONSTRAINT check_customer CHECK (customer_id > 0);
ALTER TABLE orders DROP COLUMN customer_id;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, NULL, 100000);
INSERT INTO employees VALUES (2, 1, 80000), (3, 1, 90000);
INSERT INTO employees VALUES (4, 2, 60000), (5, 2, 70000);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, data STRING);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Apple', 1.5), (2, 'Banana', 0.5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('West', 'A', 100), ('West', 'B', 200);
INSERT INTO sales VALUES ('East', 'A', 150), ('East', 'B', 250);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (date DATE, price FLOAT64);
INSERT INTO prices VALUES (DATE '2024-01-01', 10.0);
INSERT INTO prices VALUES (DATE '2024-01-02', 11.0);
INSERT INTO prices VALUES (DATE '2024-01-03', NULL);
INSERT INTO prices VALUES (DATE '2024-01-04', 12.0);
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, user_id INT64, date DATE, amount FLOAT64, category STRING);
INSERT INTO transactions VALUES (1, 1, DATE '2024-01-05', 100.0, 'Food');
INSERT INTO transactions VALUES (2, 1, DATE '2024-01-15', 50.0, 'Transport');
INSERT INTO transactions VALUES (3, 2, DATE '2024-01-10', 200.0, 'Food');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, product STRING, quantity INT64, price FLOAT64);
INSERT INTO orders VALUES (1, 'A', 5, 10.0), (1, 'B', 3, 20.0);
INSERT INTO orders VALUES (2, 'A', 10, 10.0), (2, 'B', 1, 20.0);
DROP TABLE IF EXISTS sales_2023;
CREATE TABLE sales_2023 (product STRING, amount INT64);
DROP TABLE IF EXISTS sales_2024;
CREATE TABLE sales_2024 (product STRING, amount INT64);
INSERT INTO sales_2023 VALUES ('A', 100), ('B', 200);
INSERT INTO sales_2024 VALUES ('A', 150), ('B', 250);

SELECT COUNT(*), AVG(price) FROM products WHERE name ILIKE '%apple%';
SELECT * FROM events WHERE DATE_DIFF(end_date, start_date, DAY) BETWEEN 10 AND 40;
SELECT EXTRACT(MONTH FROM date) as month, SUM(amount) as total FROM transactions GROUP BY EXTRACT(MONTH FROM date) ORDER BY month;
SELECT s.id FROM shipments s INNER JOIN deliveries d ON s.id = d.id AND d.delivery_date <= DATE_ADD(s.ship_date, INTERVAL 7 DAY);
SELECT * FROM products WHERE price > ANY (SELECT price FROM products WHERE category = 'A');
SELECT * FROM data WHERE CAST(number AS STRING) LIKE '1%';
SELECT product, SUM(CAST(amount AS FLOAT64)) as total FROM sales GROUP BY product ORDER BY product;
SELECT * FROM data WHERE CAST(value AS INT64) BETWEEN 15 AND 35;
SELECT COUNT(*) FROM monthly_summary;
SELECT * FROM computed ORDER BY id;
SELECT COUNT(*) FROM dest;
SELECT * FROM users WHERE status = 'active';
SELECT * FROM events WHERE JSON_EXTRACT(data, '$.type') = 'click';
SELECT JSON_ARRAYAGG(name) as products FROM products;
SELECT *, RANK() OVER (PARTITION BY region ORDER BY amount DESC) as rank FROM sales;
SELECT date, price, LAG(price, 1, 0.0) OVER (ORDER BY date) as prev_price FROM prices ORDER BY date;
SELECT DISTINCT product FROM prices p1
WHERE (SELECT price FROM prices p2 WHERE p2.product = p1.product ORDER BY date DESC LIMIT 1) BETWEEN 12.0 AND 18.0;

-- ============================================================================
-- Test: test_date_diff_with_between
-- Source: complex_integration_scenarios_tdd.rs:95
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, start_date DATE, end_date DATE);
INSERT INTO events VALUES (1, DATE '2024-01-01', DATE '2024-01-10');
INSERT INTO events VALUES (2, DATE '2024-01-01', DATE '2024-01-31');
INSERT INTO events VALUES (3, DATE '2024-01-01', DATE '2024-02-15');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, date DATE, amount FLOAT64);
INSERT INTO transactions VALUES (1, DATE '2024-01-15', 100.0);
INSERT INTO transactions VALUES (2, DATE '2024-01-20', 150.0);
INSERT INTO transactions VALUES (3, DATE '2024-02-10', 200.0);
INSERT INTO transactions VALUES (4, DATE '2024-02-25', 250.0);
DROP TABLE IF EXISTS shipments;
CREATE TABLE shipments (id INT64, ship_date DATE);
DROP TABLE IF EXISTS deliveries;
CREATE TABLE deliveries (id INT64, delivery_date DATE);
INSERT INTO shipments VALUES (1, DATE '2024-01-01'), (2, DATE '2024-01-10');
INSERT INTO deliveries VALUES (1, DATE '2024-01-08'), (2, DATE '2024-01-15');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, department STRING, salary INT64);
INSERT INTO employees VALUES (1, 'Sales', 50000), (2, 'Sales', 60000), (3, 'Engineering', 80000);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'A', 10.0), (2, 'A', 20.0), (3, 'B', 15.0);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (product STRING, date DATE, price FLOAT64);
INSERT INTO prices VALUES ('A', DATE '2024-01-01', 10.0);
INSERT INTO prices VALUES ('A', DATE '2024-01-15', 15.0);
INSERT INTO prices VALUES ('B', DATE '2024-01-01', 20.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, number INT64);
INSERT INTO data VALUES (1, 12345), (2, 67890), (3, 11111);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount STRING);
INSERT INTO sales VALUES ('A', '100.50'), ('B', '200.75'), ('A', '150.25');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, '10'), (2, '20'), (3, '30'), (4, '40');
DROP TABLE IF EXISTS daily_sales;
CREATE TABLE daily_sales (date DATE, product STRING, amount INT64);
DROP TABLE IF EXISTS monthly_summary;
CREATE TABLE monthly_summary (month INT64, product STRING, total INT64);
INSERT INTO daily_sales VALUES (DATE '2024-01-05', 'A', 100);
INSERT INTO daily_sales VALUES (DATE '2024-01-15', 'A', 150);
INSERT INTO daily_sales VALUES (DATE '2024-02-10', 'A', 200);
INSERT INTO monthly_summary SELECT EXTRACT(MONTH FROM date), product, SUM(amount) FROM daily_sales GROUP BY EXTRACT(MONTH FROM date), product;
DROP TABLE IF EXISTS computed;
CREATE TABLE computed (id INT64, value INT64, squared INT64);
INSERT INTO computed VALUES (1, 5, 5 * 5), (2, 10, 10 * 10), (3, 15, 15 * 15);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, value INT64);
INSERT INTO dest SELECT * FROM source WHERE value > 500 ORDER BY value DESC LIMIT 10;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
ALTER TABLE users ADD COLUMN status STRING DEFAULT 'active';
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 30);
ALTER TABLE data ALTER COLUMN value SET NOT NULL;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount INT64);
ALTER TABLE orders ADD CONSTRAINT check_customer CHECK (customer_id > 0);
ALTER TABLE orders DROP COLUMN customer_id;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, NULL, 100000);
INSERT INTO employees VALUES (2, 1, 80000), (3, 1, 90000);
INSERT INTO employees VALUES (4, 2, 60000), (5, 2, 70000);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, data STRING);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Apple', 1.5), (2, 'Banana', 0.5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('West', 'A', 100), ('West', 'B', 200);
INSERT INTO sales VALUES ('East', 'A', 150), ('East', 'B', 250);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (date DATE, price FLOAT64);
INSERT INTO prices VALUES (DATE '2024-01-01', 10.0);
INSERT INTO prices VALUES (DATE '2024-01-02', 11.0);
INSERT INTO prices VALUES (DATE '2024-01-03', NULL);
INSERT INTO prices VALUES (DATE '2024-01-04', 12.0);
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, user_id INT64, date DATE, amount FLOAT64, category STRING);
INSERT INTO transactions VALUES (1, 1, DATE '2024-01-05', 100.0, 'Food');
INSERT INTO transactions VALUES (2, 1, DATE '2024-01-15', 50.0, 'Transport');
INSERT INTO transactions VALUES (3, 2, DATE '2024-01-10', 200.0, 'Food');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, product STRING, quantity INT64, price FLOAT64);
INSERT INTO orders VALUES (1, 'A', 5, 10.0), (1, 'B', 3, 20.0);
INSERT INTO orders VALUES (2, 'A', 10, 10.0), (2, 'B', 1, 20.0);
DROP TABLE IF EXISTS sales_2023;
CREATE TABLE sales_2023 (product STRING, amount INT64);
DROP TABLE IF EXISTS sales_2024;
CREATE TABLE sales_2024 (product STRING, amount INT64);
INSERT INTO sales_2023 VALUES ('A', 100), ('B', 200);
INSERT INTO sales_2024 VALUES ('A', 150), ('B', 250);

SELECT * FROM events WHERE DATE_DIFF(end_date, start_date, DAY) BETWEEN 10 AND 40;
SELECT EXTRACT(MONTH FROM date) as month, SUM(amount) as total FROM transactions GROUP BY EXTRACT(MONTH FROM date) ORDER BY month;
SELECT s.id FROM shipments s INNER JOIN deliveries d ON s.id = d.id AND d.delivery_date <= DATE_ADD(s.ship_date, INTERVAL 7 DAY);
SELECT * FROM products WHERE price > ANY (SELECT price FROM products WHERE category = 'A');
SELECT * FROM data WHERE CAST(number AS STRING) LIKE '1%';
SELECT product, SUM(CAST(amount AS FLOAT64)) as total FROM sales GROUP BY product ORDER BY product;
SELECT * FROM data WHERE CAST(value AS INT64) BETWEEN 15 AND 35;
SELECT COUNT(*) FROM monthly_summary;
SELECT * FROM computed ORDER BY id;
SELECT COUNT(*) FROM dest;
SELECT * FROM users WHERE status = 'active';
SELECT * FROM events WHERE JSON_EXTRACT(data, '$.type') = 'click';
SELECT JSON_ARRAYAGG(name) as products FROM products;
SELECT *, RANK() OVER (PARTITION BY region ORDER BY amount DESC) as rank FROM sales;
SELECT date, price, LAG(price, 1, 0.0) OVER (ORDER BY date) as prev_price FROM prices ORDER BY date;
SELECT DISTINCT product FROM prices p1
WHERE (SELECT price FROM prices p2 WHERE p2.product = p1.product ORDER BY date DESC LIMIT 1) BETWEEN 12.0 AND 18.0;

-- ============================================================================
-- Test: test_extract_in_group_by_with_aggregation
-- Source: complex_integration_scenarios_tdd.rs:123
-- ============================================================================
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, date DATE, amount FLOAT64);
INSERT INTO transactions VALUES (1, DATE '2024-01-15', 100.0);
INSERT INTO transactions VALUES (2, DATE '2024-01-20', 150.0);
INSERT INTO transactions VALUES (3, DATE '2024-02-10', 200.0);
INSERT INTO transactions VALUES (4, DATE '2024-02-25', 250.0);
DROP TABLE IF EXISTS shipments;
CREATE TABLE shipments (id INT64, ship_date DATE);
DROP TABLE IF EXISTS deliveries;
CREATE TABLE deliveries (id INT64, delivery_date DATE);
INSERT INTO shipments VALUES (1, DATE '2024-01-01'), (2, DATE '2024-01-10');
INSERT INTO deliveries VALUES (1, DATE '2024-01-08'), (2, DATE '2024-01-15');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, department STRING, salary INT64);
INSERT INTO employees VALUES (1, 'Sales', 50000), (2, 'Sales', 60000), (3, 'Engineering', 80000);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'A', 10.0), (2, 'A', 20.0), (3, 'B', 15.0);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (product STRING, date DATE, price FLOAT64);
INSERT INTO prices VALUES ('A', DATE '2024-01-01', 10.0);
INSERT INTO prices VALUES ('A', DATE '2024-01-15', 15.0);
INSERT INTO prices VALUES ('B', DATE '2024-01-01', 20.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, number INT64);
INSERT INTO data VALUES (1, 12345), (2, 67890), (3, 11111);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount STRING);
INSERT INTO sales VALUES ('A', '100.50'), ('B', '200.75'), ('A', '150.25');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, '10'), (2, '20'), (3, '30'), (4, '40');
DROP TABLE IF EXISTS daily_sales;
CREATE TABLE daily_sales (date DATE, product STRING, amount INT64);
DROP TABLE IF EXISTS monthly_summary;
CREATE TABLE monthly_summary (month INT64, product STRING, total INT64);
INSERT INTO daily_sales VALUES (DATE '2024-01-05', 'A', 100);
INSERT INTO daily_sales VALUES (DATE '2024-01-15', 'A', 150);
INSERT INTO daily_sales VALUES (DATE '2024-02-10', 'A', 200);
INSERT INTO monthly_summary SELECT EXTRACT(MONTH FROM date), product, SUM(amount) FROM daily_sales GROUP BY EXTRACT(MONTH FROM date), product;
DROP TABLE IF EXISTS computed;
CREATE TABLE computed (id INT64, value INT64, squared INT64);
INSERT INTO computed VALUES (1, 5, 5 * 5), (2, 10, 10 * 10), (3, 15, 15 * 15);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, value INT64);
INSERT INTO dest SELECT * FROM source WHERE value > 500 ORDER BY value DESC LIMIT 10;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
ALTER TABLE users ADD COLUMN status STRING DEFAULT 'active';
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 30);
ALTER TABLE data ALTER COLUMN value SET NOT NULL;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount INT64);
ALTER TABLE orders ADD CONSTRAINT check_customer CHECK (customer_id > 0);
ALTER TABLE orders DROP COLUMN customer_id;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, NULL, 100000);
INSERT INTO employees VALUES (2, 1, 80000), (3, 1, 90000);
INSERT INTO employees VALUES (4, 2, 60000), (5, 2, 70000);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, data STRING);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Apple', 1.5), (2, 'Banana', 0.5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('West', 'A', 100), ('West', 'B', 200);
INSERT INTO sales VALUES ('East', 'A', 150), ('East', 'B', 250);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (date DATE, price FLOAT64);
INSERT INTO prices VALUES (DATE '2024-01-01', 10.0);
INSERT INTO prices VALUES (DATE '2024-01-02', 11.0);
INSERT INTO prices VALUES (DATE '2024-01-03', NULL);
INSERT INTO prices VALUES (DATE '2024-01-04', 12.0);
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, user_id INT64, date DATE, amount FLOAT64, category STRING);
INSERT INTO transactions VALUES (1, 1, DATE '2024-01-05', 100.0, 'Food');
INSERT INTO transactions VALUES (2, 1, DATE '2024-01-15', 50.0, 'Transport');
INSERT INTO transactions VALUES (3, 2, DATE '2024-01-10', 200.0, 'Food');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, product STRING, quantity INT64, price FLOAT64);
INSERT INTO orders VALUES (1, 'A', 5, 10.0), (1, 'B', 3, 20.0);
INSERT INTO orders VALUES (2, 'A', 10, 10.0), (2, 'B', 1, 20.0);
DROP TABLE IF EXISTS sales_2023;
CREATE TABLE sales_2023 (product STRING, amount INT64);
DROP TABLE IF EXISTS sales_2024;
CREATE TABLE sales_2024 (product STRING, amount INT64);
INSERT INTO sales_2023 VALUES ('A', 100), ('B', 200);
INSERT INTO sales_2024 VALUES ('A', 150), ('B', 250);

SELECT EXTRACT(MONTH FROM date) as month, SUM(amount) as total FROM transactions GROUP BY EXTRACT(MONTH FROM date) ORDER BY month;
SELECT s.id FROM shipments s INNER JOIN deliveries d ON s.id = d.id AND d.delivery_date <= DATE_ADD(s.ship_date, INTERVAL 7 DAY);
SELECT * FROM products WHERE price > ANY (SELECT price FROM products WHERE category = 'A');
SELECT * FROM data WHERE CAST(number AS STRING) LIKE '1%';
SELECT product, SUM(CAST(amount AS FLOAT64)) as total FROM sales GROUP BY product ORDER BY product;
SELECT * FROM data WHERE CAST(value AS INT64) BETWEEN 15 AND 35;
SELECT COUNT(*) FROM monthly_summary;
SELECT * FROM computed ORDER BY id;
SELECT COUNT(*) FROM dest;
SELECT * FROM users WHERE status = 'active';
SELECT * FROM events WHERE JSON_EXTRACT(data, '$.type') = 'click';
SELECT JSON_ARRAYAGG(name) as products FROM products;
SELECT *, RANK() OVER (PARTITION BY region ORDER BY amount DESC) as rank FROM sales;
SELECT date, price, LAG(price, 1, 0.0) OVER (ORDER BY date) as prev_price FROM prices ORDER BY date;
SELECT DISTINCT product FROM prices p1
WHERE (SELECT price FROM prices p2 WHERE p2.product = p1.product ORDER BY date DESC LIMIT 1) BETWEEN 12.0 AND 18.0;

-- ============================================================================
-- Test: test_date_add_in_join_condition
-- Source: complex_integration_scenarios_tdd.rs:152
-- ============================================================================
DROP TABLE IF EXISTS shipments;
CREATE TABLE shipments (id INT64, ship_date DATE);
DROP TABLE IF EXISTS deliveries;
CREATE TABLE deliveries (id INT64, delivery_date DATE);
INSERT INTO shipments VALUES (1, DATE '2024-01-01'), (2, DATE '2024-01-10');
INSERT INTO deliveries VALUES (1, DATE '2024-01-08'), (2, DATE '2024-01-15');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, department STRING, salary INT64);
INSERT INTO employees VALUES (1, 'Sales', 50000), (2, 'Sales', 60000), (3, 'Engineering', 80000);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'A', 10.0), (2, 'A', 20.0), (3, 'B', 15.0);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (product STRING, date DATE, price FLOAT64);
INSERT INTO prices VALUES ('A', DATE '2024-01-01', 10.0);
INSERT INTO prices VALUES ('A', DATE '2024-01-15', 15.0);
INSERT INTO prices VALUES ('B', DATE '2024-01-01', 20.0);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, number INT64);
INSERT INTO data VALUES (1, 12345), (2, 67890), (3, 11111);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount STRING);
INSERT INTO sales VALUES ('A', '100.50'), ('B', '200.75'), ('A', '150.25');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, '10'), (2, '20'), (3, '30'), (4, '40');
DROP TABLE IF EXISTS daily_sales;
CREATE TABLE daily_sales (date DATE, product STRING, amount INT64);
DROP TABLE IF EXISTS monthly_summary;
CREATE TABLE monthly_summary (month INT64, product STRING, total INT64);
INSERT INTO daily_sales VALUES (DATE '2024-01-05', 'A', 100);
INSERT INTO daily_sales VALUES (DATE '2024-01-15', 'A', 150);
INSERT INTO daily_sales VALUES (DATE '2024-02-10', 'A', 200);
INSERT INTO monthly_summary SELECT EXTRACT(MONTH FROM date), product, SUM(amount) FROM daily_sales GROUP BY EXTRACT(MONTH FROM date), product;
DROP TABLE IF EXISTS computed;
CREATE TABLE computed (id INT64, value INT64, squared INT64);
INSERT INTO computed VALUES (1, 5, 5 * 5), (2, 10, 10 * 10), (3, 15, 15 * 15);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, value INT64);
INSERT INTO dest SELECT * FROM source WHERE value > 500 ORDER BY value DESC LIMIT 10;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
ALTER TABLE users ADD COLUMN status STRING DEFAULT 'active';
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, NULL), (3, 30);
ALTER TABLE data ALTER COLUMN value SET NOT NULL;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount INT64);
ALTER TABLE orders ADD CONSTRAINT check_customer CHECK (customer_id > 0);
ALTER TABLE orders DROP COLUMN customer_id;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, manager_id INT64, salary INT64);
INSERT INTO employees VALUES (1, NULL, 100000);
INSERT INTO employees VALUES (2, 1, 80000), (3, 1, 90000);
INSERT INTO employees VALUES (4, 2, 60000), (5, 2, 70000);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, data STRING);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Apple', 1.5), (2, 'Banana', 0.5);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, product STRING, amount INT64);
INSERT INTO sales VALUES ('West', 'A', 100), ('West', 'B', 200);
INSERT INTO sales VALUES ('East', 'A', 150), ('East', 'B', 250);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (date DATE, price FLOAT64);
INSERT INTO prices VALUES (DATE '2024-01-01', 10.0);
INSERT INTO prices VALUES (DATE '2024-01-02', 11.0);
INSERT INTO prices VALUES (DATE '2024-01-03', NULL);
INSERT INTO prices VALUES (DATE '2024-01-04', 12.0);
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, user_id INT64, date DATE, amount FLOAT64, category STRING);
INSERT INTO transactions VALUES (1, 1, DATE '2024-01-05', 100.0, 'Food');
INSERT INTO transactions VALUES (2, 1, DATE '2024-01-15', 50.0, 'Transport');
INSERT INTO transactions VALUES (3, 2, DATE '2024-01-10', 200.0, 'Food');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (customer_id INT64, product STRING, quantity INT64, price FLOAT64);
INSERT INTO orders VALUES (1, 'A', 5, 10.0), (1, 'B', 3, 20.0);
INSERT INTO orders VALUES (2, 'A', 10, 10.0), (2, 'B', 1, 20.0);
DROP TABLE IF EXISTS sales_2023;
CREATE TABLE sales_2023 (product STRING, amount INT64);
DROP TABLE IF EXISTS sales_2024;
CREATE TABLE sales_2024 (product STRING, amount INT64);
INSERT INTO sales_2023 VALUES ('A', 100), ('B', 200);
INSERT INTO sales_2024 VALUES ('A', 150), ('B', 250);

SELECT s.id FROM shipments s INNER JOIN deliveries d ON s.id = d.id AND d.delivery_date <= DATE_ADD(s.ship_date, INTERVAL 7 DAY);
SELECT * FROM products WHERE price > ANY (SELECT price FROM products WHERE category = 'A');
SELECT * FROM data WHERE CAST(number AS STRING) LIKE '1%';
SELECT product, SUM(CAST(amount AS FLOAT64)) as total FROM sales GROUP BY product ORDER BY product;
SELECT * FROM data WHERE CAST(value AS INT64) BETWEEN 15 AND 35;
SELECT COUNT(*) FROM monthly_summary;
SELECT * FROM computed ORDER BY id;
SELECT COUNT(*) FROM dest;
SELECT * FROM users WHERE status = 'active';
SELECT * FROM events WHERE JSON_EXTRACT(data, '$.type') = 'click';
SELECT JSON_ARRAYAGG(name) as products FROM products;
SELECT *, RANK() OVER (PARTITION BY region ORDER BY amount DESC) as rank FROM sales;
SELECT date, price, LAG(price, 1, 0.0) OVER (ORDER BY date) as prev_price FROM prices ORDER BY date;
SELECT DISTINCT product FROM prices p1
WHERE (SELECT price FROM prices p2 WHERE p2.product = p1.product ORDER BY date DESC LIMIT 1) BETWEEN 12.0 AND 18.0;

-- ============================================================================
-- Test: test_date_add_basic_days
-- Source: date_functions_comprehensive_tdd.rs:108
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-10'), (2, '2024-01-20'), (3, '2024-01-30');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_ADD(NULL, INTERVAL 5 DAY) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 5 DAY) as result;
SELECT DATE_SUB('2024-01-05', INTERVAL 10 DAY) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 5 HOUR) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 45 MINUTE) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 90 SECOND) as result;
SELECT id FROM events WHERE DATE_ADD(event_date, INTERVAL 5 DAY) > '2024-01-25';
SELECT DATE_DIFF('2024-01-20', '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-20', DAY) as result;
SELECT DATE_DIFF('2024-06-15', '2024-01-15', MONTH) as result;
SELECT DATE_DIFF('2027-01-15', '2024-01-15', YEAR) as result;
SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_add_basic_months
-- Source: date_functions_comprehensive_tdd.rs:119
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-10'), (2, '2024-01-20'), (3, '2024-01-30');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_ADD(NULL, INTERVAL 5 DAY) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 5 DAY) as result;
SELECT DATE_SUB('2024-01-05', INTERVAL 10 DAY) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 5 HOUR) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 45 MINUTE) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 90 SECOND) as result;
SELECT id FROM events WHERE DATE_ADD(event_date, INTERVAL 5 DAY) > '2024-01-25';
SELECT DATE_DIFF('2024-01-20', '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-20', DAY) as result;
SELECT DATE_DIFF('2024-06-15', '2024-01-15', MONTH) as result;
SELECT DATE_DIFF('2027-01-15', '2024-01-15', YEAR) as result;
SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_add_basic_years
-- Source: date_functions_comprehensive_tdd.rs:130
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-10'), (2, '2024-01-20'), (3, '2024-01-30');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_ADD(NULL, INTERVAL 5 DAY) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 5 DAY) as result;
SELECT DATE_SUB('2024-01-05', INTERVAL 10 DAY) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 5 HOUR) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 45 MINUTE) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 90 SECOND) as result;
SELECT id FROM events WHERE DATE_ADD(event_date, INTERVAL 5 DAY) > '2024-01-25';
SELECT DATE_DIFF('2024-01-20', '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-20', DAY) as result;
SELECT DATE_DIFF('2024-06-15', '2024-01-15', MONTH) as result;
SELECT DATE_DIFF('2027-01-15', '2024-01-15', YEAR) as result;
SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_add_leap_year_edge_case
-- Source: date_functions_comprehensive_tdd.rs:141
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-10'), (2, '2024-01-20'), (3, '2024-01-30');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_ADD(NULL, INTERVAL 5 DAY) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 5 DAY) as result;
SELECT DATE_SUB('2024-01-05', INTERVAL 10 DAY) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 5 HOUR) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 45 MINUTE) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 90 SECOND) as result;
SELECT id FROM events WHERE DATE_ADD(event_date, INTERVAL 5 DAY) > '2024-01-25';
SELECT DATE_DIFF('2024-01-20', '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-20', DAY) as result;
SELECT DATE_DIFF('2024-06-15', '2024-01-15', MONTH) as result;
SELECT DATE_DIFF('2027-01-15', '2024-01-15', YEAR) as result;
SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_add_month_overflow
-- Source: date_functions_comprehensive_tdd.rs:156
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-10'), (2, '2024-01-20'), (3, '2024-01-30');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_ADD(NULL, INTERVAL 5 DAY) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 5 DAY) as result;
SELECT DATE_SUB('2024-01-05', INTERVAL 10 DAY) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 5 HOUR) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 45 MINUTE) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 90 SECOND) as result;
SELECT id FROM events WHERE DATE_ADD(event_date, INTERVAL 5 DAY) > '2024-01-25';
SELECT DATE_DIFF('2024-01-20', '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-20', DAY) as result;
SELECT DATE_DIFF('2024-06-15', '2024-01-15', MONTH) as result;
SELECT DATE_DIFF('2027-01-15', '2024-01-15', YEAR) as result;
SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_add_negative_interval
-- Source: date_functions_comprehensive_tdd.rs:171
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-10'), (2, '2024-01-20'), (3, '2024-01-30');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_ADD(NULL, INTERVAL 5 DAY) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 5 DAY) as result;
SELECT DATE_SUB('2024-01-05', INTERVAL 10 DAY) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 5 HOUR) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 45 MINUTE) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 90 SECOND) as result;
SELECT id FROM events WHERE DATE_ADD(event_date, INTERVAL 5 DAY) > '2024-01-25';
SELECT DATE_DIFF('2024-01-20', '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-20', DAY) as result;
SELECT DATE_DIFF('2024-06-15', '2024-01-15', MONTH) as result;
SELECT DATE_DIFF('2027-01-15', '2024-01-15', YEAR) as result;
SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_add_null_date
-- Source: date_functions_comprehensive_tdd.rs:181
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-10'), (2, '2024-01-20'), (3, '2024-01-30');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_ADD(NULL, INTERVAL 5 DAY) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 5 DAY) as result;
SELECT DATE_SUB('2024-01-05', INTERVAL 10 DAY) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 5 HOUR) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 45 MINUTE) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 90 SECOND) as result;
SELECT id FROM events WHERE DATE_ADD(event_date, INTERVAL 5 DAY) > '2024-01-25';
SELECT DATE_DIFF('2024-01-20', '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-20', DAY) as result;
SELECT DATE_DIFF('2024-06-15', '2024-01-15', MONTH) as result;
SELECT DATE_DIFF('2027-01-15', '2024-01-15', YEAR) as result;
SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_sub_basic_days
-- Source: date_functions_comprehensive_tdd.rs:194
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-10'), (2, '2024-01-20'), (3, '2024-01-30');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_SUB('2024-01-15', INTERVAL 5 DAY) as result;
SELECT DATE_SUB('2024-01-05', INTERVAL 10 DAY) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 5 HOUR) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 45 MINUTE) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 90 SECOND) as result;
SELECT id FROM events WHERE DATE_ADD(event_date, INTERVAL 5 DAY) > '2024-01-25';
SELECT DATE_DIFF('2024-01-20', '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-20', DAY) as result;
SELECT DATE_DIFF('2024-06-15', '2024-01-15', MONTH) as result;
SELECT DATE_DIFF('2027-01-15', '2024-01-15', YEAR) as result;
SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_sub_cross_year_boundary
-- Source: date_functions_comprehensive_tdd.rs:207
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-10'), (2, '2024-01-20'), (3, '2024-01-30');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_SUB('2024-01-05', INTERVAL 10 DAY) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 5 HOUR) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 45 MINUTE) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 90 SECOND) as result;
SELECT id FROM events WHERE DATE_ADD(event_date, INTERVAL 5 DAY) > '2024-01-25';
SELECT DATE_DIFF('2024-01-20', '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-20', DAY) as result;
SELECT DATE_DIFF('2024-06-15', '2024-01-15', MONTH) as result;
SELECT DATE_DIFF('2027-01-15', '2024-01-15', YEAR) as result;
SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_add_hours_to_timestamp
-- Source: date_functions_comprehensive_tdd.rs:227
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-10'), (2, '2024-01-20'), (3, '2024-01-30');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 5 HOUR) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 45 MINUTE) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 90 SECOND) as result;
SELECT id FROM events WHERE DATE_ADD(event_date, INTERVAL 5 DAY) > '2024-01-25';
SELECT DATE_DIFF('2024-01-20', '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-20', DAY) as result;
SELECT DATE_DIFF('2024-06-15', '2024-01-15', MONTH) as result;
SELECT DATE_DIFF('2027-01-15', '2024-01-15', YEAR) as result;
SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_add_minutes_to_timestamp
-- Source: date_functions_comprehensive_tdd.rs:244
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-10'), (2, '2024-01-20'), (3, '2024-01-30');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 45 MINUTE) as result;
SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 90 SECOND) as result;
SELECT id FROM events WHERE DATE_ADD(event_date, INTERVAL 5 DAY) > '2024-01-25';
SELECT DATE_DIFF('2024-01-20', '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-20', DAY) as result;
SELECT DATE_DIFF('2024-06-15', '2024-01-15', MONTH) as result;
SELECT DATE_DIFF('2027-01-15', '2024-01-15', YEAR) as result;
SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_add_seconds_to_timestamp
-- Source: date_functions_comprehensive_tdd.rs:254
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-10'), (2, '2024-01-20'), (3, '2024-01-30');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_ADD(TIMESTAMP '2024-01-15 10:30:00', INTERVAL 90 SECOND) as result;
SELECT id FROM events WHERE DATE_ADD(event_date, INTERVAL 5 DAY) > '2024-01-25';
SELECT DATE_DIFF('2024-01-20', '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-20', DAY) as result;
SELECT DATE_DIFF('2024-06-15', '2024-01-15', MONTH) as result;
SELECT DATE_DIFF('2027-01-15', '2024-01-15', YEAR) as result;
SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_add_in_where_clause
-- Source: date_functions_comprehensive_tdd.rs:264
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-10'), (2, '2024-01-20'), (3, '2024-01-30');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT id FROM events WHERE DATE_ADD(event_date, INTERVAL 5 DAY) > '2024-01-25';
SELECT DATE_DIFF('2024-01-20', '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-20', DAY) as result;
SELECT DATE_DIFF('2024-06-15', '2024-01-15', MONTH) as result;
SELECT DATE_DIFF('2027-01-15', '2024-01-15', YEAR) as result;
SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_diff_basic_days
-- Source: date_functions_comprehensive_tdd.rs:294
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_DIFF('2024-01-20', '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-20', DAY) as result;
SELECT DATE_DIFF('2024-06-15', '2024-01-15', MONTH) as result;
SELECT DATE_DIFF('2027-01-15', '2024-01-15', YEAR) as result;
SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_diff_negative_result
-- Source: date_functions_comprehensive_tdd.rs:312
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_DIFF('2024-01-15', '2024-01-20', DAY) as result;
SELECT DATE_DIFF('2024-06-15', '2024-01-15', MONTH) as result;
SELECT DATE_DIFF('2027-01-15', '2024-01-15', YEAR) as result;
SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_diff_months
-- Source: date_functions_comprehensive_tdd.rs:330
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_DIFF('2024-06-15', '2024-01-15', MONTH) as result;
SELECT DATE_DIFF('2027-01-15', '2024-01-15', YEAR) as result;
SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_diff_years
-- Source: date_functions_comprehensive_tdd.rs:348
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_DIFF('2027-01-15', '2024-01-15', YEAR) as result;
SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_diff_cross_leap_year
-- Source: date_functions_comprehensive_tdd.rs:366
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_DIFF('2025-03-01', '2024-02-28', DAY) as result;
SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_diff_same_date
-- Source: date_functions_comprehensive_tdd.rs:382
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_DIFF('2024-01-15', '2024-01-15', DAY) as result;
SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_diff_null_handling
-- Source: date_functions_comprehensive_tdd.rs:400
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_DIFF(NULL, '2024-01-15', DAY) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_datediff_alias
-- Source: date_functions_comprehensive_tdd.rs:413
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_DIFF('2024-01-20', '2024-01-15') as result;
SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_diff_in_aggregation
-- Source: date_functions_comprehensive_tdd.rs:428
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, order_date DATE, ship_date DATE);
INSERT INTO orders VALUES (1, '2024-01-10', '2024-01-15'), (2, '2024-01-12', '2024-01-20');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT AVG(DATE_DIFF(ship_date, order_date, DAY)) as avg_ship_days FROM orders;
SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_trunc_to_year
-- Source: date_functions_comprehensive_tdd.rs:449
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_TRUNC('2024-06-15', YEAR) as result;
SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_trunc_to_quarter
-- Source: date_functions_comprehensive_tdd.rs:466
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_TRUNC('2024-05-15', QUARTER) as result;
SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_trunc_to_month
-- Source: date_functions_comprehensive_tdd.rs:484
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_TRUNC('2024-06-15', MONTH) as result;
SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_trunc_to_week
-- Source: date_functions_comprehensive_tdd.rs:501
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_TRUNC('2024-06-15', WEEK) as result;
SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_trunc_to_day
-- Source: date_functions_comprehensive_tdd.rs:514
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_TRUNC('2024-06-15', DAY) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_trunc_timestamp_to_hour
-- Source: date_functions_comprehensive_tdd.rs:532
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', HOUR) as result;
SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_trunc_timestamp_to_minute
-- Source: date_functions_comprehensive_tdd.rs:549
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_TRUNC(TIMESTAMP '2024-06-15 14:35:42', MINUTE) as result;
SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_trunc_null_handling
-- Source: date_functions_comprehensive_tdd.rs:561
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_TRUNC(NULL, YEAR) as result;
SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_extract_year_from_date
-- Source: date_functions_comprehensive_tdd.rs:578
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT EXTRACT(YEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_extract_month_from_date
-- Source: date_functions_comprehensive_tdd.rs:591
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT EXTRACT(MONTH FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_extract_day_from_date
-- Source: date_functions_comprehensive_tdd.rs:604
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT EXTRACT(DAY FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_extract_dayofweek
-- Source: date_functions_comprehensive_tdd.rs:617
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT EXTRACT(DAYOFWEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_extract_dayofyear
-- Source: date_functions_comprehensive_tdd.rs:630
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT EXTRACT(DAYOFYEAR FROM DATE '2024-06-15') as result;
SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_extract_week
-- Source: date_functions_comprehensive_tdd.rs:643
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT EXTRACT(WEEK FROM DATE '2024-06-15') as result;
SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_extract_quarter
-- Source: date_functions_comprehensive_tdd.rs:656
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT EXTRACT(QUARTER FROM DATE '2024-06-15') as result;
SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_extract_hour_from_timestamp
-- Source: date_functions_comprehensive_tdd.rs:669
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT EXTRACT(HOUR FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_extract_minute_from_timestamp
-- Source: date_functions_comprehensive_tdd.rs:683
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT EXTRACT(MINUTE FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_extract_second_from_timestamp
-- Source: date_functions_comprehensive_tdd.rs:697
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT EXTRACT(SECOND FROM TIMESTAMP '2024-06-15 14:35:42') as result;
SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_extract_null_handling
-- Source: date_functions_comprehensive_tdd.rs:711
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT EXTRACT(YEAR FROM NULL) as result;
SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_part_alias
-- Source: date_functions_comprehensive_tdd.rs:724
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_PART('year', DATE '2024-06-15') as result;
SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_extract_in_where_clause
-- Source: date_functions_comprehensive_tdd.rs:738
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE);
INSERT INTO events VALUES (1, '2024-01-15'), (2, '2024-06-20'), (3, '2024-12-25');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT id FROM events WHERE EXTRACT(MONTH FROM event_date) = 6;
SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_extract_in_group_by
-- Source: date_functions_comprehensive_tdd.rs:759
-- ============================================================================
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, sale_date DATE, amount FLOAT64);
INSERT INTO sales VALUES (1, '2024-01-15', 100.0), (2, '2024-01-20', 150.0), (3, '2024-02-10', 200.0);
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT EXTRACT(MONTH FROM sale_date) as month, SUM(amount) as total FROM sales GROUP BY month;
SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_parse_date_iso_format
-- Source: date_functions_comprehensive_tdd.rs:783
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT PARSE_DATE('%Y-%m-%d', '2024-06-15') as result;
SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_parse_date_american_format
-- Source: date_functions_comprehensive_tdd.rs:796
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT PARSE_DATE('%m/%d/%Y', '06/15/2024') as result;
SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_parse_date_european_format
-- Source: date_functions_comprehensive_tdd.rs:816
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT PARSE_DATE('%d/%m/%Y', '15/06/2024') as result;
SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_parse_date_with_month_name
-- Source: date_functions_comprehensive_tdd.rs:836
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT PARSE_DATE('%d %B %Y', '15 June 2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_parse_date_invalid_format_error
-- Source: date_functions_comprehensive_tdd.rs:849
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT PARSE_DATE('%Y-%m-%d', 'not-a-date') as result;
SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_parse_date_format_mismatch_error
-- Source: date_functions_comprehensive_tdd.rs:863
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT PARSE_DATE('%Y-%m-%d', '06/15/2024') as result;
SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_parse_date_null_handling
-- Source: date_functions_comprehensive_tdd.rs:874
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT PARSE_DATE('%Y-%m-%d', NULL) as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_parse_timestamp_iso_format
-- Source: date_functions_comprehensive_tdd.rs:887
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', '2024-06-15 14:35:42') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_parse_timestamp_with_timezone
-- Source: date_functions_comprehensive_tdd.rs:900
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', '2024-06-15 14:35:42 UTC') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_parse_timestamp_12hour_format
-- Source: date_functions_comprehensive_tdd.rs:913
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT PARSE_TIMESTAMP('%Y-%m-%d %I:%M:%S %p', '2024-06-15 02:35:42 PM') as result;
SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_parse_timestamp_invalid_format
-- Source: date_functions_comprehensive_tdd.rs:926
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', 'invalid-timestamp') as result;
SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_interval_literal_days
-- Source: date_functions_comprehensive_tdd.rs:942
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT INTERVAL 5 DAY as result;
SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_interval_literal_months
-- Source: date_functions_comprehensive_tdd.rs:950
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT INTERVAL 3 MONTH as result;
SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_interval_literal_years
-- Source: date_functions_comprehensive_tdd.rs:958
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT INTERVAL 2 YEAR as result;
SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_plus_interval
-- Source: date_functions_comprehensive_tdd.rs:966
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE '2024-01-15' + INTERVAL 5 DAY as result;
SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_minus_interval
-- Source: date_functions_comprehensive_tdd.rs:983
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE '2024-01-15' - INTERVAL 5 DAY as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_timestamp_plus_interval
-- Source: date_functions_comprehensive_tdd.rs:1000
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT TIMESTAMP '2024-01-15 10:30:00' + INTERVAL 2 HOUR as result;
SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_timestamp_minus_interval
-- Source: date_functions_comprehensive_tdd.rs:1009
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT TIMESTAMP '2024-01-15 10:30:00' - INTERVAL 30 MINUTE as result;
SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_interval_multiplication
-- Source: date_functions_comprehensive_tdd.rs:1018
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE '2024-01-15' + (INTERVAL 2 DAY * 3) as result;
SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_interval_in_table_query
-- Source: date_functions_comprehensive_tdd.rs:1031
-- ============================================================================
DROP TABLE IF EXISTS tasks;
CREATE TABLE tasks (id INT64, due_date DATE);
INSERT INTO tasks VALUES (1, '2024-01-10'), (2, '2024-01-15'), (3, '2024-01-25');
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT id FROM tasks WHERE due_date < CURRENT_DATE + INTERVAL 7 DAY;
SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_format_iso
-- Source: date_functions_comprehensive_tdd.rs:1053
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_FORMAT(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_format_american
-- Source: date_functions_comprehensive_tdd.rs:1071
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_FORMAT(DATE '2024-06-15', '%m/%d/%Y') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_format_with_day_name
-- Source: date_functions_comprehensive_tdd.rs:1089
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_FORMAT(DATE '2024-06-15', '%A, %B %d, %Y') as result;
SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_format_timestamp
-- Source: date_functions_comprehensive_tdd.rs:1103
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_FORMAT(TIMESTAMP '2024-06-15 14:35:42', '%Y-%m-%d %H:%M:%S') as result;
SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_to_char_alias
-- Source: date_functions_comprehensive_tdd.rs:1122
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT TO_CHAR(DATE '2024-06-15', '%Y-%m-%d') as result;
SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_format_null_handling
-- Source: date_functions_comprehensive_tdd.rs:1131
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_FORMAT(NULL, '%Y-%m-%d') as result;
SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_format_invalid_format_string
-- Source: date_functions_comprehensive_tdd.rs:1144
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT DATE_FORMAT(DATE '2024-06-15', 'invalid-%Q-format') as result;
SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_functions_combined
-- Source: date_functions_comprehensive_tdd.rs:1158
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT EXTRACT(MONTH FROM DATE_ADD(DATE '2024-01-15', INTERVAL 2 MONTH)) as result;
SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_arithmetic_in_case_expression
-- Source: date_functions_comprehensive_tdd.rs:1174
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT CASE WHEN DATE_DIFF(DATE '2024-06-15', DATE '2024-01-15', DAY) > 100 THEN 'Long' ELSE 'Short' END as result;
SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_functions_with_nulls_in_coalesce
-- Source: date_functions_comprehensive_tdd.rs:1189
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT COALESCE(DATE_ADD(NULL, INTERVAL 5 DAY), DATE '2024-01-01') as result;
SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_date_based_window_function
-- Source: date_functions_comprehensive_tdd.rs:1204
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_date DATE, value FLOAT64);
INSERT INTO events VALUES (1, '2024-01-10', 100.0), (2, '2024-01-15', 150.0), (3, '2024-01-20', 200.0);
DROP TABLE IF EXISTS large_events;
CREATE TABLE large_events (id INT64, event_date DATE);

SELECT id, event_date, SUM(value) OVER (ORDER BY event_date ROWS BETWEEN INTERVAL 5 DAY PRECEDING AND CURRENT ROW) as rolling_sum FROM events;
SELECT EXTRACT(MONTH FROM event_date) as month, COUNT(*) FROM large_events GROUP BY month;
SELECT DATE_ADD('2024-01-15', INTERVAL 5 INVALID_UNIT) as result;
SELECT DATE_DIFF('2024-01-20', '2024-01-15', INVALID_UNIT) as result;
SELECT EXTRACT(INVALID_FIELD FROM DATE '2024-01-15') as result;
SELECT DATE_ADD('2024-01-15', INTERVAL 999999 YEAR) as result;
SELECT DATE_SUB('2024-01-15', INTERVAL 999999 YEAR) as result;

-- ============================================================================
-- Test: test_delete_with_inner_join
-- Source: delete_enhancements_advanced_tdd.rs:28
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, status STRING);
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0), (3, 3, 300.0);
INSERT INTO customers VALUES (1, 'inactive'), (2, 'active'), (3, 'inactive');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category_id INT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, department_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, active BOOL);
INSERT INTO products VALUES (1, 1), (2, 2), (3, 3);
INSERT INTO categories VALUES (1, 1), (2, 1), (3, 2);
INSERT INTO departments VALUES (1, FALSE), (2, TRUE);
DROP TABLE IF EXISTS emails;
CREATE TABLE emails (id INT64, address STRING);
INSERT INTO emails VALUES (1, 'test@example.com'), (2, 'test@example.com'), (3, 'unique@example.com');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS flagged_customers;
CREATE TABLE flagged_customers (id INT64);
INSERT INTO orders VALUES (1, 1), (2, 2);
DROP TABLE IF EXISTS orphan_check;
CREATE TABLE orphan_check (id INT64, parent_id INT64);
DROP TABLE IF EXISTS parents;
CREATE TABLE parents (id INT64);
INSERT INTO orphan_check VALUES (1, 1), (2, 2), (3, 999);
INSERT INTO parents VALUES (1), (2);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, timestamp INT64);
INSERT INTO logs VALUES (1, 1, 100), (2, 1, 200), (3, 1, 300), (4, 2, 150);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 10.0), (2, 50.0), (3, 100.0), (4, 25.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0), (3, 'Gizmo', 300.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary FLOAT64);
INSERT INTO employees VALUES (1, 'Alice', 50000.0), (2, 'Bob', 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category_id INT64, name STRING);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, deprecated BOOL);
INSERT INTO items VALUES (1, 1, 'Item1'), (2, 2, 'Item2'), (3, 1, 'Item3');
INSERT INTO categories VALUES (1, TRUE), (2, FALSE);
DROP TABLE IF EXISTS active_orders;
CREATE TABLE active_orders (id INT64, total FLOAT64, created_at INT64);
DROP TABLE IF EXISTS archived_orders;
CREATE TABLE archived_orders (id INT64, total FLOAT64, created_at INT64, deleted_at INT64);
INSERT INTO active_orders VALUES (1, 100.0, 1000), (2, 200.0, 2000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, product_id INT64);
INSERT INTO orders VALUES (1, 1), (2, 2);
INSERT INTO order_items VALUES (1, 100), (1, 200), (2, 300);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id));
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees ( id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id) ON DELETE CASCADE );
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1), (2, 1);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees ( id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id) ON DELETE SET NULL );
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1), (2, 1);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 10.0), (2, 50.0), (3, 100.0), (4, 25.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 1, 100.0), (2, 1, 200.0), (3, 2, 150.0), (4, 2, 300.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64);
INSERT INTO products VALUES (1, 'Popular'), (2, 'Unpopular'), (3, 'Popular2');
INSERT INTO orders VALUES (1), (1), (3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept STRING);
DROP TABLE IF EXISTS closed_depts;
CREATE TABLE closed_depts (name STRING);
INSERT INTO employees VALUES (1, 'Sales'), (2, 'Engineering'), (3, 'Marketing');
INSERT INTO closed_depts VALUES ('Sales'), ('Marketing');
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, level STRING, timestamp INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, active BOOL);
DROP TABLE IF EXISTS retention_policy;
CREATE TABLE retention_policy (level STRING, days INT64);
INSERT INTO logs VALUES (1, 1, 'DEBUG', 100), (2, 1, 'INFO', 200), (3, 2, 'ERROR', 150);
INSERT INTO users VALUES (1, FALSE), (2, TRUE);
INSERT INTO retention_policy VALUES ('DEBUG', 7), ('INFO', 30), ('ERROR', 90);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2), (3);
DROP TABLE IF EXISTS queue;
CREATE TABLE queue (id INT64, priority INT64);
INSERT INTO queue VALUES (1, 1), (2, 1), (3, 2), (4, 1);

DELETE FROM orders o
USING customers c
WHERE o.customer_id = c.id AND c.status = 'inactive';
SELECT id FROM orders ORDER BY id;
DELETE FROM products p
USING categories c
JOIN departments d ON c.department_id = d.id
WHERE p.category_id = c.id AND d.active = FALSE;
SELECT id FROM products ORDER BY id;
DELETE FROM emails e1
USING emails e2
WHERE e1.address = e2.address AND e1.id > e2.id;
SELECT id, address FROM emails ORDER BY id;
DELETE FROM orders o
USING flagged_customers f
WHERE o.customer_id = f.id;
SELECT COUNT(*) FROM orders;
DELETE FROM orphan_check o
USING (SELECT * FROM orphan_check) oc
LEFT JOIN parents p ON oc.parent_id = p.id
WHERE o.id = oc.id AND p.id IS NULL;
SELECT id FROM orphan_check ORDER BY id;
DELETE FROM logs l
USING (
SELECT user_id, MAX(timestamp) as max_ts
FROM logs
GROUP BY user_id
) recent
WHERE l.user_id = recent.user_id AND l.timestamp < recent.max_ts;
SELECT id, user_id FROM logs ORDER BY id;
WITH high_price AS (
SELECT AVG(price) * 2 as threshold FROM products
)
DELETE FROM products p
USING high_price h
WHERE p.price > h.threshold;
SELECT id FROM products ORDER BY id;
DELETE FROM products WHERE price > 150.0 RETURNING *;
DELETE FROM employees WHERE id = 1 RETURNING id, name;
DELETE FROM products WHERE id <= 2
RETURNING id, name, price, price * 0.8 as discounted_price;
DELETE FROM products WHERE id = 999 RETURNING *;
DELETE FROM items i
USING categories c
WHERE i.category_id = c.id AND c.deprecated = TRUE
RETURNING i.id, i.name, c.id as category_id;
DELETE FROM active_orders WHERE created_at < 1500 RETURNING id, total, created_at;
DELETE orders, order_items
FROM orders
JOIN order_items ON orders.id = order_items.order_id
WHERE orders.id = 1;
SELECT id FROM orders;
SELECT order_id FROM order_items;
DELETE FROM departments WHERE id = 1;
DELETE FROM departments WHERE id = 1;
SELECT COUNT(*) FROM employees;
DELETE FROM departments WHERE id = 1;
SELECT dept_id FROM employees;
DELETE FROM products
WHERE price > (SELECT AVG(price) FROM products);
SELECT id FROM products ORDER BY id;
DELETE FROM sales s1
WHERE amount < (
SELECT AVG(amount)
FROM sales s2
WHERE s2.product_id = s1.product_id
);
SELECT id FROM sales ORDER BY id;
DELETE FROM products p
WHERE NOT EXISTS (
SELECT 1 FROM orders o WHERE o.product_id = p.id
);
SELECT id FROM products ORDER BY id;
DELETE FROM employees
WHERE dept IN (SELECT name FROM closed_depts);
SELECT id FROM employees;
DELETE FROM numbers WHERE n < 5000;
SELECT COUNT(*) FROM numbers;
DELETE FROM logs l
USING users u
JOIN retention_policy r ON l.level = r.level
WHERE l.user_id = u.id
AND u.active = FALSE
AND l.timestamp < (300 - r.days)
RETURNING l.id, l.level;
DELETE FROM test;
SELECT COUNT(*) FROM test;
DELETE FROM queue WHERE priority = 1 LIMIT 2;
SELECT id FROM queue ORDER BY id;

-- ============================================================================
-- Test: test_delete_with_multiple_joins
-- Source: delete_enhancements_advanced_tdd.rs:58
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category_id INT64);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, department_id INT64);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64, active BOOL);
INSERT INTO products VALUES (1, 1), (2, 2), (3, 3);
INSERT INTO categories VALUES (1, 1), (2, 1), (3, 2);
INSERT INTO departments VALUES (1, FALSE), (2, TRUE);
DROP TABLE IF EXISTS emails;
CREATE TABLE emails (id INT64, address STRING);
INSERT INTO emails VALUES (1, 'test@example.com'), (2, 'test@example.com'), (3, 'unique@example.com');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS flagged_customers;
CREATE TABLE flagged_customers (id INT64);
INSERT INTO orders VALUES (1, 1), (2, 2);
DROP TABLE IF EXISTS orphan_check;
CREATE TABLE orphan_check (id INT64, parent_id INT64);
DROP TABLE IF EXISTS parents;
CREATE TABLE parents (id INT64);
INSERT INTO orphan_check VALUES (1, 1), (2, 2), (3, 999);
INSERT INTO parents VALUES (1), (2);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, timestamp INT64);
INSERT INTO logs VALUES (1, 1, 100), (2, 1, 200), (3, 1, 300), (4, 2, 150);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 10.0), (2, 50.0), (3, 100.0), (4, 25.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0), (3, 'Gizmo', 300.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary FLOAT64);
INSERT INTO employees VALUES (1, 'Alice', 50000.0), (2, 'Bob', 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category_id INT64, name STRING);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, deprecated BOOL);
INSERT INTO items VALUES (1, 1, 'Item1'), (2, 2, 'Item2'), (3, 1, 'Item3');
INSERT INTO categories VALUES (1, TRUE), (2, FALSE);
DROP TABLE IF EXISTS active_orders;
CREATE TABLE active_orders (id INT64, total FLOAT64, created_at INT64);
DROP TABLE IF EXISTS archived_orders;
CREATE TABLE archived_orders (id INT64, total FLOAT64, created_at INT64, deleted_at INT64);
INSERT INTO active_orders VALUES (1, 100.0, 1000), (2, 200.0, 2000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, product_id INT64);
INSERT INTO orders VALUES (1, 1), (2, 2);
INSERT INTO order_items VALUES (1, 100), (1, 200), (2, 300);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id));
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees ( id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id) ON DELETE CASCADE );
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1), (2, 1);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees ( id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id) ON DELETE SET NULL );
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1), (2, 1);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 10.0), (2, 50.0), (3, 100.0), (4, 25.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 1, 100.0), (2, 1, 200.0), (3, 2, 150.0), (4, 2, 300.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64);
INSERT INTO products VALUES (1, 'Popular'), (2, 'Unpopular'), (3, 'Popular2');
INSERT INTO orders VALUES (1), (1), (3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept STRING);
DROP TABLE IF EXISTS closed_depts;
CREATE TABLE closed_depts (name STRING);
INSERT INTO employees VALUES (1, 'Sales'), (2, 'Engineering'), (3, 'Marketing');
INSERT INTO closed_depts VALUES ('Sales'), ('Marketing');
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, level STRING, timestamp INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, active BOOL);
DROP TABLE IF EXISTS retention_policy;
CREATE TABLE retention_policy (level STRING, days INT64);
INSERT INTO logs VALUES (1, 1, 'DEBUG', 100), (2, 1, 'INFO', 200), (3, 2, 'ERROR', 150);
INSERT INTO users VALUES (1, FALSE), (2, TRUE);
INSERT INTO retention_policy VALUES ('DEBUG', 7), ('INFO', 30), ('ERROR', 90);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2), (3);
DROP TABLE IF EXISTS queue;
CREATE TABLE queue (id INT64, priority INT64);
INSERT INTO queue VALUES (1, 1), (2, 1), (3, 2), (4, 1);

DELETE FROM products p
USING categories c
JOIN departments d ON c.department_id = d.id
WHERE p.category_id = c.id AND d.active = FALSE;
SELECT id FROM products ORDER BY id;
DELETE FROM emails e1
USING emails e2
WHERE e1.address = e2.address AND e1.id > e2.id;
SELECT id, address FROM emails ORDER BY id;
DELETE FROM orders o
USING flagged_customers f
WHERE o.customer_id = f.id;
SELECT COUNT(*) FROM orders;
DELETE FROM orphan_check o
USING (SELECT * FROM orphan_check) oc
LEFT JOIN parents p ON oc.parent_id = p.id
WHERE o.id = oc.id AND p.id IS NULL;
SELECT id FROM orphan_check ORDER BY id;
DELETE FROM logs l
USING (
SELECT user_id, MAX(timestamp) as max_ts
FROM logs
GROUP BY user_id
) recent
WHERE l.user_id = recent.user_id AND l.timestamp < recent.max_ts;
SELECT id, user_id FROM logs ORDER BY id;
WITH high_price AS (
SELECT AVG(price) * 2 as threshold FROM products
)
DELETE FROM products p
USING high_price h
WHERE p.price > h.threshold;
SELECT id FROM products ORDER BY id;
DELETE FROM products WHERE price > 150.0 RETURNING *;
DELETE FROM employees WHERE id = 1 RETURNING id, name;
DELETE FROM products WHERE id <= 2
RETURNING id, name, price, price * 0.8 as discounted_price;
DELETE FROM products WHERE id = 999 RETURNING *;
DELETE FROM items i
USING categories c
WHERE i.category_id = c.id AND c.deprecated = TRUE
RETURNING i.id, i.name, c.id as category_id;
DELETE FROM active_orders WHERE created_at < 1500 RETURNING id, total, created_at;
DELETE orders, order_items
FROM orders
JOIN order_items ON orders.id = order_items.order_id
WHERE orders.id = 1;
SELECT id FROM orders;
SELECT order_id FROM order_items;
DELETE FROM departments WHERE id = 1;
DELETE FROM departments WHERE id = 1;
SELECT COUNT(*) FROM employees;
DELETE FROM departments WHERE id = 1;
SELECT dept_id FROM employees;
DELETE FROM products
WHERE price > (SELECT AVG(price) FROM products);
SELECT id FROM products ORDER BY id;
DELETE FROM sales s1
WHERE amount < (
SELECT AVG(amount)
FROM sales s2
WHERE s2.product_id = s1.product_id
);
SELECT id FROM sales ORDER BY id;
DELETE FROM products p
WHERE NOT EXISTS (
SELECT 1 FROM orders o WHERE o.product_id = p.id
);
SELECT id FROM products ORDER BY id;
DELETE FROM employees
WHERE dept IN (SELECT name FROM closed_depts);
SELECT id FROM employees;
DELETE FROM numbers WHERE n < 5000;
SELECT COUNT(*) FROM numbers;
DELETE FROM logs l
USING users u
JOIN retention_policy r ON l.level = r.level
WHERE l.user_id = u.id
AND u.active = FALSE
AND l.timestamp < (300 - r.days)
RETURNING l.id, l.level;
DELETE FROM test;
SELECT COUNT(*) FROM test;
DELETE FROM queue WHERE priority = 1 LIMIT 2;
SELECT id FROM queue ORDER BY id;

-- ============================================================================
-- Test: test_delete_with_self_join
-- Source: delete_enhancements_advanced_tdd.rs:89
-- ============================================================================
DROP TABLE IF EXISTS emails;
CREATE TABLE emails (id INT64, address STRING);
INSERT INTO emails VALUES (1, 'test@example.com'), (2, 'test@example.com'), (3, 'unique@example.com');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS flagged_customers;
CREATE TABLE flagged_customers (id INT64);
INSERT INTO orders VALUES (1, 1), (2, 2);
DROP TABLE IF EXISTS orphan_check;
CREATE TABLE orphan_check (id INT64, parent_id INT64);
DROP TABLE IF EXISTS parents;
CREATE TABLE parents (id INT64);
INSERT INTO orphan_check VALUES (1, 1), (2, 2), (3, 999);
INSERT INTO parents VALUES (1), (2);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, timestamp INT64);
INSERT INTO logs VALUES (1, 1, 100), (2, 1, 200), (3, 1, 300), (4, 2, 150);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 10.0), (2, 50.0), (3, 100.0), (4, 25.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0), (3, 'Gizmo', 300.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary FLOAT64);
INSERT INTO employees VALUES (1, 'Alice', 50000.0), (2, 'Bob', 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category_id INT64, name STRING);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, deprecated BOOL);
INSERT INTO items VALUES (1, 1, 'Item1'), (2, 2, 'Item2'), (3, 1, 'Item3');
INSERT INTO categories VALUES (1, TRUE), (2, FALSE);
DROP TABLE IF EXISTS active_orders;
CREATE TABLE active_orders (id INT64, total FLOAT64, created_at INT64);
DROP TABLE IF EXISTS archived_orders;
CREATE TABLE archived_orders (id INT64, total FLOAT64, created_at INT64, deleted_at INT64);
INSERT INTO active_orders VALUES (1, 100.0, 1000), (2, 200.0, 2000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, product_id INT64);
INSERT INTO orders VALUES (1, 1), (2, 2);
INSERT INTO order_items VALUES (1, 100), (1, 200), (2, 300);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id));
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees ( id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id) ON DELETE CASCADE );
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1), (2, 1);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees ( id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id) ON DELETE SET NULL );
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1), (2, 1);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 10.0), (2, 50.0), (3, 100.0), (4, 25.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 1, 100.0), (2, 1, 200.0), (3, 2, 150.0), (4, 2, 300.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64);
INSERT INTO products VALUES (1, 'Popular'), (2, 'Unpopular'), (3, 'Popular2');
INSERT INTO orders VALUES (1), (1), (3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept STRING);
DROP TABLE IF EXISTS closed_depts;
CREATE TABLE closed_depts (name STRING);
INSERT INTO employees VALUES (1, 'Sales'), (2, 'Engineering'), (3, 'Marketing');
INSERT INTO closed_depts VALUES ('Sales'), ('Marketing');
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, level STRING, timestamp INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, active BOOL);
DROP TABLE IF EXISTS retention_policy;
CREATE TABLE retention_policy (level STRING, days INT64);
INSERT INTO logs VALUES (1, 1, 'DEBUG', 100), (2, 1, 'INFO', 200), (3, 2, 'ERROR', 150);
INSERT INTO users VALUES (1, FALSE), (2, TRUE);
INSERT INTO retention_policy VALUES ('DEBUG', 7), ('INFO', 30), ('ERROR', 90);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2), (3);
DROP TABLE IF EXISTS queue;
CREATE TABLE queue (id INT64, priority INT64);
INSERT INTO queue VALUES (1, 1), (2, 1), (3, 2), (4, 1);

DELETE FROM emails e1
USING emails e2
WHERE e1.address = e2.address AND e1.id > e2.id;
SELECT id, address FROM emails ORDER BY id;
DELETE FROM orders o
USING flagged_customers f
WHERE o.customer_id = f.id;
SELECT COUNT(*) FROM orders;
DELETE FROM orphan_check o
USING (SELECT * FROM orphan_check) oc
LEFT JOIN parents p ON oc.parent_id = p.id
WHERE o.id = oc.id AND p.id IS NULL;
SELECT id FROM orphan_check ORDER BY id;
DELETE FROM logs l
USING (
SELECT user_id, MAX(timestamp) as max_ts
FROM logs
GROUP BY user_id
) recent
WHERE l.user_id = recent.user_id AND l.timestamp < recent.max_ts;
SELECT id, user_id FROM logs ORDER BY id;
WITH high_price AS (
SELECT AVG(price) * 2 as threshold FROM products
)
DELETE FROM products p
USING high_price h
WHERE p.price > h.threshold;
SELECT id FROM products ORDER BY id;
DELETE FROM products WHERE price > 150.0 RETURNING *;
DELETE FROM employees WHERE id = 1 RETURNING id, name;
DELETE FROM products WHERE id <= 2
RETURNING id, name, price, price * 0.8 as discounted_price;
DELETE FROM products WHERE id = 999 RETURNING *;
DELETE FROM items i
USING categories c
WHERE i.category_id = c.id AND c.deprecated = TRUE
RETURNING i.id, i.name, c.id as category_id;
DELETE FROM active_orders WHERE created_at < 1500 RETURNING id, total, created_at;
DELETE orders, order_items
FROM orders
JOIN order_items ON orders.id = order_items.order_id
WHERE orders.id = 1;
SELECT id FROM orders;
SELECT order_id FROM order_items;
DELETE FROM departments WHERE id = 1;
DELETE FROM departments WHERE id = 1;
SELECT COUNT(*) FROM employees;
DELETE FROM departments WHERE id = 1;
SELECT dept_id FROM employees;
DELETE FROM products
WHERE price > (SELECT AVG(price) FROM products);
SELECT id FROM products ORDER BY id;
DELETE FROM sales s1
WHERE amount < (
SELECT AVG(amount)
FROM sales s2
WHERE s2.product_id = s1.product_id
);
SELECT id FROM sales ORDER BY id;
DELETE FROM products p
WHERE NOT EXISTS (
SELECT 1 FROM orders o WHERE o.product_id = p.id
);
SELECT id FROM products ORDER BY id;
DELETE FROM employees
WHERE dept IN (SELECT name FROM closed_depts);
SELECT id FROM employees;
DELETE FROM numbers WHERE n < 5000;
SELECT COUNT(*) FROM numbers;
DELETE FROM logs l
USING users u
JOIN retention_policy r ON l.level = r.level
WHERE l.user_id = u.id
AND u.active = FALSE
AND l.timestamp < (300 - r.days)
RETURNING l.id, l.level;
DELETE FROM test;
SELECT COUNT(*) FROM test;
DELETE FROM queue WHERE priority = 1 LIMIT 2;
SELECT id FROM queue ORDER BY id;

-- ============================================================================
-- Test: test_delete_with_join_no_matches
-- Source: delete_enhancements_advanced_tdd.rs:117
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS flagged_customers;
CREATE TABLE flagged_customers (id INT64);
INSERT INTO orders VALUES (1, 1), (2, 2);
DROP TABLE IF EXISTS orphan_check;
CREATE TABLE orphan_check (id INT64, parent_id INT64);
DROP TABLE IF EXISTS parents;
CREATE TABLE parents (id INT64);
INSERT INTO orphan_check VALUES (1, 1), (2, 2), (3, 999);
INSERT INTO parents VALUES (1), (2);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, timestamp INT64);
INSERT INTO logs VALUES (1, 1, 100), (2, 1, 200), (3, 1, 300), (4, 2, 150);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 10.0), (2, 50.0), (3, 100.0), (4, 25.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0), (3, 'Gizmo', 300.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary FLOAT64);
INSERT INTO employees VALUES (1, 'Alice', 50000.0), (2, 'Bob', 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category_id INT64, name STRING);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, deprecated BOOL);
INSERT INTO items VALUES (1, 1, 'Item1'), (2, 2, 'Item2'), (3, 1, 'Item3');
INSERT INTO categories VALUES (1, TRUE), (2, FALSE);
DROP TABLE IF EXISTS active_orders;
CREATE TABLE active_orders (id INT64, total FLOAT64, created_at INT64);
DROP TABLE IF EXISTS archived_orders;
CREATE TABLE archived_orders (id INT64, total FLOAT64, created_at INT64, deleted_at INT64);
INSERT INTO active_orders VALUES (1, 100.0, 1000), (2, 200.0, 2000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, product_id INT64);
INSERT INTO orders VALUES (1, 1), (2, 2);
INSERT INTO order_items VALUES (1, 100), (1, 200), (2, 300);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id));
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees ( id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id) ON DELETE CASCADE );
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1), (2, 1);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees ( id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id) ON DELETE SET NULL );
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1), (2, 1);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 10.0), (2, 50.0), (3, 100.0), (4, 25.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 1, 100.0), (2, 1, 200.0), (3, 2, 150.0), (4, 2, 300.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64);
INSERT INTO products VALUES (1, 'Popular'), (2, 'Unpopular'), (3, 'Popular2');
INSERT INTO orders VALUES (1), (1), (3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept STRING);
DROP TABLE IF EXISTS closed_depts;
CREATE TABLE closed_depts (name STRING);
INSERT INTO employees VALUES (1, 'Sales'), (2, 'Engineering'), (3, 'Marketing');
INSERT INTO closed_depts VALUES ('Sales'), ('Marketing');
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, level STRING, timestamp INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, active BOOL);
DROP TABLE IF EXISTS retention_policy;
CREATE TABLE retention_policy (level STRING, days INT64);
INSERT INTO logs VALUES (1, 1, 'DEBUG', 100), (2, 1, 'INFO', 200), (3, 2, 'ERROR', 150);
INSERT INTO users VALUES (1, FALSE), (2, TRUE);
INSERT INTO retention_policy VALUES ('DEBUG', 7), ('INFO', 30), ('ERROR', 90);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2), (3);
DROP TABLE IF EXISTS queue;
CREATE TABLE queue (id INT64, priority INT64);
INSERT INTO queue VALUES (1, 1), (2, 1), (3, 2), (4, 1);

DELETE FROM orders o
USING flagged_customers f
WHERE o.customer_id = f.id;
SELECT COUNT(*) FROM orders;
DELETE FROM orphan_check o
USING (SELECT * FROM orphan_check) oc
LEFT JOIN parents p ON oc.parent_id = p.id
WHERE o.id = oc.id AND p.id IS NULL;
SELECT id FROM orphan_check ORDER BY id;
DELETE FROM logs l
USING (
SELECT user_id, MAX(timestamp) as max_ts
FROM logs
GROUP BY user_id
) recent
WHERE l.user_id = recent.user_id AND l.timestamp < recent.max_ts;
SELECT id, user_id FROM logs ORDER BY id;
WITH high_price AS (
SELECT AVG(price) * 2 as threshold FROM products
)
DELETE FROM products p
USING high_price h
WHERE p.price > h.threshold;
SELECT id FROM products ORDER BY id;
DELETE FROM products WHERE price > 150.0 RETURNING *;
DELETE FROM employees WHERE id = 1 RETURNING id, name;
DELETE FROM products WHERE id <= 2
RETURNING id, name, price, price * 0.8 as discounted_price;
DELETE FROM products WHERE id = 999 RETURNING *;
DELETE FROM items i
USING categories c
WHERE i.category_id = c.id AND c.deprecated = TRUE
RETURNING i.id, i.name, c.id as category_id;
DELETE FROM active_orders WHERE created_at < 1500 RETURNING id, total, created_at;
DELETE orders, order_items
FROM orders
JOIN order_items ON orders.id = order_items.order_id
WHERE orders.id = 1;
SELECT id FROM orders;
SELECT order_id FROM order_items;
DELETE FROM departments WHERE id = 1;
DELETE FROM departments WHERE id = 1;
SELECT COUNT(*) FROM employees;
DELETE FROM departments WHERE id = 1;
SELECT dept_id FROM employees;
DELETE FROM products
WHERE price > (SELECT AVG(price) FROM products);
SELECT id FROM products ORDER BY id;
DELETE FROM sales s1
WHERE amount < (
SELECT AVG(amount)
FROM sales s2
WHERE s2.product_id = s1.product_id
);
SELECT id FROM sales ORDER BY id;
DELETE FROM products p
WHERE NOT EXISTS (
SELECT 1 FROM orders o WHERE o.product_id = p.id
);
SELECT id FROM products ORDER BY id;
DELETE FROM employees
WHERE dept IN (SELECT name FROM closed_depts);
SELECT id FROM employees;
DELETE FROM numbers WHERE n < 5000;
SELECT COUNT(*) FROM numbers;
DELETE FROM logs l
USING users u
JOIN retention_policy r ON l.level = r.level
WHERE l.user_id = u.id
AND u.active = FALSE
AND l.timestamp < (300 - r.days)
RETURNING l.id, l.level;
DELETE FROM test;
SELECT COUNT(*) FROM test;
DELETE FROM queue WHERE priority = 1 LIMIT 2;
SELECT id FROM queue ORDER BY id;

-- ============================================================================
-- Test: test_update_from_simple_join
-- Source: join_based_dml_comprehensive_tdd.rs:32
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, status STRING);
DROP TABLE IF EXISTS status_updates;
CREATE TABLE status_updates (user_id INT64, new_status STRING);
INSERT INTO users VALUES (1, 'Alice', 'active'), (2, 'Bob', 'active');
INSERT INTO status_updates VALUES (1, 'inactive');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64, category STRING);
DROP TABLE IF EXISTS price_updates;
CREATE TABLE price_updates (product_id INT64, new_price FLOAT64, new_category STRING);
INSERT INTO products VALUES (1, 'Widget', 10.0, 'tools');
INSERT INTO price_updates VALUES (1, 15.0, 'hardware');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (user_id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO updates VALUES (99, 'Charlie');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
DROP TABLE IF EXISTS email_updates;
CREATE TABLE email_updates (user_id INT64, new_email STRING);
INSERT INTO users VALUES (1, 'alice@old.com');
INSERT INTO email_updates VALUES (1, NULL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (id INT64, amount FLOAT64);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (price_id INT64, factor FLOAT64);
INSERT INTO prices VALUES (1, 100.0);
INSERT INTO multipliers VALUES (1, 1.5);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, discount FLOAT64);
DROP TABLE IF EXISTS promotions;
CREATE TABLE promotions (user_id INT64, extra_discount FLOAT64);
INSERT INTO orders VALUES (1, 1, 100.0);
INSERT INTO users VALUES (1, 0.1);
INSERT INTO promotions VALUES (1, 0.05);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, manager_name STRING);
INSERT INTO employees VALUES (1, 'Alice', NULL, NULL), (2, 'Bob', 1, NULL);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (id INT64, item STRING, quantity INT64);
DROP TABLE IF EXISTS adjustments;
CREATE TABLE adjustments (item STRING, delta INT64);
INSERT INTO inventory VALUES (1, 'widget', 100), (2, 'gadget', 50);
INSERT INTO adjustments VALUES ('widget', -10), ('gadget', -60);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO to_delete VALUES (1), (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO to_delete VALUES (99);
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64);
DROP TABLE IF EXISTS cleanup;
CREATE TABLE cleanup (flag BOOL);
INSERT INTO temp VALUES (1), (2), (3);
INSERT INTO cleanup VALUES (TRUE);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, amount FLOAT64, status STRING);
DROP TABLE IF EXISTS cancelled_users;
CREATE TABLE cancelled_users (user_id INT64);
INSERT INTO orders VALUES \
(1, 1, 100.0, 'pending'), \
(2, 1, 200.0, 'completed'), \
(3, 2, 150.0, 'pending');
INSERT INTO cancelled_users VALUES (1);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, type STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (user_id INT64);
DROP TABLE IF EXISTS log_types_to_clean;
CREATE TABLE log_types_to_clean (type STRING);
INSERT INTO logs VALUES \
(1, 1, 'debug'), \
(2, 1, 'error'), \
(3, 2, 'debug');
INSERT INTO inactive_users VALUES (1);
INSERT INTO log_types_to_clean VALUES ('debug');
DROP TABLE IF EXISTS contacts;
CREATE TABLE contacts (id INT64, email STRING, created_at INT64);
INSERT INTO contacts VALUES \
(1, 'alice@example.com', 1), \
(2, 'alice@example.com', 2), \
(3, 'bob@example.com', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, score INT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (user_id INT64, bonus INT64);
INSERT INTO users VALUES (1, 100), (2, 200);
INSERT INTO bonuses VALUES (1, 50);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category STRING);
DROP TABLE IF EXISTS discontinued_categories;
CREATE TABLE discontinued_categories (category STRING);
INSERT INTO products VALUES \
(1, 'Widget', 'tools'), \
(2, 'Gadget', 'electronics');
INSERT INTO discontinued_categories VALUES ('tools');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, level STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, points INT64);
INSERT INTO users VALUES (1, 'beginner'), (2, 'beginner');
INSERT INTO scores VALUES (1, 1000), (2, 500);
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

UPDATE users \
SET status = status_updates.new_status \
FROM status_updates \
WHERE users.id = status_updates.user_id;
SELECT id, status FROM users WHERE id = 1;
SELECT status FROM users WHERE id = 2;
UPDATE products \
SET price = price_updates.new_price, \
category = price_updates.new_category \
FROM price_updates \
WHERE products.id = price_updates.product_id;
SELECT price, category FROM products WHERE id = 1;
UPDATE users \
SET name = updates.new_name \
FROM updates \
WHERE users.id = updates.user_id;
SELECT name FROM users ORDER BY id;
UPDATE users \
SET email = email_updates.new_email \
FROM email_updates \
WHERE users.id = email_updates.user_id;
SELECT email FROM users WHERE id = 1;
UPDATE prices \
SET amount = prices.amount * multipliers.factor \
FROM multipliers \
WHERE prices.id = multipliers.price_id;
SELECT amount FROM prices WHERE id = 1;
UPDATE orders \
SET total = orders.total * (1.0 - users.discount - promotions.extra_discount) \
FROM users, promotions \
WHERE orders.user_id = users.id \
AND orders.user_id = promotions.user_id;
SELECT total FROM orders WHERE id = 1;
UPDATE employees e1 \
SET manager_name = e2.name \
FROM employees e2 \
WHERE e1.manager_id = e2.id;
SELECT manager_name FROM employees WHERE id = 2;
UPDATE inventory \
SET quantity = inventory.quantity + adjustments.delta \
FROM adjustments \
WHERE inventory.item = adjustments.item \
AND inventory.quantity + adjustments.delta >= 0;
SELECT quantity FROM inventory WHERE item = 'widget';
SELECT quantity FROM inventory WHERE item = 'gadget';
DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT name FROM users;
DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT COUNT(*) FROM users;
DELETE FROM temp \
USING cleanup \
WHERE cleanup.flag = TRUE;
SELECT COUNT(*) FROM temp;
DELETE FROM orders \
USING cancelled_users \
WHERE orders.user_id = cancelled_users.user_id \
AND orders.status = 'pending';
SELECT id FROM orders WHERE user_id = 1 ORDER BY id;
DELETE FROM logs \
USING inactive_users, log_types_to_clean \
WHERE logs.user_id = inactive_users.user_id \
AND logs.type = log_types_to_clean.type;
SELECT id FROM logs ORDER BY id;
DELETE FROM contacts c1 \
USING contacts c2 \
WHERE c1.email = c2.email \
AND c1.created_at < c2.created_at;
SELECT id FROM contacts ORDER BY id;
UPDATE users \
SET score = users.score + bonuses.bonus \
FROM bonuses \
WHERE users.id = bonuses.user_id \
RETURNING users.id, users.score;
DELETE FROM products \
USING discontinued_categories \
WHERE products.category = discontinued_categories.category \
RETURNING products.id, products.name;
WITH high_scorers AS ( \
SELECT user_id FROM scores WHERE points >= 1000 \
) \
UPDATE users \
SET level = 'advanced' \
FROM high_scorers \
WHERE users.id = high_scorers.user_id;
SELECT level FROM users WHERE id = 1;
WITH inactive AS ( \
SELECT user_id FROM activity WHERE last_active > 60 \
) \
DELETE FROM sessions \
USING inactive \
WHERE sessions.user_id = inactive.user_id;
SELECT COUNT(*) FROM sessions;
UPDATE t1 \
SET value = t2.value \
FROM t2 \
WHERE id = t2.id;
DELETE FROM users \
USING filter \
WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \
SET value = n2.value + 1 \
FROM nums n2 \
WHERE n1.id = n2.id;
SELECT value FROM nums WHERE id = 1;
UPDATE items \
SET price = items.price * price_changes.multiplier \
FROM price_changes \
WHERE items.id = price_changes.item_id;
SELECT price FROM items WHERE id = 1;
SELECT price FROM items WHERE id = 100;
DELETE FROM records \
USING to_remove \
WHERE records.id = to_remove.record_id;
SELECT COUNT(*) FROM records;

-- ============================================================================
-- Test: test_update_from_multiple_columns
-- Source: join_based_dml_comprehensive_tdd.rs:78
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64, category STRING);
DROP TABLE IF EXISTS price_updates;
CREATE TABLE price_updates (product_id INT64, new_price FLOAT64, new_category STRING);
INSERT INTO products VALUES (1, 'Widget', 10.0, 'tools');
INSERT INTO price_updates VALUES (1, 15.0, 'hardware');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (user_id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO updates VALUES (99, 'Charlie');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
DROP TABLE IF EXISTS email_updates;
CREATE TABLE email_updates (user_id INT64, new_email STRING);
INSERT INTO users VALUES (1, 'alice@old.com');
INSERT INTO email_updates VALUES (1, NULL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (id INT64, amount FLOAT64);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (price_id INT64, factor FLOAT64);
INSERT INTO prices VALUES (1, 100.0);
INSERT INTO multipliers VALUES (1, 1.5);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, discount FLOAT64);
DROP TABLE IF EXISTS promotions;
CREATE TABLE promotions (user_id INT64, extra_discount FLOAT64);
INSERT INTO orders VALUES (1, 1, 100.0);
INSERT INTO users VALUES (1, 0.1);
INSERT INTO promotions VALUES (1, 0.05);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, manager_name STRING);
INSERT INTO employees VALUES (1, 'Alice', NULL, NULL), (2, 'Bob', 1, NULL);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (id INT64, item STRING, quantity INT64);
DROP TABLE IF EXISTS adjustments;
CREATE TABLE adjustments (item STRING, delta INT64);
INSERT INTO inventory VALUES (1, 'widget', 100), (2, 'gadget', 50);
INSERT INTO adjustments VALUES ('widget', -10), ('gadget', -60);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO to_delete VALUES (1), (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO to_delete VALUES (99);
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64);
DROP TABLE IF EXISTS cleanup;
CREATE TABLE cleanup (flag BOOL);
INSERT INTO temp VALUES (1), (2), (3);
INSERT INTO cleanup VALUES (TRUE);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, amount FLOAT64, status STRING);
DROP TABLE IF EXISTS cancelled_users;
CREATE TABLE cancelled_users (user_id INT64);
INSERT INTO orders VALUES \
(1, 1, 100.0, 'pending'), \
(2, 1, 200.0, 'completed'), \
(3, 2, 150.0, 'pending');
INSERT INTO cancelled_users VALUES (1);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, type STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (user_id INT64);
DROP TABLE IF EXISTS log_types_to_clean;
CREATE TABLE log_types_to_clean (type STRING);
INSERT INTO logs VALUES \
(1, 1, 'debug'), \
(2, 1, 'error'), \
(3, 2, 'debug');
INSERT INTO inactive_users VALUES (1);
INSERT INTO log_types_to_clean VALUES ('debug');
DROP TABLE IF EXISTS contacts;
CREATE TABLE contacts (id INT64, email STRING, created_at INT64);
INSERT INTO contacts VALUES \
(1, 'alice@example.com', 1), \
(2, 'alice@example.com', 2), \
(3, 'bob@example.com', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, score INT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (user_id INT64, bonus INT64);
INSERT INTO users VALUES (1, 100), (2, 200);
INSERT INTO bonuses VALUES (1, 50);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category STRING);
DROP TABLE IF EXISTS discontinued_categories;
CREATE TABLE discontinued_categories (category STRING);
INSERT INTO products VALUES \
(1, 'Widget', 'tools'), \
(2, 'Gadget', 'electronics');
INSERT INTO discontinued_categories VALUES ('tools');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, level STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, points INT64);
INSERT INTO users VALUES (1, 'beginner'), (2, 'beginner');
INSERT INTO scores VALUES (1, 1000), (2, 500);
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

UPDATE products \
SET price = price_updates.new_price, \
category = price_updates.new_category \
FROM price_updates \
WHERE products.id = price_updates.product_id;
SELECT price, category FROM products WHERE id = 1;
UPDATE users \
SET name = updates.new_name \
FROM updates \
WHERE users.id = updates.user_id;
SELECT name FROM users ORDER BY id;
UPDATE users \
SET email = email_updates.new_email \
FROM email_updates \
WHERE users.id = email_updates.user_id;
SELECT email FROM users WHERE id = 1;
UPDATE prices \
SET amount = prices.amount * multipliers.factor \
FROM multipliers \
WHERE prices.id = multipliers.price_id;
SELECT amount FROM prices WHERE id = 1;
UPDATE orders \
SET total = orders.total * (1.0 - users.discount - promotions.extra_discount) \
FROM users, promotions \
WHERE orders.user_id = users.id \
AND orders.user_id = promotions.user_id;
SELECT total FROM orders WHERE id = 1;
UPDATE employees e1 \
SET manager_name = e2.name \
FROM employees e2 \
WHERE e1.manager_id = e2.id;
SELECT manager_name FROM employees WHERE id = 2;
UPDATE inventory \
SET quantity = inventory.quantity + adjustments.delta \
FROM adjustments \
WHERE inventory.item = adjustments.item \
AND inventory.quantity + adjustments.delta >= 0;
SELECT quantity FROM inventory WHERE item = 'widget';
SELECT quantity FROM inventory WHERE item = 'gadget';
DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT name FROM users;
DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT COUNT(*) FROM users;
DELETE FROM temp \
USING cleanup \
WHERE cleanup.flag = TRUE;
SELECT COUNT(*) FROM temp;
DELETE FROM orders \
USING cancelled_users \
WHERE orders.user_id = cancelled_users.user_id \
AND orders.status = 'pending';
SELECT id FROM orders WHERE user_id = 1 ORDER BY id;
DELETE FROM logs \
USING inactive_users, log_types_to_clean \
WHERE logs.user_id = inactive_users.user_id \
AND logs.type = log_types_to_clean.type;
SELECT id FROM logs ORDER BY id;
DELETE FROM contacts c1 \
USING contacts c2 \
WHERE c1.email = c2.email \
AND c1.created_at < c2.created_at;
SELECT id FROM contacts ORDER BY id;
UPDATE users \
SET score = users.score + bonuses.bonus \
FROM bonuses \
WHERE users.id = bonuses.user_id \
RETURNING users.id, users.score;
DELETE FROM products \
USING discontinued_categories \
WHERE products.category = discontinued_categories.category \
RETURNING products.id, products.name;
WITH high_scorers AS ( \
SELECT user_id FROM scores WHERE points >= 1000 \
) \
UPDATE users \
SET level = 'advanced' \
FROM high_scorers \
WHERE users.id = high_scorers.user_id;
SELECT level FROM users WHERE id = 1;
WITH inactive AS ( \
SELECT user_id FROM activity WHERE last_active > 60 \
) \
DELETE FROM sessions \
USING inactive \
WHERE sessions.user_id = inactive.user_id;
SELECT COUNT(*) FROM sessions;
UPDATE t1 \
SET value = t2.value \
FROM t2 \
WHERE id = t2.id;
DELETE FROM users \
USING filter \
WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \
SET value = n2.value + 1 \
FROM nums n2 \
WHERE n1.id = n2.id;
SELECT value FROM nums WHERE id = 1;
UPDATE items \
SET price = items.price * price_changes.multiplier \
FROM price_changes \
WHERE items.id = price_changes.item_id;
SELECT price FROM items WHERE id = 1;
SELECT price FROM items WHERE id = 100;
DELETE FROM records \
USING to_remove \
WHERE records.id = to_remove.record_id;
SELECT COUNT(*) FROM records;

-- ============================================================================
-- Test: test_update_from_no_matches
-- Source: join_based_dml_comprehensive_tdd.rs:125
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (user_id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO updates VALUES (99, 'Charlie');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
DROP TABLE IF EXISTS email_updates;
CREATE TABLE email_updates (user_id INT64, new_email STRING);
INSERT INTO users VALUES (1, 'alice@old.com');
INSERT INTO email_updates VALUES (1, NULL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (id INT64, amount FLOAT64);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (price_id INT64, factor FLOAT64);
INSERT INTO prices VALUES (1, 100.0);
INSERT INTO multipliers VALUES (1, 1.5);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, discount FLOAT64);
DROP TABLE IF EXISTS promotions;
CREATE TABLE promotions (user_id INT64, extra_discount FLOAT64);
INSERT INTO orders VALUES (1, 1, 100.0);
INSERT INTO users VALUES (1, 0.1);
INSERT INTO promotions VALUES (1, 0.05);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, manager_name STRING);
INSERT INTO employees VALUES (1, 'Alice', NULL, NULL), (2, 'Bob', 1, NULL);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (id INT64, item STRING, quantity INT64);
DROP TABLE IF EXISTS adjustments;
CREATE TABLE adjustments (item STRING, delta INT64);
INSERT INTO inventory VALUES (1, 'widget', 100), (2, 'gadget', 50);
INSERT INTO adjustments VALUES ('widget', -10), ('gadget', -60);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO to_delete VALUES (1), (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO to_delete VALUES (99);
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64);
DROP TABLE IF EXISTS cleanup;
CREATE TABLE cleanup (flag BOOL);
INSERT INTO temp VALUES (1), (2), (3);
INSERT INTO cleanup VALUES (TRUE);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, amount FLOAT64, status STRING);
DROP TABLE IF EXISTS cancelled_users;
CREATE TABLE cancelled_users (user_id INT64);
INSERT INTO orders VALUES \
(1, 1, 100.0, 'pending'), \
(2, 1, 200.0, 'completed'), \
(3, 2, 150.0, 'pending');
INSERT INTO cancelled_users VALUES (1);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, type STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (user_id INT64);
DROP TABLE IF EXISTS log_types_to_clean;
CREATE TABLE log_types_to_clean (type STRING);
INSERT INTO logs VALUES \
(1, 1, 'debug'), \
(2, 1, 'error'), \
(3, 2, 'debug');
INSERT INTO inactive_users VALUES (1);
INSERT INTO log_types_to_clean VALUES ('debug');
DROP TABLE IF EXISTS contacts;
CREATE TABLE contacts (id INT64, email STRING, created_at INT64);
INSERT INTO contacts VALUES \
(1, 'alice@example.com', 1), \
(2, 'alice@example.com', 2), \
(3, 'bob@example.com', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, score INT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (user_id INT64, bonus INT64);
INSERT INTO users VALUES (1, 100), (2, 200);
INSERT INTO bonuses VALUES (1, 50);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category STRING);
DROP TABLE IF EXISTS discontinued_categories;
CREATE TABLE discontinued_categories (category STRING);
INSERT INTO products VALUES \
(1, 'Widget', 'tools'), \
(2, 'Gadget', 'electronics');
INSERT INTO discontinued_categories VALUES ('tools');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, level STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, points INT64);
INSERT INTO users VALUES (1, 'beginner'), (2, 'beginner');
INSERT INTO scores VALUES (1, 1000), (2, 500);
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

UPDATE users \
SET name = updates.new_name \
FROM updates \
WHERE users.id = updates.user_id;
SELECT name FROM users ORDER BY id;
UPDATE users \
SET email = email_updates.new_email \
FROM email_updates \
WHERE users.id = email_updates.user_id;
SELECT email FROM users WHERE id = 1;
UPDATE prices \
SET amount = prices.amount * multipliers.factor \
FROM multipliers \
WHERE prices.id = multipliers.price_id;
SELECT amount FROM prices WHERE id = 1;
UPDATE orders \
SET total = orders.total * (1.0 - users.discount - promotions.extra_discount) \
FROM users, promotions \
WHERE orders.user_id = users.id \
AND orders.user_id = promotions.user_id;
SELECT total FROM orders WHERE id = 1;
UPDATE employees e1 \
SET manager_name = e2.name \
FROM employees e2 \
WHERE e1.manager_id = e2.id;
SELECT manager_name FROM employees WHERE id = 2;
UPDATE inventory \
SET quantity = inventory.quantity + adjustments.delta \
FROM adjustments \
WHERE inventory.item = adjustments.item \
AND inventory.quantity + adjustments.delta >= 0;
SELECT quantity FROM inventory WHERE item = 'widget';
SELECT quantity FROM inventory WHERE item = 'gadget';
DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT name FROM users;
DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT COUNT(*) FROM users;
DELETE FROM temp \
USING cleanup \
WHERE cleanup.flag = TRUE;
SELECT COUNT(*) FROM temp;
DELETE FROM orders \
USING cancelled_users \
WHERE orders.user_id = cancelled_users.user_id \
AND orders.status = 'pending';
SELECT id FROM orders WHERE user_id = 1 ORDER BY id;
DELETE FROM logs \
USING inactive_users, log_types_to_clean \
WHERE logs.user_id = inactive_users.user_id \
AND logs.type = log_types_to_clean.type;
SELECT id FROM logs ORDER BY id;
DELETE FROM contacts c1 \
USING contacts c2 \
WHERE c1.email = c2.email \
AND c1.created_at < c2.created_at;
SELECT id FROM contacts ORDER BY id;
UPDATE users \
SET score = users.score + bonuses.bonus \
FROM bonuses \
WHERE users.id = bonuses.user_id \
RETURNING users.id, users.score;
DELETE FROM products \
USING discontinued_categories \
WHERE products.category = discontinued_categories.category \
RETURNING products.id, products.name;
WITH high_scorers AS ( \
SELECT user_id FROM scores WHERE points >= 1000 \
) \
UPDATE users \
SET level = 'advanced' \
FROM high_scorers \
WHERE users.id = high_scorers.user_id;
SELECT level FROM users WHERE id = 1;
WITH inactive AS ( \
SELECT user_id FROM activity WHERE last_active > 60 \
) \
DELETE FROM sessions \
USING inactive \
WHERE sessions.user_id = inactive.user_id;
SELECT COUNT(*) FROM sessions;
UPDATE t1 \
SET value = t2.value \
FROM t2 \
WHERE id = t2.id;
DELETE FROM users \
USING filter \
WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \
SET value = n2.value + 1 \
FROM nums n2 \
WHERE n1.id = n2.id;
SELECT value FROM nums WHERE id = 1;
UPDATE items \
SET price = items.price * price_changes.multiplier \
FROM price_changes \
WHERE items.id = price_changes.item_id;
SELECT price FROM items WHERE id = 1;
SELECT price FROM items WHERE id = 100;
DELETE FROM records \
USING to_remove \
WHERE records.id = to_remove.record_id;
SELECT COUNT(*) FROM records;

-- ============================================================================
-- Test: test_update_from_with_null_values
-- Source: join_based_dml_comprehensive_tdd.rs:170
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
DROP TABLE IF EXISTS email_updates;
CREATE TABLE email_updates (user_id INT64, new_email STRING);
INSERT INTO users VALUES (1, 'alice@old.com');
INSERT INTO email_updates VALUES (1, NULL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (id INT64, amount FLOAT64);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (price_id INT64, factor FLOAT64);
INSERT INTO prices VALUES (1, 100.0);
INSERT INTO multipliers VALUES (1, 1.5);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, discount FLOAT64);
DROP TABLE IF EXISTS promotions;
CREATE TABLE promotions (user_id INT64, extra_discount FLOAT64);
INSERT INTO orders VALUES (1, 1, 100.0);
INSERT INTO users VALUES (1, 0.1);
INSERT INTO promotions VALUES (1, 0.05);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, manager_name STRING);
INSERT INTO employees VALUES (1, 'Alice', NULL, NULL), (2, 'Bob', 1, NULL);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (id INT64, item STRING, quantity INT64);
DROP TABLE IF EXISTS adjustments;
CREATE TABLE adjustments (item STRING, delta INT64);
INSERT INTO inventory VALUES (1, 'widget', 100), (2, 'gadget', 50);
INSERT INTO adjustments VALUES ('widget', -10), ('gadget', -60);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO to_delete VALUES (1), (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO to_delete VALUES (99);
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64);
DROP TABLE IF EXISTS cleanup;
CREATE TABLE cleanup (flag BOOL);
INSERT INTO temp VALUES (1), (2), (3);
INSERT INTO cleanup VALUES (TRUE);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, amount FLOAT64, status STRING);
DROP TABLE IF EXISTS cancelled_users;
CREATE TABLE cancelled_users (user_id INT64);
INSERT INTO orders VALUES \
(1, 1, 100.0, 'pending'), \
(2, 1, 200.0, 'completed'), \
(3, 2, 150.0, 'pending');
INSERT INTO cancelled_users VALUES (1);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, type STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (user_id INT64);
DROP TABLE IF EXISTS log_types_to_clean;
CREATE TABLE log_types_to_clean (type STRING);
INSERT INTO logs VALUES \
(1, 1, 'debug'), \
(2, 1, 'error'), \
(3, 2, 'debug');
INSERT INTO inactive_users VALUES (1);
INSERT INTO log_types_to_clean VALUES ('debug');
DROP TABLE IF EXISTS contacts;
CREATE TABLE contacts (id INT64, email STRING, created_at INT64);
INSERT INTO contacts VALUES \
(1, 'alice@example.com', 1), \
(2, 'alice@example.com', 2), \
(3, 'bob@example.com', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, score INT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (user_id INT64, bonus INT64);
INSERT INTO users VALUES (1, 100), (2, 200);
INSERT INTO bonuses VALUES (1, 50);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category STRING);
DROP TABLE IF EXISTS discontinued_categories;
CREATE TABLE discontinued_categories (category STRING);
INSERT INTO products VALUES \
(1, 'Widget', 'tools'), \
(2, 'Gadget', 'electronics');
INSERT INTO discontinued_categories VALUES ('tools');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, level STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, points INT64);
INSERT INTO users VALUES (1, 'beginner'), (2, 'beginner');
INSERT INTO scores VALUES (1, 1000), (2, 500);
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

UPDATE users \
SET email = email_updates.new_email \
FROM email_updates \
WHERE users.id = email_updates.user_id;
SELECT email FROM users WHERE id = 1;
UPDATE prices \
SET amount = prices.amount * multipliers.factor \
FROM multipliers \
WHERE prices.id = multipliers.price_id;
SELECT amount FROM prices WHERE id = 1;
UPDATE orders \
SET total = orders.total * (1.0 - users.discount - promotions.extra_discount) \
FROM users, promotions \
WHERE orders.user_id = users.id \
AND orders.user_id = promotions.user_id;
SELECT total FROM orders WHERE id = 1;
UPDATE employees e1 \
SET manager_name = e2.name \
FROM employees e2 \
WHERE e1.manager_id = e2.id;
SELECT manager_name FROM employees WHERE id = 2;
UPDATE inventory \
SET quantity = inventory.quantity + adjustments.delta \
FROM adjustments \
WHERE inventory.item = adjustments.item \
AND inventory.quantity + adjustments.delta >= 0;
SELECT quantity FROM inventory WHERE item = 'widget';
SELECT quantity FROM inventory WHERE item = 'gadget';
DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT name FROM users;
DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT COUNT(*) FROM users;
DELETE FROM temp \
USING cleanup \
WHERE cleanup.flag = TRUE;
SELECT COUNT(*) FROM temp;
DELETE FROM orders \
USING cancelled_users \
WHERE orders.user_id = cancelled_users.user_id \
AND orders.status = 'pending';
SELECT id FROM orders WHERE user_id = 1 ORDER BY id;
DELETE FROM logs \
USING inactive_users, log_types_to_clean \
WHERE logs.user_id = inactive_users.user_id \
AND logs.type = log_types_to_clean.type;
SELECT id FROM logs ORDER BY id;
DELETE FROM contacts c1 \
USING contacts c2 \
WHERE c1.email = c2.email \
AND c1.created_at < c2.created_at;
SELECT id FROM contacts ORDER BY id;
UPDATE users \
SET score = users.score + bonuses.bonus \
FROM bonuses \
WHERE users.id = bonuses.user_id \
RETURNING users.id, users.score;
DELETE FROM products \
USING discontinued_categories \
WHERE products.category = discontinued_categories.category \
RETURNING products.id, products.name;
WITH high_scorers AS ( \
SELECT user_id FROM scores WHERE points >= 1000 \
) \
UPDATE users \
SET level = 'advanced' \
FROM high_scorers \
WHERE users.id = high_scorers.user_id;
SELECT level FROM users WHERE id = 1;
WITH inactive AS ( \
SELECT user_id FROM activity WHERE last_active > 60 \
) \
DELETE FROM sessions \
USING inactive \
WHERE sessions.user_id = inactive.user_id;
SELECT COUNT(*) FROM sessions;
UPDATE t1 \
SET value = t2.value \
FROM t2 \
WHERE id = t2.id;
DELETE FROM users \
USING filter \
WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \
SET value = n2.value + 1 \
FROM nums n2 \
WHERE n1.id = n2.id;
SELECT value FROM nums WHERE id = 1;
UPDATE items \
SET price = items.price * price_changes.multiplier \
FROM price_changes \
WHERE items.id = price_changes.item_id;
SELECT price FROM items WHERE id = 1;
SELECT price FROM items WHERE id = 100;
DELETE FROM records \
USING to_remove \
WHERE records.id = to_remove.record_id;
SELECT COUNT(*) FROM records;

-- ============================================================================
-- Test: test_update_from_with_expression
-- Source: join_based_dml_comprehensive_tdd.rs:205
-- ============================================================================
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (id INT64, amount FLOAT64);
DROP TABLE IF EXISTS multipliers;
CREATE TABLE multipliers (price_id INT64, factor FLOAT64);
INSERT INTO prices VALUES (1, 100.0);
INSERT INTO multipliers VALUES (1, 1.5);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, discount FLOAT64);
DROP TABLE IF EXISTS promotions;
CREATE TABLE promotions (user_id INT64, extra_discount FLOAT64);
INSERT INTO orders VALUES (1, 1, 100.0);
INSERT INTO users VALUES (1, 0.1);
INSERT INTO promotions VALUES (1, 0.05);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, manager_name STRING);
INSERT INTO employees VALUES (1, 'Alice', NULL, NULL), (2, 'Bob', 1, NULL);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (id INT64, item STRING, quantity INT64);
DROP TABLE IF EXISTS adjustments;
CREATE TABLE adjustments (item STRING, delta INT64);
INSERT INTO inventory VALUES (1, 'widget', 100), (2, 'gadget', 50);
INSERT INTO adjustments VALUES ('widget', -10), ('gadget', -60);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO to_delete VALUES (1), (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO to_delete VALUES (99);
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64);
DROP TABLE IF EXISTS cleanup;
CREATE TABLE cleanup (flag BOOL);
INSERT INTO temp VALUES (1), (2), (3);
INSERT INTO cleanup VALUES (TRUE);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, amount FLOAT64, status STRING);
DROP TABLE IF EXISTS cancelled_users;
CREATE TABLE cancelled_users (user_id INT64);
INSERT INTO orders VALUES \
(1, 1, 100.0, 'pending'), \
(2, 1, 200.0, 'completed'), \
(3, 2, 150.0, 'pending');
INSERT INTO cancelled_users VALUES (1);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, type STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (user_id INT64);
DROP TABLE IF EXISTS log_types_to_clean;
CREATE TABLE log_types_to_clean (type STRING);
INSERT INTO logs VALUES \
(1, 1, 'debug'), \
(2, 1, 'error'), \
(3, 2, 'debug');
INSERT INTO inactive_users VALUES (1);
INSERT INTO log_types_to_clean VALUES ('debug');
DROP TABLE IF EXISTS contacts;
CREATE TABLE contacts (id INT64, email STRING, created_at INT64);
INSERT INTO contacts VALUES \
(1, 'alice@example.com', 1), \
(2, 'alice@example.com', 2), \
(3, 'bob@example.com', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, score INT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (user_id INT64, bonus INT64);
INSERT INTO users VALUES (1, 100), (2, 200);
INSERT INTO bonuses VALUES (1, 50);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category STRING);
DROP TABLE IF EXISTS discontinued_categories;
CREATE TABLE discontinued_categories (category STRING);
INSERT INTO products VALUES \
(1, 'Widget', 'tools'), \
(2, 'Gadget', 'electronics');
INSERT INTO discontinued_categories VALUES ('tools');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, level STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, points INT64);
INSERT INTO users VALUES (1, 'beginner'), (2, 'beginner');
INSERT INTO scores VALUES (1, 1000), (2, 500);
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

UPDATE prices \
SET amount = prices.amount * multipliers.factor \
FROM multipliers \
WHERE prices.id = multipliers.price_id;
SELECT amount FROM prices WHERE id = 1;
UPDATE orders \
SET total = orders.total * (1.0 - users.discount - promotions.extra_discount) \
FROM users, promotions \
WHERE orders.user_id = users.id \
AND orders.user_id = promotions.user_id;
SELECT total FROM orders WHERE id = 1;
UPDATE employees e1 \
SET manager_name = e2.name \
FROM employees e2 \
WHERE e1.manager_id = e2.id;
SELECT manager_name FROM employees WHERE id = 2;
UPDATE inventory \
SET quantity = inventory.quantity + adjustments.delta \
FROM adjustments \
WHERE inventory.item = adjustments.item \
AND inventory.quantity + adjustments.delta >= 0;
SELECT quantity FROM inventory WHERE item = 'widget';
SELECT quantity FROM inventory WHERE item = 'gadget';
DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT name FROM users;
DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT COUNT(*) FROM users;
DELETE FROM temp \
USING cleanup \
WHERE cleanup.flag = TRUE;
SELECT COUNT(*) FROM temp;
DELETE FROM orders \
USING cancelled_users \
WHERE orders.user_id = cancelled_users.user_id \
AND orders.status = 'pending';
SELECT id FROM orders WHERE user_id = 1 ORDER BY id;
DELETE FROM logs \
USING inactive_users, log_types_to_clean \
WHERE logs.user_id = inactive_users.user_id \
AND logs.type = log_types_to_clean.type;
SELECT id FROM logs ORDER BY id;
DELETE FROM contacts c1 \
USING contacts c2 \
WHERE c1.email = c2.email \
AND c1.created_at < c2.created_at;
SELECT id FROM contacts ORDER BY id;
UPDATE users \
SET score = users.score + bonuses.bonus \
FROM bonuses \
WHERE users.id = bonuses.user_id \
RETURNING users.id, users.score;
DELETE FROM products \
USING discontinued_categories \
WHERE products.category = discontinued_categories.category \
RETURNING products.id, products.name;
WITH high_scorers AS ( \
SELECT user_id FROM scores WHERE points >= 1000 \
) \
UPDATE users \
SET level = 'advanced' \
FROM high_scorers \
WHERE users.id = high_scorers.user_id;
SELECT level FROM users WHERE id = 1;
WITH inactive AS ( \
SELECT user_id FROM activity WHERE last_active > 60 \
) \
DELETE FROM sessions \
USING inactive \
WHERE sessions.user_id = inactive.user_id;
SELECT COUNT(*) FROM sessions;
UPDATE t1 \
SET value = t2.value \
FROM t2 \
WHERE id = t2.id;
DELETE FROM users \
USING filter \
WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \
SET value = n2.value + 1 \
FROM nums n2 \
WHERE n1.id = n2.id;
SELECT value FROM nums WHERE id = 1;
UPDATE items \
SET price = items.price * price_changes.multiplier \
FROM price_changes \
WHERE items.id = price_changes.item_id;
SELECT price FROM items WHERE id = 1;
SELECT price FROM items WHERE id = 100;
DELETE FROM records \
USING to_remove \
WHERE records.id = to_remove.record_id;
SELECT COUNT(*) FROM records;

-- ============================================================================
-- Test: test_update_from_multiple_joins
-- Source: join_based_dml_comprehensive_tdd.rs:243
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, discount FLOAT64);
DROP TABLE IF EXISTS promotions;
CREATE TABLE promotions (user_id INT64, extra_discount FLOAT64);
INSERT INTO orders VALUES (1, 1, 100.0);
INSERT INTO users VALUES (1, 0.1);
INSERT INTO promotions VALUES (1, 0.05);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, manager_name STRING);
INSERT INTO employees VALUES (1, 'Alice', NULL, NULL), (2, 'Bob', 1, NULL);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (id INT64, item STRING, quantity INT64);
DROP TABLE IF EXISTS adjustments;
CREATE TABLE adjustments (item STRING, delta INT64);
INSERT INTO inventory VALUES (1, 'widget', 100), (2, 'gadget', 50);
INSERT INTO adjustments VALUES ('widget', -10), ('gadget', -60);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO to_delete VALUES (1), (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO to_delete VALUES (99);
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64);
DROP TABLE IF EXISTS cleanup;
CREATE TABLE cleanup (flag BOOL);
INSERT INTO temp VALUES (1), (2), (3);
INSERT INTO cleanup VALUES (TRUE);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, amount FLOAT64, status STRING);
DROP TABLE IF EXISTS cancelled_users;
CREATE TABLE cancelled_users (user_id INT64);
INSERT INTO orders VALUES \
(1, 1, 100.0, 'pending'), \
(2, 1, 200.0, 'completed'), \
(3, 2, 150.0, 'pending');
INSERT INTO cancelled_users VALUES (1);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, type STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (user_id INT64);
DROP TABLE IF EXISTS log_types_to_clean;
CREATE TABLE log_types_to_clean (type STRING);
INSERT INTO logs VALUES \
(1, 1, 'debug'), \
(2, 1, 'error'), \
(3, 2, 'debug');
INSERT INTO inactive_users VALUES (1);
INSERT INTO log_types_to_clean VALUES ('debug');
DROP TABLE IF EXISTS contacts;
CREATE TABLE contacts (id INT64, email STRING, created_at INT64);
INSERT INTO contacts VALUES \
(1, 'alice@example.com', 1), \
(2, 'alice@example.com', 2), \
(3, 'bob@example.com', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, score INT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (user_id INT64, bonus INT64);
INSERT INTO users VALUES (1, 100), (2, 200);
INSERT INTO bonuses VALUES (1, 50);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category STRING);
DROP TABLE IF EXISTS discontinued_categories;
CREATE TABLE discontinued_categories (category STRING);
INSERT INTO products VALUES \
(1, 'Widget', 'tools'), \
(2, 'Gadget', 'electronics');
INSERT INTO discontinued_categories VALUES ('tools');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, level STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, points INT64);
INSERT INTO users VALUES (1, 'beginner'), (2, 'beginner');
INSERT INTO scores VALUES (1, 1000), (2, 500);
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

UPDATE orders \
SET total = orders.total * (1.0 - users.discount - promotions.extra_discount) \
FROM users, promotions \
WHERE orders.user_id = users.id \
AND orders.user_id = promotions.user_id;
SELECT total FROM orders WHERE id = 1;
UPDATE employees e1 \
SET manager_name = e2.name \
FROM employees e2 \
WHERE e1.manager_id = e2.id;
SELECT manager_name FROM employees WHERE id = 2;
UPDATE inventory \
SET quantity = inventory.quantity + adjustments.delta \
FROM adjustments \
WHERE inventory.item = adjustments.item \
AND inventory.quantity + adjustments.delta >= 0;
SELECT quantity FROM inventory WHERE item = 'widget';
SELECT quantity FROM inventory WHERE item = 'gadget';
DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT name FROM users;
DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT COUNT(*) FROM users;
DELETE FROM temp \
USING cleanup \
WHERE cleanup.flag = TRUE;
SELECT COUNT(*) FROM temp;
DELETE FROM orders \
USING cancelled_users \
WHERE orders.user_id = cancelled_users.user_id \
AND orders.status = 'pending';
SELECT id FROM orders WHERE user_id = 1 ORDER BY id;
DELETE FROM logs \
USING inactive_users, log_types_to_clean \
WHERE logs.user_id = inactive_users.user_id \
AND logs.type = log_types_to_clean.type;
SELECT id FROM logs ORDER BY id;
DELETE FROM contacts c1 \
USING contacts c2 \
WHERE c1.email = c2.email \
AND c1.created_at < c2.created_at;
SELECT id FROM contacts ORDER BY id;
UPDATE users \
SET score = users.score + bonuses.bonus \
FROM bonuses \
WHERE users.id = bonuses.user_id \
RETURNING users.id, users.score;
DELETE FROM products \
USING discontinued_categories \
WHERE products.category = discontinued_categories.category \
RETURNING products.id, products.name;
WITH high_scorers AS ( \
SELECT user_id FROM scores WHERE points >= 1000 \
) \
UPDATE users \
SET level = 'advanced' \
FROM high_scorers \
WHERE users.id = high_scorers.user_id;
SELECT level FROM users WHERE id = 1;
WITH inactive AS ( \
SELECT user_id FROM activity WHERE last_active > 60 \
) \
DELETE FROM sessions \
USING inactive \
WHERE sessions.user_id = inactive.user_id;
SELECT COUNT(*) FROM sessions;
UPDATE t1 \
SET value = t2.value \
FROM t2 \
WHERE id = t2.id;
DELETE FROM users \
USING filter \
WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \
SET value = n2.value + 1 \
FROM nums n2 \
WHERE n1.id = n2.id;
SELECT value FROM nums WHERE id = 1;
UPDATE items \
SET price = items.price * price_changes.multiplier \
FROM price_changes \
WHERE items.id = price_changes.item_id;
SELECT price FROM items WHERE id = 1;
SELECT price FROM items WHERE id = 100;
DELETE FROM records \
USING to_remove \
WHERE records.id = to_remove.record_id;
SELECT COUNT(*) FROM records;

-- ============================================================================
-- Test: test_update_from_self_join
-- Source: join_based_dml_comprehensive_tdd.rs:289
-- ============================================================================
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64, manager_name STRING);
INSERT INTO employees VALUES (1, 'Alice', NULL, NULL), (2, 'Bob', 1, NULL);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (id INT64, item STRING, quantity INT64);
DROP TABLE IF EXISTS adjustments;
CREATE TABLE adjustments (item STRING, delta INT64);
INSERT INTO inventory VALUES (1, 'widget', 100), (2, 'gadget', 50);
INSERT INTO adjustments VALUES ('widget', -10), ('gadget', -60);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO to_delete VALUES (1), (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO to_delete VALUES (99);
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64);
DROP TABLE IF EXISTS cleanup;
CREATE TABLE cleanup (flag BOOL);
INSERT INTO temp VALUES (1), (2), (3);
INSERT INTO cleanup VALUES (TRUE);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, amount FLOAT64, status STRING);
DROP TABLE IF EXISTS cancelled_users;
CREATE TABLE cancelled_users (user_id INT64);
INSERT INTO orders VALUES \
(1, 1, 100.0, 'pending'), \
(2, 1, 200.0, 'completed'), \
(3, 2, 150.0, 'pending');
INSERT INTO cancelled_users VALUES (1);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, type STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (user_id INT64);
DROP TABLE IF EXISTS log_types_to_clean;
CREATE TABLE log_types_to_clean (type STRING);
INSERT INTO logs VALUES \
(1, 1, 'debug'), \
(2, 1, 'error'), \
(3, 2, 'debug');
INSERT INTO inactive_users VALUES (1);
INSERT INTO log_types_to_clean VALUES ('debug');
DROP TABLE IF EXISTS contacts;
CREATE TABLE contacts (id INT64, email STRING, created_at INT64);
INSERT INTO contacts VALUES \
(1, 'alice@example.com', 1), \
(2, 'alice@example.com', 2), \
(3, 'bob@example.com', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, score INT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (user_id INT64, bonus INT64);
INSERT INTO users VALUES (1, 100), (2, 200);
INSERT INTO bonuses VALUES (1, 50);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category STRING);
DROP TABLE IF EXISTS discontinued_categories;
CREATE TABLE discontinued_categories (category STRING);
INSERT INTO products VALUES \
(1, 'Widget', 'tools'), \
(2, 'Gadget', 'electronics');
INSERT INTO discontinued_categories VALUES ('tools');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, level STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, points INT64);
INSERT INTO users VALUES (1, 'beginner'), (2, 'beginner');
INSERT INTO scores VALUES (1, 1000), (2, 500);
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

UPDATE employees e1 \
SET manager_name = e2.name \
FROM employees e2 \
WHERE e1.manager_id = e2.id;
SELECT manager_name FROM employees WHERE id = 2;
UPDATE inventory \
SET quantity = inventory.quantity + adjustments.delta \
FROM adjustments \
WHERE inventory.item = adjustments.item \
AND inventory.quantity + adjustments.delta >= 0;
SELECT quantity FROM inventory WHERE item = 'widget';
SELECT quantity FROM inventory WHERE item = 'gadget';
DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT name FROM users;
DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT COUNT(*) FROM users;
DELETE FROM temp \
USING cleanup \
WHERE cleanup.flag = TRUE;
SELECT COUNT(*) FROM temp;
DELETE FROM orders \
USING cancelled_users \
WHERE orders.user_id = cancelled_users.user_id \
AND orders.status = 'pending';
SELECT id FROM orders WHERE user_id = 1 ORDER BY id;
DELETE FROM logs \
USING inactive_users, log_types_to_clean \
WHERE logs.user_id = inactive_users.user_id \
AND logs.type = log_types_to_clean.type;
SELECT id FROM logs ORDER BY id;
DELETE FROM contacts c1 \
USING contacts c2 \
WHERE c1.email = c2.email \
AND c1.created_at < c2.created_at;
SELECT id FROM contacts ORDER BY id;
UPDATE users \
SET score = users.score + bonuses.bonus \
FROM bonuses \
WHERE users.id = bonuses.user_id \
RETURNING users.id, users.score;
DELETE FROM products \
USING discontinued_categories \
WHERE products.category = discontinued_categories.category \
RETURNING products.id, products.name;
WITH high_scorers AS ( \
SELECT user_id FROM scores WHERE points >= 1000 \
) \
UPDATE users \
SET level = 'advanced' \
FROM high_scorers \
WHERE users.id = high_scorers.user_id;
SELECT level FROM users WHERE id = 1;
WITH inactive AS ( \
SELECT user_id FROM activity WHERE last_active > 60 \
) \
DELETE FROM sessions \
USING inactive \
WHERE sessions.user_id = inactive.user_id;
SELECT COUNT(*) FROM sessions;
UPDATE t1 \
SET value = t2.value \
FROM t2 \
WHERE id = t2.id;
DELETE FROM users \
USING filter \
WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \
SET value = n2.value + 1 \
FROM nums n2 \
WHERE n1.id = n2.id;
SELECT value FROM nums WHERE id = 1;
UPDATE items \
SET price = items.price * price_changes.multiplier \
FROM price_changes \
WHERE items.id = price_changes.item_id;
SELECT price FROM items WHERE id = 1;
SELECT price FROM items WHERE id = 100;
DELETE FROM records \
USING to_remove \
WHERE records.id = to_remove.record_id;
SELECT COUNT(*) FROM records;

-- ============================================================================
-- Test: test_update_from_with_additional_where
-- Source: join_based_dml_comprehensive_tdd.rs:324
-- ============================================================================
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (id INT64, item STRING, quantity INT64);
DROP TABLE IF EXISTS adjustments;
CREATE TABLE adjustments (item STRING, delta INT64);
INSERT INTO inventory VALUES (1, 'widget', 100), (2, 'gadget', 50);
INSERT INTO adjustments VALUES ('widget', -10), ('gadget', -60);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO to_delete VALUES (1), (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO to_delete VALUES (99);
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64);
DROP TABLE IF EXISTS cleanup;
CREATE TABLE cleanup (flag BOOL);
INSERT INTO temp VALUES (1), (2), (3);
INSERT INTO cleanup VALUES (TRUE);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, amount FLOAT64, status STRING);
DROP TABLE IF EXISTS cancelled_users;
CREATE TABLE cancelled_users (user_id INT64);
INSERT INTO orders VALUES \
(1, 1, 100.0, 'pending'), \
(2, 1, 200.0, 'completed'), \
(3, 2, 150.0, 'pending');
INSERT INTO cancelled_users VALUES (1);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, type STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (user_id INT64);
DROP TABLE IF EXISTS log_types_to_clean;
CREATE TABLE log_types_to_clean (type STRING);
INSERT INTO logs VALUES \
(1, 1, 'debug'), \
(2, 1, 'error'), \
(3, 2, 'debug');
INSERT INTO inactive_users VALUES (1);
INSERT INTO log_types_to_clean VALUES ('debug');
DROP TABLE IF EXISTS contacts;
CREATE TABLE contacts (id INT64, email STRING, created_at INT64);
INSERT INTO contacts VALUES \
(1, 'alice@example.com', 1), \
(2, 'alice@example.com', 2), \
(3, 'bob@example.com', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, score INT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (user_id INT64, bonus INT64);
INSERT INTO users VALUES (1, 100), (2, 200);
INSERT INTO bonuses VALUES (1, 50);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category STRING);
DROP TABLE IF EXISTS discontinued_categories;
CREATE TABLE discontinued_categories (category STRING);
INSERT INTO products VALUES \
(1, 'Widget', 'tools'), \
(2, 'Gadget', 'electronics');
INSERT INTO discontinued_categories VALUES ('tools');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, level STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, points INT64);
INSERT INTO users VALUES (1, 'beginner'), (2, 'beginner');
INSERT INTO scores VALUES (1, 1000), (2, 500);
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

UPDATE inventory \
SET quantity = inventory.quantity + adjustments.delta \
FROM adjustments \
WHERE inventory.item = adjustments.item \
AND inventory.quantity + adjustments.delta >= 0;
SELECT quantity FROM inventory WHERE item = 'widget';
SELECT quantity FROM inventory WHERE item = 'gadget';
DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT name FROM users;
DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT COUNT(*) FROM users;
DELETE FROM temp \
USING cleanup \
WHERE cleanup.flag = TRUE;
SELECT COUNT(*) FROM temp;
DELETE FROM orders \
USING cancelled_users \
WHERE orders.user_id = cancelled_users.user_id \
AND orders.status = 'pending';
SELECT id FROM orders WHERE user_id = 1 ORDER BY id;
DELETE FROM logs \
USING inactive_users, log_types_to_clean \
WHERE logs.user_id = inactive_users.user_id \
AND logs.type = log_types_to_clean.type;
SELECT id FROM logs ORDER BY id;
DELETE FROM contacts c1 \
USING contacts c2 \
WHERE c1.email = c2.email \
AND c1.created_at < c2.created_at;
SELECT id FROM contacts ORDER BY id;
UPDATE users \
SET score = users.score + bonuses.bonus \
FROM bonuses \
WHERE users.id = bonuses.user_id \
RETURNING users.id, users.score;
DELETE FROM products \
USING discontinued_categories \
WHERE products.category = discontinued_categories.category \
RETURNING products.id, products.name;
WITH high_scorers AS ( \
SELECT user_id FROM scores WHERE points >= 1000 \
) \
UPDATE users \
SET level = 'advanced' \
FROM high_scorers \
WHERE users.id = high_scorers.user_id;
SELECT level FROM users WHERE id = 1;
WITH inactive AS ( \
SELECT user_id FROM activity WHERE last_active > 60 \
) \
DELETE FROM sessions \
USING inactive \
WHERE sessions.user_id = inactive.user_id;
SELECT COUNT(*) FROM sessions;
UPDATE t1 \
SET value = t2.value \
FROM t2 \
WHERE id = t2.id;
DELETE FROM users \
USING filter \
WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \
SET value = n2.value + 1 \
FROM nums n2 \
WHERE n1.id = n2.id;
SELECT value FROM nums WHERE id = 1;
UPDATE items \
SET price = items.price * price_changes.multiplier \
FROM price_changes \
WHERE items.id = price_changes.item_id;
SELECT price FROM items WHERE id = 1;
SELECT price FROM items WHERE id = 100;
DELETE FROM records \
USING to_remove \
WHERE records.id = to_remove.record_id;
SELECT COUNT(*) FROM records;

-- ============================================================================
-- Test: test_delete_using_simple_join
-- Source: join_based_dml_comprehensive_tdd.rs:371
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
INSERT INTO to_delete VALUES (1), (3);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO to_delete VALUES (99);
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64);
DROP TABLE IF EXISTS cleanup;
CREATE TABLE cleanup (flag BOOL);
INSERT INTO temp VALUES (1), (2), (3);
INSERT INTO cleanup VALUES (TRUE);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, amount FLOAT64, status STRING);
DROP TABLE IF EXISTS cancelled_users;
CREATE TABLE cancelled_users (user_id INT64);
INSERT INTO orders VALUES \
(1, 1, 100.0, 'pending'), \
(2, 1, 200.0, 'completed'), \
(3, 2, 150.0, 'pending');
INSERT INTO cancelled_users VALUES (1);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, type STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (user_id INT64);
DROP TABLE IF EXISTS log_types_to_clean;
CREATE TABLE log_types_to_clean (type STRING);
INSERT INTO logs VALUES \
(1, 1, 'debug'), \
(2, 1, 'error'), \
(3, 2, 'debug');
INSERT INTO inactive_users VALUES (1);
INSERT INTO log_types_to_clean VALUES ('debug');
DROP TABLE IF EXISTS contacts;
CREATE TABLE contacts (id INT64, email STRING, created_at INT64);
INSERT INTO contacts VALUES \
(1, 'alice@example.com', 1), \
(2, 'alice@example.com', 2), \
(3, 'bob@example.com', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, score INT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (user_id INT64, bonus INT64);
INSERT INTO users VALUES (1, 100), (2, 200);
INSERT INTO bonuses VALUES (1, 50);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category STRING);
DROP TABLE IF EXISTS discontinued_categories;
CREATE TABLE discontinued_categories (category STRING);
INSERT INTO products VALUES \
(1, 'Widget', 'tools'), \
(2, 'Gadget', 'electronics');
INSERT INTO discontinued_categories VALUES ('tools');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, level STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, points INT64);
INSERT INTO users VALUES (1, 'beginner'), (2, 'beginner');
INSERT INTO scores VALUES (1, 1000), (2, 500);
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT name FROM users;
DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT COUNT(*) FROM users;
DELETE FROM temp \
USING cleanup \
WHERE cleanup.flag = TRUE;
SELECT COUNT(*) FROM temp;
DELETE FROM orders \
USING cancelled_users \
WHERE orders.user_id = cancelled_users.user_id \
AND orders.status = 'pending';
SELECT id FROM orders WHERE user_id = 1 ORDER BY id;
DELETE FROM logs \
USING inactive_users, log_types_to_clean \
WHERE logs.user_id = inactive_users.user_id \
AND logs.type = log_types_to_clean.type;
SELECT id FROM logs ORDER BY id;
DELETE FROM contacts c1 \
USING contacts c2 \
WHERE c1.email = c2.email \
AND c1.created_at < c2.created_at;
SELECT id FROM contacts ORDER BY id;
UPDATE users \
SET score = users.score + bonuses.bonus \
FROM bonuses \
WHERE users.id = bonuses.user_id \
RETURNING users.id, users.score;
DELETE FROM products \
USING discontinued_categories \
WHERE products.category = discontinued_categories.category \
RETURNING products.id, products.name;
WITH high_scorers AS ( \
SELECT user_id FROM scores WHERE points >= 1000 \
) \
UPDATE users \
SET level = 'advanced' \
FROM high_scorers \
WHERE users.id = high_scorers.user_id;
SELECT level FROM users WHERE id = 1;
WITH inactive AS ( \
SELECT user_id FROM activity WHERE last_active > 60 \
) \
DELETE FROM sessions \
USING inactive \
WHERE sessions.user_id = inactive.user_id;
SELECT COUNT(*) FROM sessions;
UPDATE t1 \
SET value = t2.value \
FROM t2 \
WHERE id = t2.id;
DELETE FROM users \
USING filter \
WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \
SET value = n2.value + 1 \
FROM nums n2 \
WHERE n1.id = n2.id;
SELECT value FROM nums WHERE id = 1;
UPDATE items \
SET price = items.price * price_changes.multiplier \
FROM price_changes \
WHERE items.id = price_changes.item_id;
SELECT price FROM items WHERE id = 1;
SELECT price FROM items WHERE id = 100;
DELETE FROM records \
USING to_remove \
WHERE records.id = to_remove.record_id;
SELECT COUNT(*) FROM records;

-- ============================================================================
-- Test: test_delete_using_no_matches
-- Source: join_based_dml_comprehensive_tdd.rs:408
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS to_delete;
CREATE TABLE to_delete (user_id INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO to_delete VALUES (99);
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64);
DROP TABLE IF EXISTS cleanup;
CREATE TABLE cleanup (flag BOOL);
INSERT INTO temp VALUES (1), (2), (3);
INSERT INTO cleanup VALUES (TRUE);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, amount FLOAT64, status STRING);
DROP TABLE IF EXISTS cancelled_users;
CREATE TABLE cancelled_users (user_id INT64);
INSERT INTO orders VALUES \
(1, 1, 100.0, 'pending'), \
(2, 1, 200.0, 'completed'), \
(3, 2, 150.0, 'pending');
INSERT INTO cancelled_users VALUES (1);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, type STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (user_id INT64);
DROP TABLE IF EXISTS log_types_to_clean;
CREATE TABLE log_types_to_clean (type STRING);
INSERT INTO logs VALUES \
(1, 1, 'debug'), \
(2, 1, 'error'), \
(3, 2, 'debug');
INSERT INTO inactive_users VALUES (1);
INSERT INTO log_types_to_clean VALUES ('debug');
DROP TABLE IF EXISTS contacts;
CREATE TABLE contacts (id INT64, email STRING, created_at INT64);
INSERT INTO contacts VALUES \
(1, 'alice@example.com', 1), \
(2, 'alice@example.com', 2), \
(3, 'bob@example.com', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, score INT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (user_id INT64, bonus INT64);
INSERT INTO users VALUES (1, 100), (2, 200);
INSERT INTO bonuses VALUES (1, 50);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category STRING);
DROP TABLE IF EXISTS discontinued_categories;
CREATE TABLE discontinued_categories (category STRING);
INSERT INTO products VALUES \
(1, 'Widget', 'tools'), \
(2, 'Gadget', 'electronics');
INSERT INTO discontinued_categories VALUES ('tools');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, level STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, points INT64);
INSERT INTO users VALUES (1, 'beginner'), (2, 'beginner');
INSERT INTO scores VALUES (1, 1000), (2, 500);
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

DELETE FROM users \
USING to_delete \
WHERE users.id = to_delete.user_id;
SELECT COUNT(*) FROM users;
DELETE FROM temp \
USING cleanup \
WHERE cleanup.flag = TRUE;
SELECT COUNT(*) FROM temp;
DELETE FROM orders \
USING cancelled_users \
WHERE orders.user_id = cancelled_users.user_id \
AND orders.status = 'pending';
SELECT id FROM orders WHERE user_id = 1 ORDER BY id;
DELETE FROM logs \
USING inactive_users, log_types_to_clean \
WHERE logs.user_id = inactive_users.user_id \
AND logs.type = log_types_to_clean.type;
SELECT id FROM logs ORDER BY id;
DELETE FROM contacts c1 \
USING contacts c2 \
WHERE c1.email = c2.email \
AND c1.created_at < c2.created_at;
SELECT id FROM contacts ORDER BY id;
UPDATE users \
SET score = users.score + bonuses.bonus \
FROM bonuses \
WHERE users.id = bonuses.user_id \
RETURNING users.id, users.score;
DELETE FROM products \
USING discontinued_categories \
WHERE products.category = discontinued_categories.category \
RETURNING products.id, products.name;
WITH high_scorers AS ( \
SELECT user_id FROM scores WHERE points >= 1000 \
) \
UPDATE users \
SET level = 'advanced' \
FROM high_scorers \
WHERE users.id = high_scorers.user_id;
SELECT level FROM users WHERE id = 1;
WITH inactive AS ( \
SELECT user_id FROM activity WHERE last_active > 60 \
) \
DELETE FROM sessions \
USING inactive \
WHERE sessions.user_id = inactive.user_id;
SELECT COUNT(*) FROM sessions;
UPDATE t1 \
SET value = t2.value \
FROM t2 \
WHERE id = t2.id;
DELETE FROM users \
USING filter \
WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \
SET value = n2.value + 1 \
FROM nums n2 \
WHERE n1.id = n2.id;
SELECT value FROM nums WHERE id = 1;
UPDATE items \
SET price = items.price * price_changes.multiplier \
FROM price_changes \
WHERE items.id = price_changes.item_id;
SELECT price FROM items WHERE id = 1;
SELECT price FROM items WHERE id = 100;
DELETE FROM records \
USING to_remove \
WHERE records.id = to_remove.record_id;
SELECT COUNT(*) FROM records;

-- ============================================================================
-- Test: test_delete_using_all_rows
-- Source: join_based_dml_comprehensive_tdd.rs:442
-- ============================================================================
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64);
DROP TABLE IF EXISTS cleanup;
CREATE TABLE cleanup (flag BOOL);
INSERT INTO temp VALUES (1), (2), (3);
INSERT INTO cleanup VALUES (TRUE);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, amount FLOAT64, status STRING);
DROP TABLE IF EXISTS cancelled_users;
CREATE TABLE cancelled_users (user_id INT64);
INSERT INTO orders VALUES \
(1, 1, 100.0, 'pending'), \
(2, 1, 200.0, 'completed'), \
(3, 2, 150.0, 'pending');
INSERT INTO cancelled_users VALUES (1);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, type STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (user_id INT64);
DROP TABLE IF EXISTS log_types_to_clean;
CREATE TABLE log_types_to_clean (type STRING);
INSERT INTO logs VALUES \
(1, 1, 'debug'), \
(2, 1, 'error'), \
(3, 2, 'debug');
INSERT INTO inactive_users VALUES (1);
INSERT INTO log_types_to_clean VALUES ('debug');
DROP TABLE IF EXISTS contacts;
CREATE TABLE contacts (id INT64, email STRING, created_at INT64);
INSERT INTO contacts VALUES \
(1, 'alice@example.com', 1), \
(2, 'alice@example.com', 2), \
(3, 'bob@example.com', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, score INT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (user_id INT64, bonus INT64);
INSERT INTO users VALUES (1, 100), (2, 200);
INSERT INTO bonuses VALUES (1, 50);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category STRING);
DROP TABLE IF EXISTS discontinued_categories;
CREATE TABLE discontinued_categories (category STRING);
INSERT INTO products VALUES \
(1, 'Widget', 'tools'), \
(2, 'Gadget', 'electronics');
INSERT INTO discontinued_categories VALUES ('tools');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, level STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, points INT64);
INSERT INTO users VALUES (1, 'beginner'), (2, 'beginner');
INSERT INTO scores VALUES (1, 1000), (2, 500);
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

DELETE FROM temp \
USING cleanup \
WHERE cleanup.flag = TRUE;
SELECT COUNT(*) FROM temp;
DELETE FROM orders \
USING cancelled_users \
WHERE orders.user_id = cancelled_users.user_id \
AND orders.status = 'pending';
SELECT id FROM orders WHERE user_id = 1 ORDER BY id;
DELETE FROM logs \
USING inactive_users, log_types_to_clean \
WHERE logs.user_id = inactive_users.user_id \
AND logs.type = log_types_to_clean.type;
SELECT id FROM logs ORDER BY id;
DELETE FROM contacts c1 \
USING contacts c2 \
WHERE c1.email = c2.email \
AND c1.created_at < c2.created_at;
SELECT id FROM contacts ORDER BY id;
UPDATE users \
SET score = users.score + bonuses.bonus \
FROM bonuses \
WHERE users.id = bonuses.user_id \
RETURNING users.id, users.score;
DELETE FROM products \
USING discontinued_categories \
WHERE products.category = discontinued_categories.category \
RETURNING products.id, products.name;
WITH high_scorers AS ( \
SELECT user_id FROM scores WHERE points >= 1000 \
) \
UPDATE users \
SET level = 'advanced' \
FROM high_scorers \
WHERE users.id = high_scorers.user_id;
SELECT level FROM users WHERE id = 1;
WITH inactive AS ( \
SELECT user_id FROM activity WHERE last_active > 60 \
) \
DELETE FROM sessions \
USING inactive \
WHERE sessions.user_id = inactive.user_id;
SELECT COUNT(*) FROM sessions;
UPDATE t1 \
SET value = t2.value \
FROM t2 \
WHERE id = t2.id;
DELETE FROM users \
USING filter \
WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \
SET value = n2.value + 1 \
FROM nums n2 \
WHERE n1.id = n2.id;
SELECT value FROM nums WHERE id = 1;
UPDATE items \
SET price = items.price * price_changes.multiplier \
FROM price_changes \
WHERE items.id = price_changes.item_id;
SELECT price FROM items WHERE id = 1;
SELECT price FROM items WHERE id = 100;
DELETE FROM records \
USING to_remove \
WHERE records.id = to_remove.record_id;
SELECT COUNT(*) FROM records;

-- ============================================================================
-- Test: test_create_materialized_view_basic
-- Source: materialized_views_comprehensive_tdd.rs:42
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products ( id INT64, name STRING, price FLOAT64, category STRING );
INSERT INTO products VALUES
(1, 'Laptop', 1200.00, 'Electronics'),
(2, 'Mouse', 25.99, 'Electronics'),
(3, 'Desk', 350.00, 'Furniture'),
(4, 'Chair', 200.00, 'Furniture');
DROP MATERIALIZED VIEW IF EXISTS expensive_products;
CREATE MATERIALIZED VIEW expensive_products AS SELECT * FROM products WHERE price > 100;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales ( product_id INT64, quantity INT64, amount FLOAT64, sale_date DATE );
INSERT INTO sales VALUES
(1, 5, 500.00, DATE '2024-01-01'),
(1, 3, 300.00, DATE '2024-01-02'),
(2, 10, 250.00, DATE '2024-01-01'),
(2, 5, 125.00, DATE '2024-01-03'),
(3, 2, 700.00, DATE '2024-01-01');
DROP MATERIALIZED VIEW IF EXISTS product_totals;
CREATE MATERIALIZED VIEW product_totals AS SELECT product_id, SUM(quantity) as total_quantity, SUM(amount) as total_amount, COUNT(*) as sale_count FROM sales GROUP BY product_id;
DROP TABLE IF EXISTS test_table;
CREATE TABLE test_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP MATERIALIZED VIEW IF EXISTS IF;
CREATE MATERIALIZED VIEW IF NOT EXISTS test_mv AS SELECT * FROM test_table;
DROP TABLE IF EXISTS test_table;
CREATE TABLE test_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS counter_sum;
CREATE MATERIALIZED VIEW counter_sum AS SELECT SUM(value) as total FROM counters;
INSERT INTO counters VALUES (3, 15);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, active BOOL);
INSERT INTO items VALUES (1, TRUE), (2, TRUE), (3, FALSE), (4, TRUE);
DROP MATERIALIZED VIEW IF EXISTS active_items;
CREATE MATERIALIZED VIEW active_items AS SELECT COUNT(*) as count FROM items WHERE active = TRUE;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (player_id INT64, score INT64);
INSERT INTO scores VALUES (1, 100), (2, 200), (3, 150);
DROP MATERIALIZED VIEW IF EXISTS top_score;
CREATE MATERIALIZED VIEW top_score AS SELECT MAX(score) as highest FROM scores;
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, processed BOOL);
INSERT INTO events VALUES (1, FALSE), (2, FALSE);
DROP MATERIALIZED VIEW IF EXISTS pending_events;
CREATE MATERIALIZED VIEW pending_events AS SELECT * FROM events WHERE processed = TRUE;
DROP TABLE IF EXISTS test_table;
CREATE TABLE test_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP MATERIALIZED VIEW test_mv;
DROP MATERIALIZED VIEW nonexistent_mv;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64, value INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table WHERE value > 10;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1 WHERE value < 100;
DROP MATERIALIZED VIEW mv1 CASCADE;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1;
DROP MATERIALIZED VIEW mv1 RESTRICT;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (customer_id INT64, name STRING, tier STRING);
INSERT INTO orders VALUES
(1, 101, 500.00),
(2, 102, 750.00),
(3, 101, 300.00);
INSERT INTO customers VALUES
(101, 'Alice', 'Gold'),
(102, 'Bob', 'Silver');
DROP MATERIALIZED VIEW IF EXISTS customer_orders;
CREATE MATERIALIZED VIEW customer_orders AS SELECT c.name, c.tier, SUM(o.amount) as total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name, c.tier;
DROP TABLE IF EXISTS employee_sales;
CREATE TABLE employee_sales ( employee_id INT64, sale_amount FLOAT64, sale_date DATE );
INSERT INTO employee_sales VALUES
(1, 1000.00, DATE '2024-01-01'),
(1, 1500.00, DATE '2024-01-02'),
(2, 2000.00, DATE '2024-01-01'),
(2, 1200.00, DATE '2024-01-02'),
(3, 1800.00, DATE '2024-01-01');
DROP MATERIALIZED VIEW IF EXISTS sales_with_rank;
CREATE MATERIALIZED VIEW sales_with_rank AS SELECT employee_id, SUM(sale_amount) as total_sales, RANK() OVER (ORDER BY SUM(sale_amount) DESC) as sales_rank FROM employee_sales GROUP BY employee_id;
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions ( account_id INT64, amount FLOAT64, tx_type STRING );
INSERT INTO transactions VALUES
(1, 100.00, 'credit'),
(1, 50.00, 'debit'),
(1, 200.00, 'credit'),
(2, 300.00, 'credit'),
(2, 150.00, 'debit');
DROP MATERIALIZED VIEW IF EXISTS account_balances;
CREATE MATERIALIZED VIEW account_balances AS WITH credits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'credit' GROUP BY account_id ), debits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'debit' GROUP BY account_id ) SELECT COALESCE(c.account_id, d.account_id) as account_id, COALESCE(c.total, 0) - COALESCE(d.total, 0) as balance FROM credits c FULL OUTER JOIN debits d ON c.account_id = d.account_id;
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (dept_id INT64, dept_name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (emp_id INT64, dept_id INT64, salary FLOAT64);
INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES
(1, 1, 100000.00),
(2, 1, 120000.00),
(3, 2, 80000.00),
(4, 2, 90000.00);
DROP MATERIALIZED VIEW IF EXISTS dept_avg_salary;
CREATE MATERIALIZED VIEW dept_avg_salary AS SELECT d.dept_name, (SELECT AVG(salary) FROM employees e WHERE e.dept_id = d.dept_id) as avg_salary FROM departments d;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS filtered_data;
CREATE MATERIALIZED VIEW filtered_data AS SELECT * FROM data WHERE value > 1000;
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, value FLOAT64);
DROP MATERIALIZED VIEW IF EXISTS large_mv;
CREATE MATERIALIZED VIEW large_mv AS SELECT * FROM large_table WHERE value > 500.0;
DROP TABLE IF EXISTS nullable_data;
CREATE TABLE nullable_data (id INT64, value INT64);
INSERT INTO nullable_data VALUES (1, 10), (2, NULL), (3, 30), (4, NULL);
DROP MATERIALIZED VIEW IF EXISTS non_null_data;
CREATE MATERIALIZED VIEW non_null_data AS SELECT * FROM nullable_data WHERE value IS NOT NULL;
DROP MATERIALIZED VIEW IF EXISTS invalid_mv;
CREATE MATERIALIZED VIEW invalid_mv AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS shared_name;
CREATE TABLE shared_name (id INT64);
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP VIEW IF EXISTS shared_name;
CREATE VIEW shared_name AS SELECT * FROM base;
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test WHERE id > 10;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP MATERIALIZED VIEW IF EXISTS even_numbers;
CREATE MATERIALIZED VIEW even_numbers AS SELECT * FROM numbers WHERE n % 2 = 0;
DROP MATERIALIZED VIEW IF EXISTS odd_numbers;
CREATE MATERIALIZED VIEW odd_numbers AS SELECT * FROM numbers WHERE n % 2 = 1;
DROP MATERIALIZED VIEW IF EXISTS large_numbers;
CREATE MATERIALIZED VIEW large_numbers AS SELECT * FROM numbers WHERE n > 5;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
INSERT INTO mv VALUES (1);
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WHERE value > 50;
CREATE TABLE copy AS SELECT * FROM mv;

SELECT COUNT(*) FROM expensive_products;
SELECT product_id, total_amount FROM product_totals ORDER BY product_id;
SELECT COUNT(*) FROM test_mv;
SELECT total FROM counter_sum;
SELECT total FROM counter_sum;
REFRESH MATERIALIZED VIEW counter_sum;
SELECT total FROM counter_sum;
SELECT count FROM active_items;
DELETE FROM items WHERE id = 1;
REFRESH MATERIALIZED VIEW active_items;
SELECT count FROM active_items;
SELECT highest FROM top_score;
UPDATE scores SET score = 300 WHERE player_id = 3;
REFRESH MATERIALIZED VIEW top_score;
SELECT highest FROM top_score;
SELECT COUNT(*) FROM pending_events;
UPDATE events SET processed = TRUE;
REFRESH MATERIALIZED VIEW pending_events;
SELECT COUNT(*) FROM pending_events;
SELECT * FROM test_mv;
SELECT * FROM mv2;
SELECT name, total_spent FROM customer_orders ORDER BY name;
SELECT employee_id, sales_rank FROM sales_with_rank ORDER BY sales_rank;
SELECT account_id, balance FROM account_balances ORDER BY account_id;
SELECT dept_name, avg_salary FROM dept_avg_salary ORDER BY dept_name;
SELECT COUNT(*) FROM filtered_data;
SELECT COUNT(*) FROM large_mv;
SELECT COUNT(*) FROM non_null_data;
REFRESH MATERIALIZED VIEW test_mv;
SELECT COUNT(*) FROM even_numbers;
SELECT COUNT(*) FROM odd_numbers;
SELECT COUNT(*) FROM large_numbers;
UPDATE mv SET id = 2 WHERE id = 1;
DELETE FROM mv WHERE id = 1;
SELECT COUNT(*) FROM copy;

-- ============================================================================
-- Test: test_create_materialized_view_with_aggregation
-- Source: materialized_views_comprehensive_tdd.rs:87
-- ============================================================================
DROP TABLE IF EXISTS sales;
CREATE TABLE sales ( product_id INT64, quantity INT64, amount FLOAT64, sale_date DATE );
INSERT INTO sales VALUES
(1, 5, 500.00, DATE '2024-01-01'),
(1, 3, 300.00, DATE '2024-01-02'),
(2, 10, 250.00, DATE '2024-01-01'),
(2, 5, 125.00, DATE '2024-01-03'),
(3, 2, 700.00, DATE '2024-01-01');
DROP MATERIALIZED VIEW IF EXISTS product_totals;
CREATE MATERIALIZED VIEW product_totals AS SELECT product_id, SUM(quantity) as total_quantity, SUM(amount) as total_amount, COUNT(*) as sale_count FROM sales GROUP BY product_id;
DROP TABLE IF EXISTS test_table;
CREATE TABLE test_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP MATERIALIZED VIEW IF EXISTS IF;
CREATE MATERIALIZED VIEW IF NOT EXISTS test_mv AS SELECT * FROM test_table;
DROP TABLE IF EXISTS test_table;
CREATE TABLE test_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS counter_sum;
CREATE MATERIALIZED VIEW counter_sum AS SELECT SUM(value) as total FROM counters;
INSERT INTO counters VALUES (3, 15);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, active BOOL);
INSERT INTO items VALUES (1, TRUE), (2, TRUE), (3, FALSE), (4, TRUE);
DROP MATERIALIZED VIEW IF EXISTS active_items;
CREATE MATERIALIZED VIEW active_items AS SELECT COUNT(*) as count FROM items WHERE active = TRUE;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (player_id INT64, score INT64);
INSERT INTO scores VALUES (1, 100), (2, 200), (3, 150);
DROP MATERIALIZED VIEW IF EXISTS top_score;
CREATE MATERIALIZED VIEW top_score AS SELECT MAX(score) as highest FROM scores;
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, processed BOOL);
INSERT INTO events VALUES (1, FALSE), (2, FALSE);
DROP MATERIALIZED VIEW IF EXISTS pending_events;
CREATE MATERIALIZED VIEW pending_events AS SELECT * FROM events WHERE processed = TRUE;
DROP TABLE IF EXISTS test_table;
CREATE TABLE test_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP MATERIALIZED VIEW test_mv;
DROP MATERIALIZED VIEW nonexistent_mv;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64, value INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table WHERE value > 10;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1 WHERE value < 100;
DROP MATERIALIZED VIEW mv1 CASCADE;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1;
DROP MATERIALIZED VIEW mv1 RESTRICT;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (customer_id INT64, name STRING, tier STRING);
INSERT INTO orders VALUES
(1, 101, 500.00),
(2, 102, 750.00),
(3, 101, 300.00);
INSERT INTO customers VALUES
(101, 'Alice', 'Gold'),
(102, 'Bob', 'Silver');
DROP MATERIALIZED VIEW IF EXISTS customer_orders;
CREATE MATERIALIZED VIEW customer_orders AS SELECT c.name, c.tier, SUM(o.amount) as total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name, c.tier;
DROP TABLE IF EXISTS employee_sales;
CREATE TABLE employee_sales ( employee_id INT64, sale_amount FLOAT64, sale_date DATE );
INSERT INTO employee_sales VALUES
(1, 1000.00, DATE '2024-01-01'),
(1, 1500.00, DATE '2024-01-02'),
(2, 2000.00, DATE '2024-01-01'),
(2, 1200.00, DATE '2024-01-02'),
(3, 1800.00, DATE '2024-01-01');
DROP MATERIALIZED VIEW IF EXISTS sales_with_rank;
CREATE MATERIALIZED VIEW sales_with_rank AS SELECT employee_id, SUM(sale_amount) as total_sales, RANK() OVER (ORDER BY SUM(sale_amount) DESC) as sales_rank FROM employee_sales GROUP BY employee_id;
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions ( account_id INT64, amount FLOAT64, tx_type STRING );
INSERT INTO transactions VALUES
(1, 100.00, 'credit'),
(1, 50.00, 'debit'),
(1, 200.00, 'credit'),
(2, 300.00, 'credit'),
(2, 150.00, 'debit');
DROP MATERIALIZED VIEW IF EXISTS account_balances;
CREATE MATERIALIZED VIEW account_balances AS WITH credits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'credit' GROUP BY account_id ), debits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'debit' GROUP BY account_id ) SELECT COALESCE(c.account_id, d.account_id) as account_id, COALESCE(c.total, 0) - COALESCE(d.total, 0) as balance FROM credits c FULL OUTER JOIN debits d ON c.account_id = d.account_id;
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (dept_id INT64, dept_name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (emp_id INT64, dept_id INT64, salary FLOAT64);
INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES
(1, 1, 100000.00),
(2, 1, 120000.00),
(3, 2, 80000.00),
(4, 2, 90000.00);
DROP MATERIALIZED VIEW IF EXISTS dept_avg_salary;
CREATE MATERIALIZED VIEW dept_avg_salary AS SELECT d.dept_name, (SELECT AVG(salary) FROM employees e WHERE e.dept_id = d.dept_id) as avg_salary FROM departments d;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS filtered_data;
CREATE MATERIALIZED VIEW filtered_data AS SELECT * FROM data WHERE value > 1000;
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, value FLOAT64);
DROP MATERIALIZED VIEW IF EXISTS large_mv;
CREATE MATERIALIZED VIEW large_mv AS SELECT * FROM large_table WHERE value > 500.0;
DROP TABLE IF EXISTS nullable_data;
CREATE TABLE nullable_data (id INT64, value INT64);
INSERT INTO nullable_data VALUES (1, 10), (2, NULL), (3, 30), (4, NULL);
DROP MATERIALIZED VIEW IF EXISTS non_null_data;
CREATE MATERIALIZED VIEW non_null_data AS SELECT * FROM nullable_data WHERE value IS NOT NULL;
DROP MATERIALIZED VIEW IF EXISTS invalid_mv;
CREATE MATERIALIZED VIEW invalid_mv AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS shared_name;
CREATE TABLE shared_name (id INT64);
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP VIEW IF EXISTS shared_name;
CREATE VIEW shared_name AS SELECT * FROM base;
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test WHERE id > 10;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP MATERIALIZED VIEW IF EXISTS even_numbers;
CREATE MATERIALIZED VIEW even_numbers AS SELECT * FROM numbers WHERE n % 2 = 0;
DROP MATERIALIZED VIEW IF EXISTS odd_numbers;
CREATE MATERIALIZED VIEW odd_numbers AS SELECT * FROM numbers WHERE n % 2 = 1;
DROP MATERIALIZED VIEW IF EXISTS large_numbers;
CREATE MATERIALIZED VIEW large_numbers AS SELECT * FROM numbers WHERE n > 5;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
INSERT INTO mv VALUES (1);
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WHERE value > 50;
CREATE TABLE copy AS SELECT * FROM mv;

SELECT product_id, total_amount FROM product_totals ORDER BY product_id;
SELECT COUNT(*) FROM test_mv;
SELECT total FROM counter_sum;
SELECT total FROM counter_sum;
REFRESH MATERIALIZED VIEW counter_sum;
SELECT total FROM counter_sum;
SELECT count FROM active_items;
DELETE FROM items WHERE id = 1;
REFRESH MATERIALIZED VIEW active_items;
SELECT count FROM active_items;
SELECT highest FROM top_score;
UPDATE scores SET score = 300 WHERE player_id = 3;
REFRESH MATERIALIZED VIEW top_score;
SELECT highest FROM top_score;
SELECT COUNT(*) FROM pending_events;
UPDATE events SET processed = TRUE;
REFRESH MATERIALIZED VIEW pending_events;
SELECT COUNT(*) FROM pending_events;
SELECT * FROM test_mv;
SELECT * FROM mv2;
SELECT name, total_spent FROM customer_orders ORDER BY name;
SELECT employee_id, sales_rank FROM sales_with_rank ORDER BY sales_rank;
SELECT account_id, balance FROM account_balances ORDER BY account_id;
SELECT dept_name, avg_salary FROM dept_avg_salary ORDER BY dept_name;
SELECT COUNT(*) FROM filtered_data;
SELECT COUNT(*) FROM large_mv;
SELECT COUNT(*) FROM non_null_data;
REFRESH MATERIALIZED VIEW test_mv;
SELECT COUNT(*) FROM even_numbers;
SELECT COUNT(*) FROM odd_numbers;
SELECT COUNT(*) FROM large_numbers;
UPDATE mv SET id = 2 WHERE id = 1;
DELETE FROM mv WHERE id = 1;
SELECT COUNT(*) FROM copy;

-- ============================================================================
-- Test: test_create_materialized_view_if_not_exists
-- Source: materialized_views_comprehensive_tdd.rs:138
-- ============================================================================
DROP TABLE IF EXISTS test_table;
CREATE TABLE test_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP MATERIALIZED VIEW IF EXISTS IF;
CREATE MATERIALIZED VIEW IF NOT EXISTS test_mv AS SELECT * FROM test_table;
DROP TABLE IF EXISTS test_table;
CREATE TABLE test_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS counter_sum;
CREATE MATERIALIZED VIEW counter_sum AS SELECT SUM(value) as total FROM counters;
INSERT INTO counters VALUES (3, 15);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, active BOOL);
INSERT INTO items VALUES (1, TRUE), (2, TRUE), (3, FALSE), (4, TRUE);
DROP MATERIALIZED VIEW IF EXISTS active_items;
CREATE MATERIALIZED VIEW active_items AS SELECT COUNT(*) as count FROM items WHERE active = TRUE;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (player_id INT64, score INT64);
INSERT INTO scores VALUES (1, 100), (2, 200), (3, 150);
DROP MATERIALIZED VIEW IF EXISTS top_score;
CREATE MATERIALIZED VIEW top_score AS SELECT MAX(score) as highest FROM scores;
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, processed BOOL);
INSERT INTO events VALUES (1, FALSE), (2, FALSE);
DROP MATERIALIZED VIEW IF EXISTS pending_events;
CREATE MATERIALIZED VIEW pending_events AS SELECT * FROM events WHERE processed = TRUE;
DROP TABLE IF EXISTS test_table;
CREATE TABLE test_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP MATERIALIZED VIEW test_mv;
DROP MATERIALIZED VIEW nonexistent_mv;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64, value INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table WHERE value > 10;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1 WHERE value < 100;
DROP MATERIALIZED VIEW mv1 CASCADE;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1;
DROP MATERIALIZED VIEW mv1 RESTRICT;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (customer_id INT64, name STRING, tier STRING);
INSERT INTO orders VALUES
(1, 101, 500.00),
(2, 102, 750.00),
(3, 101, 300.00);
INSERT INTO customers VALUES
(101, 'Alice', 'Gold'),
(102, 'Bob', 'Silver');
DROP MATERIALIZED VIEW IF EXISTS customer_orders;
CREATE MATERIALIZED VIEW customer_orders AS SELECT c.name, c.tier, SUM(o.amount) as total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name, c.tier;
DROP TABLE IF EXISTS employee_sales;
CREATE TABLE employee_sales ( employee_id INT64, sale_amount FLOAT64, sale_date DATE );
INSERT INTO employee_sales VALUES
(1, 1000.00, DATE '2024-01-01'),
(1, 1500.00, DATE '2024-01-02'),
(2, 2000.00, DATE '2024-01-01'),
(2, 1200.00, DATE '2024-01-02'),
(3, 1800.00, DATE '2024-01-01');
DROP MATERIALIZED VIEW IF EXISTS sales_with_rank;
CREATE MATERIALIZED VIEW sales_with_rank AS SELECT employee_id, SUM(sale_amount) as total_sales, RANK() OVER (ORDER BY SUM(sale_amount) DESC) as sales_rank FROM employee_sales GROUP BY employee_id;
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions ( account_id INT64, amount FLOAT64, tx_type STRING );
INSERT INTO transactions VALUES
(1, 100.00, 'credit'),
(1, 50.00, 'debit'),
(1, 200.00, 'credit'),
(2, 300.00, 'credit'),
(2, 150.00, 'debit');
DROP MATERIALIZED VIEW IF EXISTS account_balances;
CREATE MATERIALIZED VIEW account_balances AS WITH credits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'credit' GROUP BY account_id ), debits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'debit' GROUP BY account_id ) SELECT COALESCE(c.account_id, d.account_id) as account_id, COALESCE(c.total, 0) - COALESCE(d.total, 0) as balance FROM credits c FULL OUTER JOIN debits d ON c.account_id = d.account_id;
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (dept_id INT64, dept_name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (emp_id INT64, dept_id INT64, salary FLOAT64);
INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES
(1, 1, 100000.00),
(2, 1, 120000.00),
(3, 2, 80000.00),
(4, 2, 90000.00);
DROP MATERIALIZED VIEW IF EXISTS dept_avg_salary;
CREATE MATERIALIZED VIEW dept_avg_salary AS SELECT d.dept_name, (SELECT AVG(salary) FROM employees e WHERE e.dept_id = d.dept_id) as avg_salary FROM departments d;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS filtered_data;
CREATE MATERIALIZED VIEW filtered_data AS SELECT * FROM data WHERE value > 1000;
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, value FLOAT64);
DROP MATERIALIZED VIEW IF EXISTS large_mv;
CREATE MATERIALIZED VIEW large_mv AS SELECT * FROM large_table WHERE value > 500.0;
DROP TABLE IF EXISTS nullable_data;
CREATE TABLE nullable_data (id INT64, value INT64);
INSERT INTO nullable_data VALUES (1, 10), (2, NULL), (3, 30), (4, NULL);
DROP MATERIALIZED VIEW IF EXISTS non_null_data;
CREATE MATERIALIZED VIEW non_null_data AS SELECT * FROM nullable_data WHERE value IS NOT NULL;
DROP MATERIALIZED VIEW IF EXISTS invalid_mv;
CREATE MATERIALIZED VIEW invalid_mv AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS shared_name;
CREATE TABLE shared_name (id INT64);
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP VIEW IF EXISTS shared_name;
CREATE VIEW shared_name AS SELECT * FROM base;
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test WHERE id > 10;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP MATERIALIZED VIEW IF EXISTS even_numbers;
CREATE MATERIALIZED VIEW even_numbers AS SELECT * FROM numbers WHERE n % 2 = 0;
DROP MATERIALIZED VIEW IF EXISTS odd_numbers;
CREATE MATERIALIZED VIEW odd_numbers AS SELECT * FROM numbers WHERE n % 2 = 1;
DROP MATERIALIZED VIEW IF EXISTS large_numbers;
CREATE MATERIALIZED VIEW large_numbers AS SELECT * FROM numbers WHERE n > 5;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
INSERT INTO mv VALUES (1);
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WHERE value > 50;
CREATE TABLE copy AS SELECT * FROM mv;

SELECT COUNT(*) FROM test_mv;
SELECT total FROM counter_sum;
SELECT total FROM counter_sum;
REFRESH MATERIALIZED VIEW counter_sum;
SELECT total FROM counter_sum;
SELECT count FROM active_items;
DELETE FROM items WHERE id = 1;
REFRESH MATERIALIZED VIEW active_items;
SELECT count FROM active_items;
SELECT highest FROM top_score;
UPDATE scores SET score = 300 WHERE player_id = 3;
REFRESH MATERIALIZED VIEW top_score;
SELECT highest FROM top_score;
SELECT COUNT(*) FROM pending_events;
UPDATE events SET processed = TRUE;
REFRESH MATERIALIZED VIEW pending_events;
SELECT COUNT(*) FROM pending_events;
SELECT * FROM test_mv;
SELECT * FROM mv2;
SELECT name, total_spent FROM customer_orders ORDER BY name;
SELECT employee_id, sales_rank FROM sales_with_rank ORDER BY sales_rank;
SELECT account_id, balance FROM account_balances ORDER BY account_id;
SELECT dept_name, avg_salary FROM dept_avg_salary ORDER BY dept_name;
SELECT COUNT(*) FROM filtered_data;
SELECT COUNT(*) FROM large_mv;
SELECT COUNT(*) FROM non_null_data;
REFRESH MATERIALIZED VIEW test_mv;
SELECT COUNT(*) FROM even_numbers;
SELECT COUNT(*) FROM odd_numbers;
SELECT COUNT(*) FROM large_numbers;
UPDATE mv SET id = 2 WHERE id = 1;
DELETE FROM mv WHERE id = 1;
SELECT COUNT(*) FROM copy;

-- ============================================================================
-- Test: test_create_materialized_view_duplicate_error
-- Source: materialized_views_comprehensive_tdd.rs:164
-- ============================================================================
DROP TABLE IF EXISTS test_table;
CREATE TABLE test_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS counter_sum;
CREATE MATERIALIZED VIEW counter_sum AS SELECT SUM(value) as total FROM counters;
INSERT INTO counters VALUES (3, 15);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, active BOOL);
INSERT INTO items VALUES (1, TRUE), (2, TRUE), (3, FALSE), (4, TRUE);
DROP MATERIALIZED VIEW IF EXISTS active_items;
CREATE MATERIALIZED VIEW active_items AS SELECT COUNT(*) as count FROM items WHERE active = TRUE;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (player_id INT64, score INT64);
INSERT INTO scores VALUES (1, 100), (2, 200), (3, 150);
DROP MATERIALIZED VIEW IF EXISTS top_score;
CREATE MATERIALIZED VIEW top_score AS SELECT MAX(score) as highest FROM scores;
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, processed BOOL);
INSERT INTO events VALUES (1, FALSE), (2, FALSE);
DROP MATERIALIZED VIEW IF EXISTS pending_events;
CREATE MATERIALIZED VIEW pending_events AS SELECT * FROM events WHERE processed = TRUE;
DROP TABLE IF EXISTS test_table;
CREATE TABLE test_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP MATERIALIZED VIEW test_mv;
DROP MATERIALIZED VIEW nonexistent_mv;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64, value INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table WHERE value > 10;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1 WHERE value < 100;
DROP MATERIALIZED VIEW mv1 CASCADE;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1;
DROP MATERIALIZED VIEW mv1 RESTRICT;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (customer_id INT64, name STRING, tier STRING);
INSERT INTO orders VALUES
(1, 101, 500.00),
(2, 102, 750.00),
(3, 101, 300.00);
INSERT INTO customers VALUES
(101, 'Alice', 'Gold'),
(102, 'Bob', 'Silver');
DROP MATERIALIZED VIEW IF EXISTS customer_orders;
CREATE MATERIALIZED VIEW customer_orders AS SELECT c.name, c.tier, SUM(o.amount) as total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name, c.tier;
DROP TABLE IF EXISTS employee_sales;
CREATE TABLE employee_sales ( employee_id INT64, sale_amount FLOAT64, sale_date DATE );
INSERT INTO employee_sales VALUES
(1, 1000.00, DATE '2024-01-01'),
(1, 1500.00, DATE '2024-01-02'),
(2, 2000.00, DATE '2024-01-01'),
(2, 1200.00, DATE '2024-01-02'),
(3, 1800.00, DATE '2024-01-01');
DROP MATERIALIZED VIEW IF EXISTS sales_with_rank;
CREATE MATERIALIZED VIEW sales_with_rank AS SELECT employee_id, SUM(sale_amount) as total_sales, RANK() OVER (ORDER BY SUM(sale_amount) DESC) as sales_rank FROM employee_sales GROUP BY employee_id;
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions ( account_id INT64, amount FLOAT64, tx_type STRING );
INSERT INTO transactions VALUES
(1, 100.00, 'credit'),
(1, 50.00, 'debit'),
(1, 200.00, 'credit'),
(2, 300.00, 'credit'),
(2, 150.00, 'debit');
DROP MATERIALIZED VIEW IF EXISTS account_balances;
CREATE MATERIALIZED VIEW account_balances AS WITH credits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'credit' GROUP BY account_id ), debits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'debit' GROUP BY account_id ) SELECT COALESCE(c.account_id, d.account_id) as account_id, COALESCE(c.total, 0) - COALESCE(d.total, 0) as balance FROM credits c FULL OUTER JOIN debits d ON c.account_id = d.account_id;
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (dept_id INT64, dept_name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (emp_id INT64, dept_id INT64, salary FLOAT64);
INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES
(1, 1, 100000.00),
(2, 1, 120000.00),
(3, 2, 80000.00),
(4, 2, 90000.00);
DROP MATERIALIZED VIEW IF EXISTS dept_avg_salary;
CREATE MATERIALIZED VIEW dept_avg_salary AS SELECT d.dept_name, (SELECT AVG(salary) FROM employees e WHERE e.dept_id = d.dept_id) as avg_salary FROM departments d;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS filtered_data;
CREATE MATERIALIZED VIEW filtered_data AS SELECT * FROM data WHERE value > 1000;
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, value FLOAT64);
DROP MATERIALIZED VIEW IF EXISTS large_mv;
CREATE MATERIALIZED VIEW large_mv AS SELECT * FROM large_table WHERE value > 500.0;
DROP TABLE IF EXISTS nullable_data;
CREATE TABLE nullable_data (id INT64, value INT64);
INSERT INTO nullable_data VALUES (1, 10), (2, NULL), (3, 30), (4, NULL);
DROP MATERIALIZED VIEW IF EXISTS non_null_data;
CREATE MATERIALIZED VIEW non_null_data AS SELECT * FROM nullable_data WHERE value IS NOT NULL;
DROP MATERIALIZED VIEW IF EXISTS invalid_mv;
CREATE MATERIALIZED VIEW invalid_mv AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS shared_name;
CREATE TABLE shared_name (id INT64);
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP VIEW IF EXISTS shared_name;
CREATE VIEW shared_name AS SELECT * FROM base;
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test WHERE id > 10;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP MATERIALIZED VIEW IF EXISTS even_numbers;
CREATE MATERIALIZED VIEW even_numbers AS SELECT * FROM numbers WHERE n % 2 = 0;
DROP MATERIALIZED VIEW IF EXISTS odd_numbers;
CREATE MATERIALIZED VIEW odd_numbers AS SELECT * FROM numbers WHERE n % 2 = 1;
DROP MATERIALIZED VIEW IF EXISTS large_numbers;
CREATE MATERIALIZED VIEW large_numbers AS SELECT * FROM numbers WHERE n > 5;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
INSERT INTO mv VALUES (1);
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WHERE value > 50;
CREATE TABLE copy AS SELECT * FROM mv;

SELECT total FROM counter_sum;
SELECT total FROM counter_sum;
REFRESH MATERIALIZED VIEW counter_sum;
SELECT total FROM counter_sum;
SELECT count FROM active_items;
DELETE FROM items WHERE id = 1;
REFRESH MATERIALIZED VIEW active_items;
SELECT count FROM active_items;
SELECT highest FROM top_score;
UPDATE scores SET score = 300 WHERE player_id = 3;
REFRESH MATERIALIZED VIEW top_score;
SELECT highest FROM top_score;
SELECT COUNT(*) FROM pending_events;
UPDATE events SET processed = TRUE;
REFRESH MATERIALIZED VIEW pending_events;
SELECT COUNT(*) FROM pending_events;
SELECT * FROM test_mv;
SELECT * FROM mv2;
SELECT name, total_spent FROM customer_orders ORDER BY name;
SELECT employee_id, sales_rank FROM sales_with_rank ORDER BY sales_rank;
SELECT account_id, balance FROM account_balances ORDER BY account_id;
SELECT dept_name, avg_salary FROM dept_avg_salary ORDER BY dept_name;
SELECT COUNT(*) FROM filtered_data;
SELECT COUNT(*) FROM large_mv;
SELECT COUNT(*) FROM non_null_data;
REFRESH MATERIALIZED VIEW test_mv;
SELECT COUNT(*) FROM even_numbers;
SELECT COUNT(*) FROM odd_numbers;
SELECT COUNT(*) FROM large_numbers;
UPDATE mv SET id = 2 WHERE id = 1;
DELETE FROM mv WHERE id = 1;
SELECT COUNT(*) FROM copy;

-- ============================================================================
-- Test: test_refresh_materialized_view
-- Source: materialized_views_comprehensive_tdd.rs:188
-- ============================================================================
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS counter_sum;
CREATE MATERIALIZED VIEW counter_sum AS SELECT SUM(value) as total FROM counters;
INSERT INTO counters VALUES (3, 15);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, active BOOL);
INSERT INTO items VALUES (1, TRUE), (2, TRUE), (3, FALSE), (4, TRUE);
DROP MATERIALIZED VIEW IF EXISTS active_items;
CREATE MATERIALIZED VIEW active_items AS SELECT COUNT(*) as count FROM items WHERE active = TRUE;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (player_id INT64, score INT64);
INSERT INTO scores VALUES (1, 100), (2, 200), (3, 150);
DROP MATERIALIZED VIEW IF EXISTS top_score;
CREATE MATERIALIZED VIEW top_score AS SELECT MAX(score) as highest FROM scores;
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, processed BOOL);
INSERT INTO events VALUES (1, FALSE), (2, FALSE);
DROP MATERIALIZED VIEW IF EXISTS pending_events;
CREATE MATERIALIZED VIEW pending_events AS SELECT * FROM events WHERE processed = TRUE;
DROP TABLE IF EXISTS test_table;
CREATE TABLE test_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP MATERIALIZED VIEW test_mv;
DROP MATERIALIZED VIEW nonexistent_mv;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64, value INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table WHERE value > 10;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1 WHERE value < 100;
DROP MATERIALIZED VIEW mv1 CASCADE;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1;
DROP MATERIALIZED VIEW mv1 RESTRICT;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (customer_id INT64, name STRING, tier STRING);
INSERT INTO orders VALUES
(1, 101, 500.00),
(2, 102, 750.00),
(3, 101, 300.00);
INSERT INTO customers VALUES
(101, 'Alice', 'Gold'),
(102, 'Bob', 'Silver');
DROP MATERIALIZED VIEW IF EXISTS customer_orders;
CREATE MATERIALIZED VIEW customer_orders AS SELECT c.name, c.tier, SUM(o.amount) as total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name, c.tier;
DROP TABLE IF EXISTS employee_sales;
CREATE TABLE employee_sales ( employee_id INT64, sale_amount FLOAT64, sale_date DATE );
INSERT INTO employee_sales VALUES
(1, 1000.00, DATE '2024-01-01'),
(1, 1500.00, DATE '2024-01-02'),
(2, 2000.00, DATE '2024-01-01'),
(2, 1200.00, DATE '2024-01-02'),
(3, 1800.00, DATE '2024-01-01');
DROP MATERIALIZED VIEW IF EXISTS sales_with_rank;
CREATE MATERIALIZED VIEW sales_with_rank AS SELECT employee_id, SUM(sale_amount) as total_sales, RANK() OVER (ORDER BY SUM(sale_amount) DESC) as sales_rank FROM employee_sales GROUP BY employee_id;
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions ( account_id INT64, amount FLOAT64, tx_type STRING );
INSERT INTO transactions VALUES
(1, 100.00, 'credit'),
(1, 50.00, 'debit'),
(1, 200.00, 'credit'),
(2, 300.00, 'credit'),
(2, 150.00, 'debit');
DROP MATERIALIZED VIEW IF EXISTS account_balances;
CREATE MATERIALIZED VIEW account_balances AS WITH credits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'credit' GROUP BY account_id ), debits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'debit' GROUP BY account_id ) SELECT COALESCE(c.account_id, d.account_id) as account_id, COALESCE(c.total, 0) - COALESCE(d.total, 0) as balance FROM credits c FULL OUTER JOIN debits d ON c.account_id = d.account_id;
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (dept_id INT64, dept_name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (emp_id INT64, dept_id INT64, salary FLOAT64);
INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES
(1, 1, 100000.00),
(2, 1, 120000.00),
(3, 2, 80000.00),
(4, 2, 90000.00);
DROP MATERIALIZED VIEW IF EXISTS dept_avg_salary;
CREATE MATERIALIZED VIEW dept_avg_salary AS SELECT d.dept_name, (SELECT AVG(salary) FROM employees e WHERE e.dept_id = d.dept_id) as avg_salary FROM departments d;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS filtered_data;
CREATE MATERIALIZED VIEW filtered_data AS SELECT * FROM data WHERE value > 1000;
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, value FLOAT64);
DROP MATERIALIZED VIEW IF EXISTS large_mv;
CREATE MATERIALIZED VIEW large_mv AS SELECT * FROM large_table WHERE value > 500.0;
DROP TABLE IF EXISTS nullable_data;
CREATE TABLE nullable_data (id INT64, value INT64);
INSERT INTO nullable_data VALUES (1, 10), (2, NULL), (3, 30), (4, NULL);
DROP MATERIALIZED VIEW IF EXISTS non_null_data;
CREATE MATERIALIZED VIEW non_null_data AS SELECT * FROM nullable_data WHERE value IS NOT NULL;
DROP MATERIALIZED VIEW IF EXISTS invalid_mv;
CREATE MATERIALIZED VIEW invalid_mv AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS shared_name;
CREATE TABLE shared_name (id INT64);
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP VIEW IF EXISTS shared_name;
CREATE VIEW shared_name AS SELECT * FROM base;
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test WHERE id > 10;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP MATERIALIZED VIEW IF EXISTS even_numbers;
CREATE MATERIALIZED VIEW even_numbers AS SELECT * FROM numbers WHERE n % 2 = 0;
DROP MATERIALIZED VIEW IF EXISTS odd_numbers;
CREATE MATERIALIZED VIEW odd_numbers AS SELECT * FROM numbers WHERE n % 2 = 1;
DROP MATERIALIZED VIEW IF EXISTS large_numbers;
CREATE MATERIALIZED VIEW large_numbers AS SELECT * FROM numbers WHERE n > 5;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
INSERT INTO mv VALUES (1);
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WHERE value > 50;
CREATE TABLE copy AS SELECT * FROM mv;

SELECT total FROM counter_sum;
SELECT total FROM counter_sum;
REFRESH MATERIALIZED VIEW counter_sum;
SELECT total FROM counter_sum;
SELECT count FROM active_items;
DELETE FROM items WHERE id = 1;
REFRESH MATERIALIZED VIEW active_items;
SELECT count FROM active_items;
SELECT highest FROM top_score;
UPDATE scores SET score = 300 WHERE player_id = 3;
REFRESH MATERIALIZED VIEW top_score;
SELECT highest FROM top_score;
SELECT COUNT(*) FROM pending_events;
UPDATE events SET processed = TRUE;
REFRESH MATERIALIZED VIEW pending_events;
SELECT COUNT(*) FROM pending_events;
SELECT * FROM test_mv;
SELECT * FROM mv2;
SELECT name, total_spent FROM customer_orders ORDER BY name;
SELECT employee_id, sales_rank FROM sales_with_rank ORDER BY sales_rank;
SELECT account_id, balance FROM account_balances ORDER BY account_id;
SELECT dept_name, avg_salary FROM dept_avg_salary ORDER BY dept_name;
SELECT COUNT(*) FROM filtered_data;
SELECT COUNT(*) FROM large_mv;
SELECT COUNT(*) FROM non_null_data;
REFRESH MATERIALIZED VIEW test_mv;
SELECT COUNT(*) FROM even_numbers;
SELECT COUNT(*) FROM odd_numbers;
SELECT COUNT(*) FROM large_numbers;
UPDATE mv SET id = 2 WHERE id = 1;
DELETE FROM mv WHERE id = 1;
SELECT COUNT(*) FROM copy;

-- ============================================================================
-- Test: test_refresh_materialized_view_with_deletes
-- Source: materialized_views_comprehensive_tdd.rs:246
-- ============================================================================
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, active BOOL);
INSERT INTO items VALUES (1, TRUE), (2, TRUE), (3, FALSE), (4, TRUE);
DROP MATERIALIZED VIEW IF EXISTS active_items;
CREATE MATERIALIZED VIEW active_items AS SELECT COUNT(*) as count FROM items WHERE active = TRUE;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (player_id INT64, score INT64);
INSERT INTO scores VALUES (1, 100), (2, 200), (3, 150);
DROP MATERIALIZED VIEW IF EXISTS top_score;
CREATE MATERIALIZED VIEW top_score AS SELECT MAX(score) as highest FROM scores;
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, processed BOOL);
INSERT INTO events VALUES (1, FALSE), (2, FALSE);
DROP MATERIALIZED VIEW IF EXISTS pending_events;
CREATE MATERIALIZED VIEW pending_events AS SELECT * FROM events WHERE processed = TRUE;
DROP TABLE IF EXISTS test_table;
CREATE TABLE test_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP MATERIALIZED VIEW test_mv;
DROP MATERIALIZED VIEW nonexistent_mv;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64, value INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table WHERE value > 10;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1 WHERE value < 100;
DROP MATERIALIZED VIEW mv1 CASCADE;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1;
DROP MATERIALIZED VIEW mv1 RESTRICT;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (customer_id INT64, name STRING, tier STRING);
INSERT INTO orders VALUES
(1, 101, 500.00),
(2, 102, 750.00),
(3, 101, 300.00);
INSERT INTO customers VALUES
(101, 'Alice', 'Gold'),
(102, 'Bob', 'Silver');
DROP MATERIALIZED VIEW IF EXISTS customer_orders;
CREATE MATERIALIZED VIEW customer_orders AS SELECT c.name, c.tier, SUM(o.amount) as total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name, c.tier;
DROP TABLE IF EXISTS employee_sales;
CREATE TABLE employee_sales ( employee_id INT64, sale_amount FLOAT64, sale_date DATE );
INSERT INTO employee_sales VALUES
(1, 1000.00, DATE '2024-01-01'),
(1, 1500.00, DATE '2024-01-02'),
(2, 2000.00, DATE '2024-01-01'),
(2, 1200.00, DATE '2024-01-02'),
(3, 1800.00, DATE '2024-01-01');
DROP MATERIALIZED VIEW IF EXISTS sales_with_rank;
CREATE MATERIALIZED VIEW sales_with_rank AS SELECT employee_id, SUM(sale_amount) as total_sales, RANK() OVER (ORDER BY SUM(sale_amount) DESC) as sales_rank FROM employee_sales GROUP BY employee_id;
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions ( account_id INT64, amount FLOAT64, tx_type STRING );
INSERT INTO transactions VALUES
(1, 100.00, 'credit'),
(1, 50.00, 'debit'),
(1, 200.00, 'credit'),
(2, 300.00, 'credit'),
(2, 150.00, 'debit');
DROP MATERIALIZED VIEW IF EXISTS account_balances;
CREATE MATERIALIZED VIEW account_balances AS WITH credits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'credit' GROUP BY account_id ), debits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'debit' GROUP BY account_id ) SELECT COALESCE(c.account_id, d.account_id) as account_id, COALESCE(c.total, 0) - COALESCE(d.total, 0) as balance FROM credits c FULL OUTER JOIN debits d ON c.account_id = d.account_id;
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (dept_id INT64, dept_name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (emp_id INT64, dept_id INT64, salary FLOAT64);
INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES
(1, 1, 100000.00),
(2, 1, 120000.00),
(3, 2, 80000.00),
(4, 2, 90000.00);
DROP MATERIALIZED VIEW IF EXISTS dept_avg_salary;
CREATE MATERIALIZED VIEW dept_avg_salary AS SELECT d.dept_name, (SELECT AVG(salary) FROM employees e WHERE e.dept_id = d.dept_id) as avg_salary FROM departments d;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS filtered_data;
CREATE MATERIALIZED VIEW filtered_data AS SELECT * FROM data WHERE value > 1000;
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, value FLOAT64);
DROP MATERIALIZED VIEW IF EXISTS large_mv;
CREATE MATERIALIZED VIEW large_mv AS SELECT * FROM large_table WHERE value > 500.0;
DROP TABLE IF EXISTS nullable_data;
CREATE TABLE nullable_data (id INT64, value INT64);
INSERT INTO nullable_data VALUES (1, 10), (2, NULL), (3, 30), (4, NULL);
DROP MATERIALIZED VIEW IF EXISTS non_null_data;
CREATE MATERIALIZED VIEW non_null_data AS SELECT * FROM nullable_data WHERE value IS NOT NULL;
DROP MATERIALIZED VIEW IF EXISTS invalid_mv;
CREATE MATERIALIZED VIEW invalid_mv AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS shared_name;
CREATE TABLE shared_name (id INT64);
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP VIEW IF EXISTS shared_name;
CREATE VIEW shared_name AS SELECT * FROM base;
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test WHERE id > 10;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP MATERIALIZED VIEW IF EXISTS even_numbers;
CREATE MATERIALIZED VIEW even_numbers AS SELECT * FROM numbers WHERE n % 2 = 0;
DROP MATERIALIZED VIEW IF EXISTS odd_numbers;
CREATE MATERIALIZED VIEW odd_numbers AS SELECT * FROM numbers WHERE n % 2 = 1;
DROP MATERIALIZED VIEW IF EXISTS large_numbers;
CREATE MATERIALIZED VIEW large_numbers AS SELECT * FROM numbers WHERE n > 5;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
INSERT INTO mv VALUES (1);
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WHERE value > 50;
CREATE TABLE copy AS SELECT * FROM mv;

SELECT count FROM active_items;
DELETE FROM items WHERE id = 1;
REFRESH MATERIALIZED VIEW active_items;
SELECT count FROM active_items;
SELECT highest FROM top_score;
UPDATE scores SET score = 300 WHERE player_id = 3;
REFRESH MATERIALIZED VIEW top_score;
SELECT highest FROM top_score;
SELECT COUNT(*) FROM pending_events;
UPDATE events SET processed = TRUE;
REFRESH MATERIALIZED VIEW pending_events;
SELECT COUNT(*) FROM pending_events;
SELECT * FROM test_mv;
SELECT * FROM mv2;
SELECT name, total_spent FROM customer_orders ORDER BY name;
SELECT employee_id, sales_rank FROM sales_with_rank ORDER BY sales_rank;
SELECT account_id, balance FROM account_balances ORDER BY account_id;
SELECT dept_name, avg_salary FROM dept_avg_salary ORDER BY dept_name;
SELECT COUNT(*) FROM filtered_data;
SELECT COUNT(*) FROM large_mv;
SELECT COUNT(*) FROM non_null_data;
REFRESH MATERIALIZED VIEW test_mv;
SELECT COUNT(*) FROM even_numbers;
SELECT COUNT(*) FROM odd_numbers;
SELECT COUNT(*) FROM large_numbers;
UPDATE mv SET id = 2 WHERE id = 1;
DELETE FROM mv WHERE id = 1;
SELECT COUNT(*) FROM copy;

-- ============================================================================
-- Test: test_refresh_materialized_view_with_updates
-- Source: materialized_views_comprehensive_tdd.rs:293
-- ============================================================================
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (player_id INT64, score INT64);
INSERT INTO scores VALUES (1, 100), (2, 200), (3, 150);
DROP MATERIALIZED VIEW IF EXISTS top_score;
CREATE MATERIALIZED VIEW top_score AS SELECT MAX(score) as highest FROM scores;
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, processed BOOL);
INSERT INTO events VALUES (1, FALSE), (2, FALSE);
DROP MATERIALIZED VIEW IF EXISTS pending_events;
CREATE MATERIALIZED VIEW pending_events AS SELECT * FROM events WHERE processed = TRUE;
DROP TABLE IF EXISTS test_table;
CREATE TABLE test_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP MATERIALIZED VIEW test_mv;
DROP MATERIALIZED VIEW nonexistent_mv;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64, value INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table WHERE value > 10;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1 WHERE value < 100;
DROP MATERIALIZED VIEW mv1 CASCADE;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1;
DROP MATERIALIZED VIEW mv1 RESTRICT;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (customer_id INT64, name STRING, tier STRING);
INSERT INTO orders VALUES
(1, 101, 500.00),
(2, 102, 750.00),
(3, 101, 300.00);
INSERT INTO customers VALUES
(101, 'Alice', 'Gold'),
(102, 'Bob', 'Silver');
DROP MATERIALIZED VIEW IF EXISTS customer_orders;
CREATE MATERIALIZED VIEW customer_orders AS SELECT c.name, c.tier, SUM(o.amount) as total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name, c.tier;
DROP TABLE IF EXISTS employee_sales;
CREATE TABLE employee_sales ( employee_id INT64, sale_amount FLOAT64, sale_date DATE );
INSERT INTO employee_sales VALUES
(1, 1000.00, DATE '2024-01-01'),
(1, 1500.00, DATE '2024-01-02'),
(2, 2000.00, DATE '2024-01-01'),
(2, 1200.00, DATE '2024-01-02'),
(3, 1800.00, DATE '2024-01-01');
DROP MATERIALIZED VIEW IF EXISTS sales_with_rank;
CREATE MATERIALIZED VIEW sales_with_rank AS SELECT employee_id, SUM(sale_amount) as total_sales, RANK() OVER (ORDER BY SUM(sale_amount) DESC) as sales_rank FROM employee_sales GROUP BY employee_id;
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions ( account_id INT64, amount FLOAT64, tx_type STRING );
INSERT INTO transactions VALUES
(1, 100.00, 'credit'),
(1, 50.00, 'debit'),
(1, 200.00, 'credit'),
(2, 300.00, 'credit'),
(2, 150.00, 'debit');
DROP MATERIALIZED VIEW IF EXISTS account_balances;
CREATE MATERIALIZED VIEW account_balances AS WITH credits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'credit' GROUP BY account_id ), debits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'debit' GROUP BY account_id ) SELECT COALESCE(c.account_id, d.account_id) as account_id, COALESCE(c.total, 0) - COALESCE(d.total, 0) as balance FROM credits c FULL OUTER JOIN debits d ON c.account_id = d.account_id;
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (dept_id INT64, dept_name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (emp_id INT64, dept_id INT64, salary FLOAT64);
INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES
(1, 1, 100000.00),
(2, 1, 120000.00),
(3, 2, 80000.00),
(4, 2, 90000.00);
DROP MATERIALIZED VIEW IF EXISTS dept_avg_salary;
CREATE MATERIALIZED VIEW dept_avg_salary AS SELECT d.dept_name, (SELECT AVG(salary) FROM employees e WHERE e.dept_id = d.dept_id) as avg_salary FROM departments d;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS filtered_data;
CREATE MATERIALIZED VIEW filtered_data AS SELECT * FROM data WHERE value > 1000;
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, value FLOAT64);
DROP MATERIALIZED VIEW IF EXISTS large_mv;
CREATE MATERIALIZED VIEW large_mv AS SELECT * FROM large_table WHERE value > 500.0;
DROP TABLE IF EXISTS nullable_data;
CREATE TABLE nullable_data (id INT64, value INT64);
INSERT INTO nullable_data VALUES (1, 10), (2, NULL), (3, 30), (4, NULL);
DROP MATERIALIZED VIEW IF EXISTS non_null_data;
CREATE MATERIALIZED VIEW non_null_data AS SELECT * FROM nullable_data WHERE value IS NOT NULL;
DROP MATERIALIZED VIEW IF EXISTS invalid_mv;
CREATE MATERIALIZED VIEW invalid_mv AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS shared_name;
CREATE TABLE shared_name (id INT64);
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP VIEW IF EXISTS shared_name;
CREATE VIEW shared_name AS SELECT * FROM base;
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test WHERE id > 10;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP MATERIALIZED VIEW IF EXISTS even_numbers;
CREATE MATERIALIZED VIEW even_numbers AS SELECT * FROM numbers WHERE n % 2 = 0;
DROP MATERIALIZED VIEW IF EXISTS odd_numbers;
CREATE MATERIALIZED VIEW odd_numbers AS SELECT * FROM numbers WHERE n % 2 = 1;
DROP MATERIALIZED VIEW IF EXISTS large_numbers;
CREATE MATERIALIZED VIEW large_numbers AS SELECT * FROM numbers WHERE n > 5;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
INSERT INTO mv VALUES (1);
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WHERE value > 50;
CREATE TABLE copy AS SELECT * FROM mv;

SELECT highest FROM top_score;
UPDATE scores SET score = 300 WHERE player_id = 3;
REFRESH MATERIALIZED VIEW top_score;
SELECT highest FROM top_score;
SELECT COUNT(*) FROM pending_events;
UPDATE events SET processed = TRUE;
REFRESH MATERIALIZED VIEW pending_events;
SELECT COUNT(*) FROM pending_events;
SELECT * FROM test_mv;
SELECT * FROM mv2;
SELECT name, total_spent FROM customer_orders ORDER BY name;
SELECT employee_id, sales_rank FROM sales_with_rank ORDER BY sales_rank;
SELECT account_id, balance FROM account_balances ORDER BY account_id;
SELECT dept_name, avg_salary FROM dept_avg_salary ORDER BY dept_name;
SELECT COUNT(*) FROM filtered_data;
SELECT COUNT(*) FROM large_mv;
SELECT COUNT(*) FROM non_null_data;
REFRESH MATERIALIZED VIEW test_mv;
SELECT COUNT(*) FROM even_numbers;
SELECT COUNT(*) FROM odd_numbers;
SELECT COUNT(*) FROM large_numbers;
UPDATE mv SET id = 2 WHERE id = 1;
DELETE FROM mv WHERE id = 1;
SELECT COUNT(*) FROM copy;

-- ============================================================================
-- Test: test_refresh_materialized_view_empty_result
-- Source: materialized_views_comprehensive_tdd.rs:339
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, processed BOOL);
INSERT INTO events VALUES (1, FALSE), (2, FALSE);
DROP MATERIALIZED VIEW IF EXISTS pending_events;
CREATE MATERIALIZED VIEW pending_events AS SELECT * FROM events WHERE processed = TRUE;
DROP TABLE IF EXISTS test_table;
CREATE TABLE test_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP MATERIALIZED VIEW test_mv;
DROP MATERIALIZED VIEW nonexistent_mv;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64, value INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table WHERE value > 10;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1 WHERE value < 100;
DROP MATERIALIZED VIEW mv1 CASCADE;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1;
DROP MATERIALIZED VIEW mv1 RESTRICT;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (customer_id INT64, name STRING, tier STRING);
INSERT INTO orders VALUES
(1, 101, 500.00),
(2, 102, 750.00),
(3, 101, 300.00);
INSERT INTO customers VALUES
(101, 'Alice', 'Gold'),
(102, 'Bob', 'Silver');
DROP MATERIALIZED VIEW IF EXISTS customer_orders;
CREATE MATERIALIZED VIEW customer_orders AS SELECT c.name, c.tier, SUM(o.amount) as total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name, c.tier;
DROP TABLE IF EXISTS employee_sales;
CREATE TABLE employee_sales ( employee_id INT64, sale_amount FLOAT64, sale_date DATE );
INSERT INTO employee_sales VALUES
(1, 1000.00, DATE '2024-01-01'),
(1, 1500.00, DATE '2024-01-02'),
(2, 2000.00, DATE '2024-01-01'),
(2, 1200.00, DATE '2024-01-02'),
(3, 1800.00, DATE '2024-01-01');
DROP MATERIALIZED VIEW IF EXISTS sales_with_rank;
CREATE MATERIALIZED VIEW sales_with_rank AS SELECT employee_id, SUM(sale_amount) as total_sales, RANK() OVER (ORDER BY SUM(sale_amount) DESC) as sales_rank FROM employee_sales GROUP BY employee_id;
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions ( account_id INT64, amount FLOAT64, tx_type STRING );
INSERT INTO transactions VALUES
(1, 100.00, 'credit'),
(1, 50.00, 'debit'),
(1, 200.00, 'credit'),
(2, 300.00, 'credit'),
(2, 150.00, 'debit');
DROP MATERIALIZED VIEW IF EXISTS account_balances;
CREATE MATERIALIZED VIEW account_balances AS WITH credits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'credit' GROUP BY account_id ), debits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'debit' GROUP BY account_id ) SELECT COALESCE(c.account_id, d.account_id) as account_id, COALESCE(c.total, 0) - COALESCE(d.total, 0) as balance FROM credits c FULL OUTER JOIN debits d ON c.account_id = d.account_id;
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (dept_id INT64, dept_name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (emp_id INT64, dept_id INT64, salary FLOAT64);
INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES
(1, 1, 100000.00),
(2, 1, 120000.00),
(3, 2, 80000.00),
(4, 2, 90000.00);
DROP MATERIALIZED VIEW IF EXISTS dept_avg_salary;
CREATE MATERIALIZED VIEW dept_avg_salary AS SELECT d.dept_name, (SELECT AVG(salary) FROM employees e WHERE e.dept_id = d.dept_id) as avg_salary FROM departments d;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS filtered_data;
CREATE MATERIALIZED VIEW filtered_data AS SELECT * FROM data WHERE value > 1000;
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, value FLOAT64);
DROP MATERIALIZED VIEW IF EXISTS large_mv;
CREATE MATERIALIZED VIEW large_mv AS SELECT * FROM large_table WHERE value > 500.0;
DROP TABLE IF EXISTS nullable_data;
CREATE TABLE nullable_data (id INT64, value INT64);
INSERT INTO nullable_data VALUES (1, 10), (2, NULL), (3, 30), (4, NULL);
DROP MATERIALIZED VIEW IF EXISTS non_null_data;
CREATE MATERIALIZED VIEW non_null_data AS SELECT * FROM nullable_data WHERE value IS NOT NULL;
DROP MATERIALIZED VIEW IF EXISTS invalid_mv;
CREATE MATERIALIZED VIEW invalid_mv AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS shared_name;
CREATE TABLE shared_name (id INT64);
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP VIEW IF EXISTS shared_name;
CREATE VIEW shared_name AS SELECT * FROM base;
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test WHERE id > 10;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP MATERIALIZED VIEW IF EXISTS even_numbers;
CREATE MATERIALIZED VIEW even_numbers AS SELECT * FROM numbers WHERE n % 2 = 0;
DROP MATERIALIZED VIEW IF EXISTS odd_numbers;
CREATE MATERIALIZED VIEW odd_numbers AS SELECT * FROM numbers WHERE n % 2 = 1;
DROP MATERIALIZED VIEW IF EXISTS large_numbers;
CREATE MATERIALIZED VIEW large_numbers AS SELECT * FROM numbers WHERE n > 5;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
INSERT INTO mv VALUES (1);
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WHERE value > 50;
CREATE TABLE copy AS SELECT * FROM mv;

SELECT COUNT(*) FROM pending_events;
UPDATE events SET processed = TRUE;
REFRESH MATERIALIZED VIEW pending_events;
SELECT COUNT(*) FROM pending_events;
SELECT * FROM test_mv;
SELECT * FROM mv2;
SELECT name, total_spent FROM customer_orders ORDER BY name;
SELECT employee_id, sales_rank FROM sales_with_rank ORDER BY sales_rank;
SELECT account_id, balance FROM account_balances ORDER BY account_id;
SELECT dept_name, avg_salary FROM dept_avg_salary ORDER BY dept_name;
SELECT COUNT(*) FROM filtered_data;
SELECT COUNT(*) FROM large_mv;
SELECT COUNT(*) FROM non_null_data;
REFRESH MATERIALIZED VIEW test_mv;
SELECT COUNT(*) FROM even_numbers;
SELECT COUNT(*) FROM odd_numbers;
SELECT COUNT(*) FROM large_numbers;
UPDATE mv SET id = 2 WHERE id = 1;
DELETE FROM mv WHERE id = 1;
SELECT COUNT(*) FROM copy;

-- ============================================================================
-- Test: test_drop_materialized_view
-- Source: materialized_views_comprehensive_tdd.rs:390
-- ============================================================================
DROP TABLE IF EXISTS test_table;
CREATE TABLE test_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test_table;
DROP MATERIALIZED VIEW test_mv;
DROP MATERIALIZED VIEW nonexistent_mv;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64, value INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table WHERE value > 10;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1 WHERE value < 100;
DROP MATERIALIZED VIEW mv1 CASCADE;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1;
DROP MATERIALIZED VIEW mv1 RESTRICT;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (customer_id INT64, name STRING, tier STRING);
INSERT INTO orders VALUES
(1, 101, 500.00),
(2, 102, 750.00),
(3, 101, 300.00);
INSERT INTO customers VALUES
(101, 'Alice', 'Gold'),
(102, 'Bob', 'Silver');
DROP MATERIALIZED VIEW IF EXISTS customer_orders;
CREATE MATERIALIZED VIEW customer_orders AS SELECT c.name, c.tier, SUM(o.amount) as total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name, c.tier;
DROP TABLE IF EXISTS employee_sales;
CREATE TABLE employee_sales ( employee_id INT64, sale_amount FLOAT64, sale_date DATE );
INSERT INTO employee_sales VALUES
(1, 1000.00, DATE '2024-01-01'),
(1, 1500.00, DATE '2024-01-02'),
(2, 2000.00, DATE '2024-01-01'),
(2, 1200.00, DATE '2024-01-02'),
(3, 1800.00, DATE '2024-01-01');
DROP MATERIALIZED VIEW IF EXISTS sales_with_rank;
CREATE MATERIALIZED VIEW sales_with_rank AS SELECT employee_id, SUM(sale_amount) as total_sales, RANK() OVER (ORDER BY SUM(sale_amount) DESC) as sales_rank FROM employee_sales GROUP BY employee_id;
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions ( account_id INT64, amount FLOAT64, tx_type STRING );
INSERT INTO transactions VALUES
(1, 100.00, 'credit'),
(1, 50.00, 'debit'),
(1, 200.00, 'credit'),
(2, 300.00, 'credit'),
(2, 150.00, 'debit');
DROP MATERIALIZED VIEW IF EXISTS account_balances;
CREATE MATERIALIZED VIEW account_balances AS WITH credits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'credit' GROUP BY account_id ), debits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'debit' GROUP BY account_id ) SELECT COALESCE(c.account_id, d.account_id) as account_id, COALESCE(c.total, 0) - COALESCE(d.total, 0) as balance FROM credits c FULL OUTER JOIN debits d ON c.account_id = d.account_id;
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (dept_id INT64, dept_name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (emp_id INT64, dept_id INT64, salary FLOAT64);
INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES
(1, 1, 100000.00),
(2, 1, 120000.00),
(3, 2, 80000.00),
(4, 2, 90000.00);
DROP MATERIALIZED VIEW IF EXISTS dept_avg_salary;
CREATE MATERIALIZED VIEW dept_avg_salary AS SELECT d.dept_name, (SELECT AVG(salary) FROM employees e WHERE e.dept_id = d.dept_id) as avg_salary FROM departments d;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS filtered_data;
CREATE MATERIALIZED VIEW filtered_data AS SELECT * FROM data WHERE value > 1000;
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, value FLOAT64);
DROP MATERIALIZED VIEW IF EXISTS large_mv;
CREATE MATERIALIZED VIEW large_mv AS SELECT * FROM large_table WHERE value > 500.0;
DROP TABLE IF EXISTS nullable_data;
CREATE TABLE nullable_data (id INT64, value INT64);
INSERT INTO nullable_data VALUES (1, 10), (2, NULL), (3, 30), (4, NULL);
DROP MATERIALIZED VIEW IF EXISTS non_null_data;
CREATE MATERIALIZED VIEW non_null_data AS SELECT * FROM nullable_data WHERE value IS NOT NULL;
DROP MATERIALIZED VIEW IF EXISTS invalid_mv;
CREATE MATERIALIZED VIEW invalid_mv AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS shared_name;
CREATE TABLE shared_name (id INT64);
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP VIEW IF EXISTS shared_name;
CREATE VIEW shared_name AS SELECT * FROM base;
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test WHERE id > 10;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP MATERIALIZED VIEW IF EXISTS even_numbers;
CREATE MATERIALIZED VIEW even_numbers AS SELECT * FROM numbers WHERE n % 2 = 0;
DROP MATERIALIZED VIEW IF EXISTS odd_numbers;
CREATE MATERIALIZED VIEW odd_numbers AS SELECT * FROM numbers WHERE n % 2 = 1;
DROP MATERIALIZED VIEW IF EXISTS large_numbers;
CREATE MATERIALIZED VIEW large_numbers AS SELECT * FROM numbers WHERE n > 5;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
INSERT INTO mv VALUES (1);
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WHERE value > 50;
CREATE TABLE copy AS SELECT * FROM mv;

SELECT * FROM test_mv;
SELECT * FROM mv2;
SELECT name, total_spent FROM customer_orders ORDER BY name;
SELECT employee_id, sales_rank FROM sales_with_rank ORDER BY sales_rank;
SELECT account_id, balance FROM account_balances ORDER BY account_id;
SELECT dept_name, avg_salary FROM dept_avg_salary ORDER BY dept_name;
SELECT COUNT(*) FROM filtered_data;
SELECT COUNT(*) FROM large_mv;
SELECT COUNT(*) FROM non_null_data;
REFRESH MATERIALIZED VIEW test_mv;
SELECT COUNT(*) FROM even_numbers;
SELECT COUNT(*) FROM odd_numbers;
SELECT COUNT(*) FROM large_numbers;
UPDATE mv SET id = 2 WHERE id = 1;
DELETE FROM mv WHERE id = 1;
SELECT COUNT(*) FROM copy;

-- ============================================================================
-- Test: test_drop_materialized_view_if_exists
-- Source: materialized_views_comprehensive_tdd.rs:413
-- ============================================================================
DROP MATERIALIZED VIEW nonexistent_mv;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64, value INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table WHERE value > 10;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1 WHERE value < 100;
DROP MATERIALIZED VIEW mv1 CASCADE;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1;
DROP MATERIALIZED VIEW mv1 RESTRICT;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (customer_id INT64, name STRING, tier STRING);
INSERT INTO orders VALUES
(1, 101, 500.00),
(2, 102, 750.00),
(3, 101, 300.00);
INSERT INTO customers VALUES
(101, 'Alice', 'Gold'),
(102, 'Bob', 'Silver');
DROP MATERIALIZED VIEW IF EXISTS customer_orders;
CREATE MATERIALIZED VIEW customer_orders AS SELECT c.name, c.tier, SUM(o.amount) as total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name, c.tier;
DROP TABLE IF EXISTS employee_sales;
CREATE TABLE employee_sales ( employee_id INT64, sale_amount FLOAT64, sale_date DATE );
INSERT INTO employee_sales VALUES
(1, 1000.00, DATE '2024-01-01'),
(1, 1500.00, DATE '2024-01-02'),
(2, 2000.00, DATE '2024-01-01'),
(2, 1200.00, DATE '2024-01-02'),
(3, 1800.00, DATE '2024-01-01');
DROP MATERIALIZED VIEW IF EXISTS sales_with_rank;
CREATE MATERIALIZED VIEW sales_with_rank AS SELECT employee_id, SUM(sale_amount) as total_sales, RANK() OVER (ORDER BY SUM(sale_amount) DESC) as sales_rank FROM employee_sales GROUP BY employee_id;
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions ( account_id INT64, amount FLOAT64, tx_type STRING );
INSERT INTO transactions VALUES
(1, 100.00, 'credit'),
(1, 50.00, 'debit'),
(1, 200.00, 'credit'),
(2, 300.00, 'credit'),
(2, 150.00, 'debit');
DROP MATERIALIZED VIEW IF EXISTS account_balances;
CREATE MATERIALIZED VIEW account_balances AS WITH credits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'credit' GROUP BY account_id ), debits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'debit' GROUP BY account_id ) SELECT COALESCE(c.account_id, d.account_id) as account_id, COALESCE(c.total, 0) - COALESCE(d.total, 0) as balance FROM credits c FULL OUTER JOIN debits d ON c.account_id = d.account_id;
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (dept_id INT64, dept_name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (emp_id INT64, dept_id INT64, salary FLOAT64);
INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES
(1, 1, 100000.00),
(2, 1, 120000.00),
(3, 2, 80000.00),
(4, 2, 90000.00);
DROP MATERIALIZED VIEW IF EXISTS dept_avg_salary;
CREATE MATERIALIZED VIEW dept_avg_salary AS SELECT d.dept_name, (SELECT AVG(salary) FROM employees e WHERE e.dept_id = d.dept_id) as avg_salary FROM departments d;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS filtered_data;
CREATE MATERIALIZED VIEW filtered_data AS SELECT * FROM data WHERE value > 1000;
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, value FLOAT64);
DROP MATERIALIZED VIEW IF EXISTS large_mv;
CREATE MATERIALIZED VIEW large_mv AS SELECT * FROM large_table WHERE value > 500.0;
DROP TABLE IF EXISTS nullable_data;
CREATE TABLE nullable_data (id INT64, value INT64);
INSERT INTO nullable_data VALUES (1, 10), (2, NULL), (3, 30), (4, NULL);
DROP MATERIALIZED VIEW IF EXISTS non_null_data;
CREATE MATERIALIZED VIEW non_null_data AS SELECT * FROM nullable_data WHERE value IS NOT NULL;
DROP MATERIALIZED VIEW IF EXISTS invalid_mv;
CREATE MATERIALIZED VIEW invalid_mv AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS shared_name;
CREATE TABLE shared_name (id INT64);
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP VIEW IF EXISTS shared_name;
CREATE VIEW shared_name AS SELECT * FROM base;
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test WHERE id > 10;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP MATERIALIZED VIEW IF EXISTS even_numbers;
CREATE MATERIALIZED VIEW even_numbers AS SELECT * FROM numbers WHERE n % 2 = 0;
DROP MATERIALIZED VIEW IF EXISTS odd_numbers;
CREATE MATERIALIZED VIEW odd_numbers AS SELECT * FROM numbers WHERE n % 2 = 1;
DROP MATERIALIZED VIEW IF EXISTS large_numbers;
CREATE MATERIALIZED VIEW large_numbers AS SELECT * FROM numbers WHERE n > 5;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
INSERT INTO mv VALUES (1);
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WHERE value > 50;
CREATE TABLE copy AS SELECT * FROM mv;

SELECT * FROM mv2;
SELECT name, total_spent FROM customer_orders ORDER BY name;
SELECT employee_id, sales_rank FROM sales_with_rank ORDER BY sales_rank;
SELECT account_id, balance FROM account_balances ORDER BY account_id;
SELECT dept_name, avg_salary FROM dept_avg_salary ORDER BY dept_name;
SELECT COUNT(*) FROM filtered_data;
SELECT COUNT(*) FROM large_mv;
SELECT COUNT(*) FROM non_null_data;
REFRESH MATERIALIZED VIEW test_mv;
SELECT COUNT(*) FROM even_numbers;
SELECT COUNT(*) FROM odd_numbers;
SELECT COUNT(*) FROM large_numbers;
UPDATE mv SET id = 2 WHERE id = 1;
DELETE FROM mv WHERE id = 1;
SELECT COUNT(*) FROM copy;

-- ============================================================================
-- Test: test_drop_materialized_view_not_exists_error
-- Source: materialized_views_comprehensive_tdd.rs:424
-- ============================================================================
DROP MATERIALIZED VIEW nonexistent_mv;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64, value INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table WHERE value > 10;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1 WHERE value < 100;
DROP MATERIALIZED VIEW mv1 CASCADE;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1;
DROP MATERIALIZED VIEW mv1 RESTRICT;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (customer_id INT64, name STRING, tier STRING);
INSERT INTO orders VALUES
(1, 101, 500.00),
(2, 102, 750.00),
(3, 101, 300.00);
INSERT INTO customers VALUES
(101, 'Alice', 'Gold'),
(102, 'Bob', 'Silver');
DROP MATERIALIZED VIEW IF EXISTS customer_orders;
CREATE MATERIALIZED VIEW customer_orders AS SELECT c.name, c.tier, SUM(o.amount) as total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name, c.tier;
DROP TABLE IF EXISTS employee_sales;
CREATE TABLE employee_sales ( employee_id INT64, sale_amount FLOAT64, sale_date DATE );
INSERT INTO employee_sales VALUES
(1, 1000.00, DATE '2024-01-01'),
(1, 1500.00, DATE '2024-01-02'),
(2, 2000.00, DATE '2024-01-01'),
(2, 1200.00, DATE '2024-01-02'),
(3, 1800.00, DATE '2024-01-01');
DROP MATERIALIZED VIEW IF EXISTS sales_with_rank;
CREATE MATERIALIZED VIEW sales_with_rank AS SELECT employee_id, SUM(sale_amount) as total_sales, RANK() OVER (ORDER BY SUM(sale_amount) DESC) as sales_rank FROM employee_sales GROUP BY employee_id;
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions ( account_id INT64, amount FLOAT64, tx_type STRING );
INSERT INTO transactions VALUES
(1, 100.00, 'credit'),
(1, 50.00, 'debit'),
(1, 200.00, 'credit'),
(2, 300.00, 'credit'),
(2, 150.00, 'debit');
DROP MATERIALIZED VIEW IF EXISTS account_balances;
CREATE MATERIALIZED VIEW account_balances AS WITH credits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'credit' GROUP BY account_id ), debits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'debit' GROUP BY account_id ) SELECT COALESCE(c.account_id, d.account_id) as account_id, COALESCE(c.total, 0) - COALESCE(d.total, 0) as balance FROM credits c FULL OUTER JOIN debits d ON c.account_id = d.account_id;
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (dept_id INT64, dept_name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (emp_id INT64, dept_id INT64, salary FLOAT64);
INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES
(1, 1, 100000.00),
(2, 1, 120000.00),
(3, 2, 80000.00),
(4, 2, 90000.00);
DROP MATERIALIZED VIEW IF EXISTS dept_avg_salary;
CREATE MATERIALIZED VIEW dept_avg_salary AS SELECT d.dept_name, (SELECT AVG(salary) FROM employees e WHERE e.dept_id = d.dept_id) as avg_salary FROM departments d;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS filtered_data;
CREATE MATERIALIZED VIEW filtered_data AS SELECT * FROM data WHERE value > 1000;
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, value FLOAT64);
DROP MATERIALIZED VIEW IF EXISTS large_mv;
CREATE MATERIALIZED VIEW large_mv AS SELECT * FROM large_table WHERE value > 500.0;
DROP TABLE IF EXISTS nullable_data;
CREATE TABLE nullable_data (id INT64, value INT64);
INSERT INTO nullable_data VALUES (1, 10), (2, NULL), (3, 30), (4, NULL);
DROP MATERIALIZED VIEW IF EXISTS non_null_data;
CREATE MATERIALIZED VIEW non_null_data AS SELECT * FROM nullable_data WHERE value IS NOT NULL;
DROP MATERIALIZED VIEW IF EXISTS invalid_mv;
CREATE MATERIALIZED VIEW invalid_mv AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS shared_name;
CREATE TABLE shared_name (id INT64);
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP VIEW IF EXISTS shared_name;
CREATE VIEW shared_name AS SELECT * FROM base;
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test WHERE id > 10;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP MATERIALIZED VIEW IF EXISTS even_numbers;
CREATE MATERIALIZED VIEW even_numbers AS SELECT * FROM numbers WHERE n % 2 = 0;
DROP MATERIALIZED VIEW IF EXISTS odd_numbers;
CREATE MATERIALIZED VIEW odd_numbers AS SELECT * FROM numbers WHERE n % 2 = 1;
DROP MATERIALIZED VIEW IF EXISTS large_numbers;
CREATE MATERIALIZED VIEW large_numbers AS SELECT * FROM numbers WHERE n > 5;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
INSERT INTO mv VALUES (1);
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WHERE value > 50;
CREATE TABLE copy AS SELECT * FROM mv;

SELECT * FROM mv2;
SELECT name, total_spent FROM customer_orders ORDER BY name;
SELECT employee_id, sales_rank FROM sales_with_rank ORDER BY sales_rank;
SELECT account_id, balance FROM account_balances ORDER BY account_id;
SELECT dept_name, avg_salary FROM dept_avg_salary ORDER BY dept_name;
SELECT COUNT(*) FROM filtered_data;
SELECT COUNT(*) FROM large_mv;
SELECT COUNT(*) FROM non_null_data;
REFRESH MATERIALIZED VIEW test_mv;
SELECT COUNT(*) FROM even_numbers;
SELECT COUNT(*) FROM odd_numbers;
SELECT COUNT(*) FROM large_numbers;
UPDATE mv SET id = 2 WHERE id = 1;
DELETE FROM mv WHERE id = 1;
SELECT COUNT(*) FROM copy;

-- ============================================================================
-- Test: test_drop_materialized_view_cascade
-- Source: materialized_views_comprehensive_tdd.rs:435
-- ============================================================================
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64, value INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table WHERE value > 10;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1 WHERE value < 100;
DROP MATERIALIZED VIEW mv1 CASCADE;
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1;
DROP MATERIALIZED VIEW mv1 RESTRICT;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (customer_id INT64, name STRING, tier STRING);
INSERT INTO orders VALUES
(1, 101, 500.00),
(2, 102, 750.00),
(3, 101, 300.00);
INSERT INTO customers VALUES
(101, 'Alice', 'Gold'),
(102, 'Bob', 'Silver');
DROP MATERIALIZED VIEW IF EXISTS customer_orders;
CREATE MATERIALIZED VIEW customer_orders AS SELECT c.name, c.tier, SUM(o.amount) as total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name, c.tier;
DROP TABLE IF EXISTS employee_sales;
CREATE TABLE employee_sales ( employee_id INT64, sale_amount FLOAT64, sale_date DATE );
INSERT INTO employee_sales VALUES
(1, 1000.00, DATE '2024-01-01'),
(1, 1500.00, DATE '2024-01-02'),
(2, 2000.00, DATE '2024-01-01'),
(2, 1200.00, DATE '2024-01-02'),
(3, 1800.00, DATE '2024-01-01');
DROP MATERIALIZED VIEW IF EXISTS sales_with_rank;
CREATE MATERIALIZED VIEW sales_with_rank AS SELECT employee_id, SUM(sale_amount) as total_sales, RANK() OVER (ORDER BY SUM(sale_amount) DESC) as sales_rank FROM employee_sales GROUP BY employee_id;
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions ( account_id INT64, amount FLOAT64, tx_type STRING );
INSERT INTO transactions VALUES
(1, 100.00, 'credit'),
(1, 50.00, 'debit'),
(1, 200.00, 'credit'),
(2, 300.00, 'credit'),
(2, 150.00, 'debit');
DROP MATERIALIZED VIEW IF EXISTS account_balances;
CREATE MATERIALIZED VIEW account_balances AS WITH credits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'credit' GROUP BY account_id ), debits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'debit' GROUP BY account_id ) SELECT COALESCE(c.account_id, d.account_id) as account_id, COALESCE(c.total, 0) - COALESCE(d.total, 0) as balance FROM credits c FULL OUTER JOIN debits d ON c.account_id = d.account_id;
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (dept_id INT64, dept_name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (emp_id INT64, dept_id INT64, salary FLOAT64);
INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES
(1, 1, 100000.00),
(2, 1, 120000.00),
(3, 2, 80000.00),
(4, 2, 90000.00);
DROP MATERIALIZED VIEW IF EXISTS dept_avg_salary;
CREATE MATERIALIZED VIEW dept_avg_salary AS SELECT d.dept_name, (SELECT AVG(salary) FROM employees e WHERE e.dept_id = d.dept_id) as avg_salary FROM departments d;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS filtered_data;
CREATE MATERIALIZED VIEW filtered_data AS SELECT * FROM data WHERE value > 1000;
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, value FLOAT64);
DROP MATERIALIZED VIEW IF EXISTS large_mv;
CREATE MATERIALIZED VIEW large_mv AS SELECT * FROM large_table WHERE value > 500.0;
DROP TABLE IF EXISTS nullable_data;
CREATE TABLE nullable_data (id INT64, value INT64);
INSERT INTO nullable_data VALUES (1, 10), (2, NULL), (3, 30), (4, NULL);
DROP MATERIALIZED VIEW IF EXISTS non_null_data;
CREATE MATERIALIZED VIEW non_null_data AS SELECT * FROM nullable_data WHERE value IS NOT NULL;
DROP MATERIALIZED VIEW IF EXISTS invalid_mv;
CREATE MATERIALIZED VIEW invalid_mv AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS shared_name;
CREATE TABLE shared_name (id INT64);
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP VIEW IF EXISTS shared_name;
CREATE VIEW shared_name AS SELECT * FROM base;
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test WHERE id > 10;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP MATERIALIZED VIEW IF EXISTS even_numbers;
CREATE MATERIALIZED VIEW even_numbers AS SELECT * FROM numbers WHERE n % 2 = 0;
DROP MATERIALIZED VIEW IF EXISTS odd_numbers;
CREATE MATERIALIZED VIEW odd_numbers AS SELECT * FROM numbers WHERE n % 2 = 1;
DROP MATERIALIZED VIEW IF EXISTS large_numbers;
CREATE MATERIALIZED VIEW large_numbers AS SELECT * FROM numbers WHERE n > 5;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
INSERT INTO mv VALUES (1);
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WHERE value > 50;
CREATE TABLE copy AS SELECT * FROM mv;

SELECT * FROM mv2;
SELECT name, total_spent FROM customer_orders ORDER BY name;
SELECT employee_id, sales_rank FROM sales_with_rank ORDER BY sales_rank;
SELECT account_id, balance FROM account_balances ORDER BY account_id;
SELECT dept_name, avg_salary FROM dept_avg_salary ORDER BY dept_name;
SELECT COUNT(*) FROM filtered_data;
SELECT COUNT(*) FROM large_mv;
SELECT COUNT(*) FROM non_null_data;
REFRESH MATERIALIZED VIEW test_mv;
SELECT COUNT(*) FROM even_numbers;
SELECT COUNT(*) FROM odd_numbers;
SELECT COUNT(*) FROM large_numbers;
UPDATE mv SET id = 2 WHERE id = 1;
DELETE FROM mv WHERE id = 1;
SELECT COUNT(*) FROM copy;

-- ============================================================================
-- Test: test_drop_materialized_view_restrict_error
-- Source: materialized_views_comprehensive_tdd.rs:462
-- ============================================================================
DROP TABLE IF EXISTS base_table;
CREATE TABLE base_table (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv1;
CREATE MATERIALIZED VIEW mv1 AS SELECT * FROM base_table;
DROP MATERIALIZED VIEW IF EXISTS mv2;
CREATE MATERIALIZED VIEW mv2 AS SELECT * FROM mv1;
DROP MATERIALIZED VIEW mv1 RESTRICT;
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (customer_id INT64, name STRING, tier STRING);
INSERT INTO orders VALUES
(1, 101, 500.00),
(2, 102, 750.00),
(3, 101, 300.00);
INSERT INTO customers VALUES
(101, 'Alice', 'Gold'),
(102, 'Bob', 'Silver');
DROP MATERIALIZED VIEW IF EXISTS customer_orders;
CREATE MATERIALIZED VIEW customer_orders AS SELECT c.name, c.tier, SUM(o.amount) as total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name, c.tier;
DROP TABLE IF EXISTS employee_sales;
CREATE TABLE employee_sales ( employee_id INT64, sale_amount FLOAT64, sale_date DATE );
INSERT INTO employee_sales VALUES
(1, 1000.00, DATE '2024-01-01'),
(1, 1500.00, DATE '2024-01-02'),
(2, 2000.00, DATE '2024-01-01'),
(2, 1200.00, DATE '2024-01-02'),
(3, 1800.00, DATE '2024-01-01');
DROP MATERIALIZED VIEW IF EXISTS sales_with_rank;
CREATE MATERIALIZED VIEW sales_with_rank AS SELECT employee_id, SUM(sale_amount) as total_sales, RANK() OVER (ORDER BY SUM(sale_amount) DESC) as sales_rank FROM employee_sales GROUP BY employee_id;
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions ( account_id INT64, amount FLOAT64, tx_type STRING );
INSERT INTO transactions VALUES
(1, 100.00, 'credit'),
(1, 50.00, 'debit'),
(1, 200.00, 'credit'),
(2, 300.00, 'credit'),
(2, 150.00, 'debit');
DROP MATERIALIZED VIEW IF EXISTS account_balances;
CREATE MATERIALIZED VIEW account_balances AS WITH credits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'credit' GROUP BY account_id ), debits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'debit' GROUP BY account_id ) SELECT COALESCE(c.account_id, d.account_id) as account_id, COALESCE(c.total, 0) - COALESCE(d.total, 0) as balance FROM credits c FULL OUTER JOIN debits d ON c.account_id = d.account_id;
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (dept_id INT64, dept_name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (emp_id INT64, dept_id INT64, salary FLOAT64);
INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES
(1, 1, 100000.00),
(2, 1, 120000.00),
(3, 2, 80000.00),
(4, 2, 90000.00);
DROP MATERIALIZED VIEW IF EXISTS dept_avg_salary;
CREATE MATERIALIZED VIEW dept_avg_salary AS SELECT d.dept_name, (SELECT AVG(salary) FROM employees e WHERE e.dept_id = d.dept_id) as avg_salary FROM departments d;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS filtered_data;
CREATE MATERIALIZED VIEW filtered_data AS SELECT * FROM data WHERE value > 1000;
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, value FLOAT64);
DROP MATERIALIZED VIEW IF EXISTS large_mv;
CREATE MATERIALIZED VIEW large_mv AS SELECT * FROM large_table WHERE value > 500.0;
DROP TABLE IF EXISTS nullable_data;
CREATE TABLE nullable_data (id INT64, value INT64);
INSERT INTO nullable_data VALUES (1, 10), (2, NULL), (3, 30), (4, NULL);
DROP MATERIALIZED VIEW IF EXISTS non_null_data;
CREATE MATERIALIZED VIEW non_null_data AS SELECT * FROM nullable_data WHERE value IS NOT NULL;
DROP MATERIALIZED VIEW IF EXISTS invalid_mv;
CREATE MATERIALIZED VIEW invalid_mv AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS shared_name;
CREATE TABLE shared_name (id INT64);
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP VIEW IF EXISTS shared_name;
CREATE VIEW shared_name AS SELECT * FROM base;
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test WHERE id > 10;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP MATERIALIZED VIEW IF EXISTS even_numbers;
CREATE MATERIALIZED VIEW even_numbers AS SELECT * FROM numbers WHERE n % 2 = 0;
DROP MATERIALIZED VIEW IF EXISTS odd_numbers;
CREATE MATERIALIZED VIEW odd_numbers AS SELECT * FROM numbers WHERE n % 2 = 1;
DROP MATERIALIZED VIEW IF EXISTS large_numbers;
CREATE MATERIALIZED VIEW large_numbers AS SELECT * FROM numbers WHERE n > 5;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
INSERT INTO mv VALUES (1);
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WHERE value > 50;
CREATE TABLE copy AS SELECT * FROM mv;

SELECT name, total_spent FROM customer_orders ORDER BY name;
SELECT employee_id, sales_rank FROM sales_with_rank ORDER BY sales_rank;
SELECT account_id, balance FROM account_balances ORDER BY account_id;
SELECT dept_name, avg_salary FROM dept_avg_salary ORDER BY dept_name;
SELECT COUNT(*) FROM filtered_data;
SELECT COUNT(*) FROM large_mv;
SELECT COUNT(*) FROM non_null_data;
REFRESH MATERIALIZED VIEW test_mv;
SELECT COUNT(*) FROM even_numbers;
SELECT COUNT(*) FROM odd_numbers;
SELECT COUNT(*) FROM large_numbers;
UPDATE mv SET id = 2 WHERE id = 1;
DELETE FROM mv WHERE id = 1;
SELECT COUNT(*) FROM copy;

-- ============================================================================
-- Test: test_materialized_view_with_join
-- Source: materialized_views_comprehensive_tdd.rs:490
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, customer_id INT64, amount FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (customer_id INT64, name STRING, tier STRING);
INSERT INTO orders VALUES
(1, 101, 500.00),
(2, 102, 750.00),
(3, 101, 300.00);
INSERT INTO customers VALUES
(101, 'Alice', 'Gold'),
(102, 'Bob', 'Silver');
DROP MATERIALIZED VIEW IF EXISTS customer_orders;
CREATE MATERIALIZED VIEW customer_orders AS SELECT c.name, c.tier, SUM(o.amount) as total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name, c.tier;
DROP TABLE IF EXISTS employee_sales;
CREATE TABLE employee_sales ( employee_id INT64, sale_amount FLOAT64, sale_date DATE );
INSERT INTO employee_sales VALUES
(1, 1000.00, DATE '2024-01-01'),
(1, 1500.00, DATE '2024-01-02'),
(2, 2000.00, DATE '2024-01-01'),
(2, 1200.00, DATE '2024-01-02'),
(3, 1800.00, DATE '2024-01-01');
DROP MATERIALIZED VIEW IF EXISTS sales_with_rank;
CREATE MATERIALIZED VIEW sales_with_rank AS SELECT employee_id, SUM(sale_amount) as total_sales, RANK() OVER (ORDER BY SUM(sale_amount) DESC) as sales_rank FROM employee_sales GROUP BY employee_id;
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions ( account_id INT64, amount FLOAT64, tx_type STRING );
INSERT INTO transactions VALUES
(1, 100.00, 'credit'),
(1, 50.00, 'debit'),
(1, 200.00, 'credit'),
(2, 300.00, 'credit'),
(2, 150.00, 'debit');
DROP MATERIALIZED VIEW IF EXISTS account_balances;
CREATE MATERIALIZED VIEW account_balances AS WITH credits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'credit' GROUP BY account_id ), debits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'debit' GROUP BY account_id ) SELECT COALESCE(c.account_id, d.account_id) as account_id, COALESCE(c.total, 0) - COALESCE(d.total, 0) as balance FROM credits c FULL OUTER JOIN debits d ON c.account_id = d.account_id;
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (dept_id INT64, dept_name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (emp_id INT64, dept_id INT64, salary FLOAT64);
INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES
(1, 1, 100000.00),
(2, 1, 120000.00),
(3, 2, 80000.00),
(4, 2, 90000.00);
DROP MATERIALIZED VIEW IF EXISTS dept_avg_salary;
CREATE MATERIALIZED VIEW dept_avg_salary AS SELECT d.dept_name, (SELECT AVG(salary) FROM employees e WHERE e.dept_id = d.dept_id) as avg_salary FROM departments d;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS filtered_data;
CREATE MATERIALIZED VIEW filtered_data AS SELECT * FROM data WHERE value > 1000;
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, value FLOAT64);
DROP MATERIALIZED VIEW IF EXISTS large_mv;
CREATE MATERIALIZED VIEW large_mv AS SELECT * FROM large_table WHERE value > 500.0;
DROP TABLE IF EXISTS nullable_data;
CREATE TABLE nullable_data (id INT64, value INT64);
INSERT INTO nullable_data VALUES (1, 10), (2, NULL), (3, 30), (4, NULL);
DROP MATERIALIZED VIEW IF EXISTS non_null_data;
CREATE MATERIALIZED VIEW non_null_data AS SELECT * FROM nullable_data WHERE value IS NOT NULL;
DROP MATERIALIZED VIEW IF EXISTS invalid_mv;
CREATE MATERIALIZED VIEW invalid_mv AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS shared_name;
CREATE TABLE shared_name (id INT64);
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP VIEW IF EXISTS shared_name;
CREATE VIEW shared_name AS SELECT * FROM base;
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test WHERE id > 10;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP MATERIALIZED VIEW IF EXISTS even_numbers;
CREATE MATERIALIZED VIEW even_numbers AS SELECT * FROM numbers WHERE n % 2 = 0;
DROP MATERIALIZED VIEW IF EXISTS odd_numbers;
CREATE MATERIALIZED VIEW odd_numbers AS SELECT * FROM numbers WHERE n % 2 = 1;
DROP MATERIALIZED VIEW IF EXISTS large_numbers;
CREATE MATERIALIZED VIEW large_numbers AS SELECT * FROM numbers WHERE n > 5;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
INSERT INTO mv VALUES (1);
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WHERE value > 50;
CREATE TABLE copy AS SELECT * FROM mv;

SELECT name, total_spent FROM customer_orders ORDER BY name;
SELECT employee_id, sales_rank FROM sales_with_rank ORDER BY sales_rank;
SELECT account_id, balance FROM account_balances ORDER BY account_id;
SELECT dept_name, avg_salary FROM dept_avg_salary ORDER BY dept_name;
SELECT COUNT(*) FROM filtered_data;
SELECT COUNT(*) FROM large_mv;
SELECT COUNT(*) FROM non_null_data;
REFRESH MATERIALIZED VIEW test_mv;
SELECT COUNT(*) FROM even_numbers;
SELECT COUNT(*) FROM odd_numbers;
SELECT COUNT(*) FROM large_numbers;
UPDATE mv SET id = 2 WHERE id = 1;
DELETE FROM mv WHERE id = 1;
SELECT COUNT(*) FROM copy;

-- ============================================================================
-- Test: test_materialized_view_with_window_function
-- Source: materialized_views_comprehensive_tdd.rs:541
-- ============================================================================
DROP TABLE IF EXISTS employee_sales;
CREATE TABLE employee_sales ( employee_id INT64, sale_amount FLOAT64, sale_date DATE );
INSERT INTO employee_sales VALUES
(1, 1000.00, DATE '2024-01-01'),
(1, 1500.00, DATE '2024-01-02'),
(2, 2000.00, DATE '2024-01-01'),
(2, 1200.00, DATE '2024-01-02'),
(3, 1800.00, DATE '2024-01-01');
DROP MATERIALIZED VIEW IF EXISTS sales_with_rank;
CREATE MATERIALIZED VIEW sales_with_rank AS SELECT employee_id, SUM(sale_amount) as total_sales, RANK() OVER (ORDER BY SUM(sale_amount) DESC) as sales_rank FROM employee_sales GROUP BY employee_id;
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions ( account_id INT64, amount FLOAT64, tx_type STRING );
INSERT INTO transactions VALUES
(1, 100.00, 'credit'),
(1, 50.00, 'debit'),
(1, 200.00, 'credit'),
(2, 300.00, 'credit'),
(2, 150.00, 'debit');
DROP MATERIALIZED VIEW IF EXISTS account_balances;
CREATE MATERIALIZED VIEW account_balances AS WITH credits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'credit' GROUP BY account_id ), debits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'debit' GROUP BY account_id ) SELECT COALESCE(c.account_id, d.account_id) as account_id, COALESCE(c.total, 0) - COALESCE(d.total, 0) as balance FROM credits c FULL OUTER JOIN debits d ON c.account_id = d.account_id;
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (dept_id INT64, dept_name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (emp_id INT64, dept_id INT64, salary FLOAT64);
INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES
(1, 1, 100000.00),
(2, 1, 120000.00),
(3, 2, 80000.00),
(4, 2, 90000.00);
DROP MATERIALIZED VIEW IF EXISTS dept_avg_salary;
CREATE MATERIALIZED VIEW dept_avg_salary AS SELECT d.dept_name, (SELECT AVG(salary) FROM employees e WHERE e.dept_id = d.dept_id) as avg_salary FROM departments d;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS filtered_data;
CREATE MATERIALIZED VIEW filtered_data AS SELECT * FROM data WHERE value > 1000;
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, value FLOAT64);
DROP MATERIALIZED VIEW IF EXISTS large_mv;
CREATE MATERIALIZED VIEW large_mv AS SELECT * FROM large_table WHERE value > 500.0;
DROP TABLE IF EXISTS nullable_data;
CREATE TABLE nullable_data (id INT64, value INT64);
INSERT INTO nullable_data VALUES (1, 10), (2, NULL), (3, 30), (4, NULL);
DROP MATERIALIZED VIEW IF EXISTS non_null_data;
CREATE MATERIALIZED VIEW non_null_data AS SELECT * FROM nullable_data WHERE value IS NOT NULL;
DROP MATERIALIZED VIEW IF EXISTS invalid_mv;
CREATE MATERIALIZED VIEW invalid_mv AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS shared_name;
CREATE TABLE shared_name (id INT64);
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP VIEW IF EXISTS shared_name;
CREATE VIEW shared_name AS SELECT * FROM base;
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test WHERE id > 10;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP MATERIALIZED VIEW IF EXISTS even_numbers;
CREATE MATERIALIZED VIEW even_numbers AS SELECT * FROM numbers WHERE n % 2 = 0;
DROP MATERIALIZED VIEW IF EXISTS odd_numbers;
CREATE MATERIALIZED VIEW odd_numbers AS SELECT * FROM numbers WHERE n % 2 = 1;
DROP MATERIALIZED VIEW IF EXISTS large_numbers;
CREATE MATERIALIZED VIEW large_numbers AS SELECT * FROM numbers WHERE n > 5;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
INSERT INTO mv VALUES (1);
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WHERE value > 50;
CREATE TABLE copy AS SELECT * FROM mv;

SELECT employee_id, sales_rank FROM sales_with_rank ORDER BY sales_rank;
SELECT account_id, balance FROM account_balances ORDER BY account_id;
SELECT dept_name, avg_salary FROM dept_avg_salary ORDER BY dept_name;
SELECT COUNT(*) FROM filtered_data;
SELECT COUNT(*) FROM large_mv;
SELECT COUNT(*) FROM non_null_data;
REFRESH MATERIALIZED VIEW test_mv;
SELECT COUNT(*) FROM even_numbers;
SELECT COUNT(*) FROM odd_numbers;
SELECT COUNT(*) FROM large_numbers;
UPDATE mv SET id = 2 WHERE id = 1;
DELETE FROM mv WHERE id = 1;
SELECT COUNT(*) FROM copy;

-- ============================================================================
-- Test: test_merge_basic_upsert
-- Source: merge_statement_comprehensive_tdd.rs:86
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price INT64);
INSERT INTO products VALUES
(1, 'Widget', 100),
(2, 'Gadget', 200);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, name STRING, price INT64);
INSERT INTO updates VALUES
(1, 'Widget', 150),
(3, 'Doohickey', 300);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (id INT64, quantity INT64);
INSERT INTO inventory VALUES (1, 100), (2, 200), (3, 300);
DROP TABLE IF EXISTS adjustments;
CREATE TABLE adjustments (id INT64, adjustment INT64);
INSERT INTO adjustments VALUES (1, -10), (2, 20);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
DROP TABLE IF EXISTS new_customers;
CREATE TABLE new_customers (id INT64, name STRING);
INSERT INTO new_customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep'), (2, 'delete'), (3, 'delete');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'keep'), (4, 'new');
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (id INT64, price INT64);
INSERT INTO prices VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS new_prices;
CREATE TABLE new_prices (id INT64, price INT64);
INSERT INTO new_prices VALUES (1, 90), (2, 250);
DROP TABLE IF EXISTS high_values;
CREATE TABLE high_values (id INT64, value INT64);
DROP TABLE IF EXISTS candidates;
CREATE TABLE candidates (id INT64, value INT64);
INSERT INTO candidates VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS accounts;
CREATE TABLE accounts (id INT64, balance INT64, status STRING);
INSERT INTO accounts VALUES
(1, 1000, 'active'),
(2, 100, 'active');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64);
INSERT INTO transactions VALUES (1, -1500), (2, 200);
DROP TABLE IF EXISTS summary;
CREATE TABLE summary (category STRING, total INT64);
INSERT INTO summary VALUES ('A', 100), ('B', 200);
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (category STRING, amount INT64);
INSERT INTO transactions VALUES
('A', 10), ('A', 20),
('B', 30),
('C', 40), ('C', 50);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS raw_data;
CREATE TABLE raw_data (id INT64, val1 INT64, val2 INT64);
INSERT INTO raw_data VALUES (1, 5, 10), (2, 15, 20);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category_id INT64);
INSERT INTO products VALUES (1, 'Widget', 1);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING);
INSERT INTO categories VALUES (1, 'Hardware'), (2, 'Software');
DROP TABLE IF EXISTS product_details;
CREATE TABLE product_details (id INT64, category_name STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'one'), (NULL, 'null_target');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'updated'), (NULL, 'null_source');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
INSERT INTO target VALUES (1), (2);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'update1'), (1, 'update2');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64 PRIMARY KEY, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30), (2, 40);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30);

MERGE INTO products p
USING updates u
ON p.id = u.id
WHEN MATCHED THEN
UPDATE SET p.price = u.price
WHEN NOT MATCHED THEN
INSERT (id, name, price) VALUES (u.id, u.name, u.price);
SELECT * FROM products ORDER BY id;
MERGE INTO inventory i
USING adjustments a
ON i.id = a.id
WHEN MATCHED THEN
UPDATE SET i.quantity = i.quantity + a.adjustment;
SELECT * FROM inventory ORDER BY id;
MERGE INTO customers c
USING new_customers nc
ON c.id = nc.id
WHEN NOT MATCHED THEN
INSERT (id, name) VALUES (nc.id, nc.name);
SELECT * FROM customers ORDER BY id;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value)
WHEN NOT MATCHED BY SOURCE THEN
DELETE;
SELECT id FROM target ORDER BY id;
MERGE INTO prices p
USING new_prices np
ON p.id = np.id
WHEN MATCHED AND np.price > p.price THEN
UPDATE SET p.price = np.price;
SELECT * FROM prices ORDER BY id;
MERGE INTO high_values hv
USING candidates c
ON hv.id = c.id
WHEN NOT MATCHED AND c.value > 100 THEN
INSERT (id, value) VALUES (c.id, c.value);
SELECT id FROM high_values ORDER BY id;
MERGE INTO accounts a
USING transactions t
ON a.id = t.id
WHEN MATCHED AND a.balance + t.amount < 0 THEN
UPDATE SET a.status = 'overdrawn'
WHEN MATCHED THEN
UPDATE SET a.balance = a.balance + t.amount;
SELECT * FROM accounts ORDER BY id;
MERGE INTO summary s
USING (
SELECT category, SUM(amount) as total
FROM transactions
GROUP BY category
) t
ON s.category = t.category
WHEN MATCHED THEN
UPDATE SET s.total = s.total + t.total
WHEN NOT MATCHED THEN
INSERT (category, total) VALUES (t.category, t.total);
SELECT * FROM summary ORDER BY category;
WITH computed AS (
SELECT id, val1 + val2 AS total
FROM raw_data
)
MERGE INTO target t
USING computed c
ON t.id = c.id
WHEN MATCHED THEN
UPDATE SET t.value = c.total
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (c.id, c.total);
SELECT * FROM target ORDER BY id;
MERGE INTO product_details pd
USING (
SELECT p.id, c.name as category_name
FROM products p
JOIN categories c ON p.category_id = c.id
) src
ON pd.id = src.id
WHEN MATCHED THEN
UPDATE SET pd.category_name = src.category_name
WHEN NOT MATCHED THEN
INSERT (id, category_name) VALUES (src.id, src.category_name);
SELECT * FROM product_details;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
SELECT * FROM target WHERE id IS NOT NULL ORDER BY id;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = s.id
WHEN NOT MATCHED BY SOURCE THEN
DELETE;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN NOT MATCHED THEN
INSERT (id) VALUES (s.id);
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value;
MERGE INTO nonexistent t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = s.id;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.nonexistent = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
SELECT value FROM target WHERE id = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value)
RETURNING t.id, t.value;

-- ============================================================================
-- Test: test_merge_update_only
-- Source: merge_statement_comprehensive_tdd.rs:159
-- ============================================================================
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (id INT64, quantity INT64);
INSERT INTO inventory VALUES (1, 100), (2, 200), (3, 300);
DROP TABLE IF EXISTS adjustments;
CREATE TABLE adjustments (id INT64, adjustment INT64);
INSERT INTO adjustments VALUES (1, -10), (2, 20);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
DROP TABLE IF EXISTS new_customers;
CREATE TABLE new_customers (id INT64, name STRING);
INSERT INTO new_customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep'), (2, 'delete'), (3, 'delete');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'keep'), (4, 'new');
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (id INT64, price INT64);
INSERT INTO prices VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS new_prices;
CREATE TABLE new_prices (id INT64, price INT64);
INSERT INTO new_prices VALUES (1, 90), (2, 250);
DROP TABLE IF EXISTS high_values;
CREATE TABLE high_values (id INT64, value INT64);
DROP TABLE IF EXISTS candidates;
CREATE TABLE candidates (id INT64, value INT64);
INSERT INTO candidates VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS accounts;
CREATE TABLE accounts (id INT64, balance INT64, status STRING);
INSERT INTO accounts VALUES
(1, 1000, 'active'),
(2, 100, 'active');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64);
INSERT INTO transactions VALUES (1, -1500), (2, 200);
DROP TABLE IF EXISTS summary;
CREATE TABLE summary (category STRING, total INT64);
INSERT INTO summary VALUES ('A', 100), ('B', 200);
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (category STRING, amount INT64);
INSERT INTO transactions VALUES
('A', 10), ('A', 20),
('B', 30),
('C', 40), ('C', 50);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS raw_data;
CREATE TABLE raw_data (id INT64, val1 INT64, val2 INT64);
INSERT INTO raw_data VALUES (1, 5, 10), (2, 15, 20);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category_id INT64);
INSERT INTO products VALUES (1, 'Widget', 1);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING);
INSERT INTO categories VALUES (1, 'Hardware'), (2, 'Software');
DROP TABLE IF EXISTS product_details;
CREATE TABLE product_details (id INT64, category_name STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'one'), (NULL, 'null_target');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'updated'), (NULL, 'null_source');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
INSERT INTO target VALUES (1), (2);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'update1'), (1, 'update2');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64 PRIMARY KEY, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30), (2, 40);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30);

MERGE INTO inventory i
USING adjustments a
ON i.id = a.id
WHEN MATCHED THEN
UPDATE SET i.quantity = i.quantity + a.adjustment;
SELECT * FROM inventory ORDER BY id;
MERGE INTO customers c
USING new_customers nc
ON c.id = nc.id
WHEN NOT MATCHED THEN
INSERT (id, name) VALUES (nc.id, nc.name);
SELECT * FROM customers ORDER BY id;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value)
WHEN NOT MATCHED BY SOURCE THEN
DELETE;
SELECT id FROM target ORDER BY id;
MERGE INTO prices p
USING new_prices np
ON p.id = np.id
WHEN MATCHED AND np.price > p.price THEN
UPDATE SET p.price = np.price;
SELECT * FROM prices ORDER BY id;
MERGE INTO high_values hv
USING candidates c
ON hv.id = c.id
WHEN NOT MATCHED AND c.value > 100 THEN
INSERT (id, value) VALUES (c.id, c.value);
SELECT id FROM high_values ORDER BY id;
MERGE INTO accounts a
USING transactions t
ON a.id = t.id
WHEN MATCHED AND a.balance + t.amount < 0 THEN
UPDATE SET a.status = 'overdrawn'
WHEN MATCHED THEN
UPDATE SET a.balance = a.balance + t.amount;
SELECT * FROM accounts ORDER BY id;
MERGE INTO summary s
USING (
SELECT category, SUM(amount) as total
FROM transactions
GROUP BY category
) t
ON s.category = t.category
WHEN MATCHED THEN
UPDATE SET s.total = s.total + t.total
WHEN NOT MATCHED THEN
INSERT (category, total) VALUES (t.category, t.total);
SELECT * FROM summary ORDER BY category;
WITH computed AS (
SELECT id, val1 + val2 AS total
FROM raw_data
)
MERGE INTO target t
USING computed c
ON t.id = c.id
WHEN MATCHED THEN
UPDATE SET t.value = c.total
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (c.id, c.total);
SELECT * FROM target ORDER BY id;
MERGE INTO product_details pd
USING (
SELECT p.id, c.name as category_name
FROM products p
JOIN categories c ON p.category_id = c.id
) src
ON pd.id = src.id
WHEN MATCHED THEN
UPDATE SET pd.category_name = src.category_name
WHEN NOT MATCHED THEN
INSERT (id, category_name) VALUES (src.id, src.category_name);
SELECT * FROM product_details;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
SELECT * FROM target WHERE id IS NOT NULL ORDER BY id;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = s.id
WHEN NOT MATCHED BY SOURCE THEN
DELETE;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN NOT MATCHED THEN
INSERT (id) VALUES (s.id);
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value;
MERGE INTO nonexistent t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = s.id;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.nonexistent = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
SELECT value FROM target WHERE id = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value)
RETURNING t.id, t.value;

-- ============================================================================
-- Test: test_merge_insert_only
-- Source: merge_statement_comprehensive_tdd.rs:211
-- ============================================================================
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, name STRING);
INSERT INTO customers VALUES (1, 'Alice');
DROP TABLE IF EXISTS new_customers;
CREATE TABLE new_customers (id INT64, name STRING);
INSERT INTO new_customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep'), (2, 'delete'), (3, 'delete');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'keep'), (4, 'new');
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (id INT64, price INT64);
INSERT INTO prices VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS new_prices;
CREATE TABLE new_prices (id INT64, price INT64);
INSERT INTO new_prices VALUES (1, 90), (2, 250);
DROP TABLE IF EXISTS high_values;
CREATE TABLE high_values (id INT64, value INT64);
DROP TABLE IF EXISTS candidates;
CREATE TABLE candidates (id INT64, value INT64);
INSERT INTO candidates VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS accounts;
CREATE TABLE accounts (id INT64, balance INT64, status STRING);
INSERT INTO accounts VALUES
(1, 1000, 'active'),
(2, 100, 'active');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64);
INSERT INTO transactions VALUES (1, -1500), (2, 200);
DROP TABLE IF EXISTS summary;
CREATE TABLE summary (category STRING, total INT64);
INSERT INTO summary VALUES ('A', 100), ('B', 200);
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (category STRING, amount INT64);
INSERT INTO transactions VALUES
('A', 10), ('A', 20),
('B', 30),
('C', 40), ('C', 50);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS raw_data;
CREATE TABLE raw_data (id INT64, val1 INT64, val2 INT64);
INSERT INTO raw_data VALUES (1, 5, 10), (2, 15, 20);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category_id INT64);
INSERT INTO products VALUES (1, 'Widget', 1);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING);
INSERT INTO categories VALUES (1, 'Hardware'), (2, 'Software');
DROP TABLE IF EXISTS product_details;
CREATE TABLE product_details (id INT64, category_name STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'one'), (NULL, 'null_target');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'updated'), (NULL, 'null_source');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
INSERT INTO target VALUES (1), (2);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'update1'), (1, 'update2');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64 PRIMARY KEY, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30), (2, 40);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30);

MERGE INTO customers c
USING new_customers nc
ON c.id = nc.id
WHEN NOT MATCHED THEN
INSERT (id, name) VALUES (nc.id, nc.name);
SELECT * FROM customers ORDER BY id;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value)
WHEN NOT MATCHED BY SOURCE THEN
DELETE;
SELECT id FROM target ORDER BY id;
MERGE INTO prices p
USING new_prices np
ON p.id = np.id
WHEN MATCHED AND np.price > p.price THEN
UPDATE SET p.price = np.price;
SELECT * FROM prices ORDER BY id;
MERGE INTO high_values hv
USING candidates c
ON hv.id = c.id
WHEN NOT MATCHED AND c.value > 100 THEN
INSERT (id, value) VALUES (c.id, c.value);
SELECT id FROM high_values ORDER BY id;
MERGE INTO accounts a
USING transactions t
ON a.id = t.id
WHEN MATCHED AND a.balance + t.amount < 0 THEN
UPDATE SET a.status = 'overdrawn'
WHEN MATCHED THEN
UPDATE SET a.balance = a.balance + t.amount;
SELECT * FROM accounts ORDER BY id;
MERGE INTO summary s
USING (
SELECT category, SUM(amount) as total
FROM transactions
GROUP BY category
) t
ON s.category = t.category
WHEN MATCHED THEN
UPDATE SET s.total = s.total + t.total
WHEN NOT MATCHED THEN
INSERT (category, total) VALUES (t.category, t.total);
SELECT * FROM summary ORDER BY category;
WITH computed AS (
SELECT id, val1 + val2 AS total
FROM raw_data
)
MERGE INTO target t
USING computed c
ON t.id = c.id
WHEN MATCHED THEN
UPDATE SET t.value = c.total
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (c.id, c.total);
SELECT * FROM target ORDER BY id;
MERGE INTO product_details pd
USING (
SELECT p.id, c.name as category_name
FROM products p
JOIN categories c ON p.category_id = c.id
) src
ON pd.id = src.id
WHEN MATCHED THEN
UPDATE SET pd.category_name = src.category_name
WHEN NOT MATCHED THEN
INSERT (id, category_name) VALUES (src.id, src.category_name);
SELECT * FROM product_details;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
SELECT * FROM target WHERE id IS NOT NULL ORDER BY id;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = s.id
WHEN NOT MATCHED BY SOURCE THEN
DELETE;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN NOT MATCHED THEN
INSERT (id) VALUES (s.id);
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value;
MERGE INTO nonexistent t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = s.id;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.nonexistent = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
SELECT value FROM target WHERE id = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value)
RETURNING t.id, t.value;

-- ============================================================================
-- Test: test_merge_delete_not_matched_by_source
-- Source: merge_statement_comprehensive_tdd.rs:260
-- ============================================================================
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'keep'), (2, 'delete'), (3, 'delete');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'keep'), (4, 'new');
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (id INT64, price INT64);
INSERT INTO prices VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS new_prices;
CREATE TABLE new_prices (id INT64, price INT64);
INSERT INTO new_prices VALUES (1, 90), (2, 250);
DROP TABLE IF EXISTS high_values;
CREATE TABLE high_values (id INT64, value INT64);
DROP TABLE IF EXISTS candidates;
CREATE TABLE candidates (id INT64, value INT64);
INSERT INTO candidates VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS accounts;
CREATE TABLE accounts (id INT64, balance INT64, status STRING);
INSERT INTO accounts VALUES
(1, 1000, 'active'),
(2, 100, 'active');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64);
INSERT INTO transactions VALUES (1, -1500), (2, 200);
DROP TABLE IF EXISTS summary;
CREATE TABLE summary (category STRING, total INT64);
INSERT INTO summary VALUES ('A', 100), ('B', 200);
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (category STRING, amount INT64);
INSERT INTO transactions VALUES
('A', 10), ('A', 20),
('B', 30),
('C', 40), ('C', 50);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS raw_data;
CREATE TABLE raw_data (id INT64, val1 INT64, val2 INT64);
INSERT INTO raw_data VALUES (1, 5, 10), (2, 15, 20);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category_id INT64);
INSERT INTO products VALUES (1, 'Widget', 1);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING);
INSERT INTO categories VALUES (1, 'Hardware'), (2, 'Software');
DROP TABLE IF EXISTS product_details;
CREATE TABLE product_details (id INT64, category_name STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'one'), (NULL, 'null_target');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'updated'), (NULL, 'null_source');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
INSERT INTO target VALUES (1), (2);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'update1'), (1, 'update2');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64 PRIMARY KEY, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30), (2, 40);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30);

MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value)
WHEN NOT MATCHED BY SOURCE THEN
DELETE;
SELECT id FROM target ORDER BY id;
MERGE INTO prices p
USING new_prices np
ON p.id = np.id
WHEN MATCHED AND np.price > p.price THEN
UPDATE SET p.price = np.price;
SELECT * FROM prices ORDER BY id;
MERGE INTO high_values hv
USING candidates c
ON hv.id = c.id
WHEN NOT MATCHED AND c.value > 100 THEN
INSERT (id, value) VALUES (c.id, c.value);
SELECT id FROM high_values ORDER BY id;
MERGE INTO accounts a
USING transactions t
ON a.id = t.id
WHEN MATCHED AND a.balance + t.amount < 0 THEN
UPDATE SET a.status = 'overdrawn'
WHEN MATCHED THEN
UPDATE SET a.balance = a.balance + t.amount;
SELECT * FROM accounts ORDER BY id;
MERGE INTO summary s
USING (
SELECT category, SUM(amount) as total
FROM transactions
GROUP BY category
) t
ON s.category = t.category
WHEN MATCHED THEN
UPDATE SET s.total = s.total + t.total
WHEN NOT MATCHED THEN
INSERT (category, total) VALUES (t.category, t.total);
SELECT * FROM summary ORDER BY category;
WITH computed AS (
SELECT id, val1 + val2 AS total
FROM raw_data
)
MERGE INTO target t
USING computed c
ON t.id = c.id
WHEN MATCHED THEN
UPDATE SET t.value = c.total
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (c.id, c.total);
SELECT * FROM target ORDER BY id;
MERGE INTO product_details pd
USING (
SELECT p.id, c.name as category_name
FROM products p
JOIN categories c ON p.category_id = c.id
) src
ON pd.id = src.id
WHEN MATCHED THEN
UPDATE SET pd.category_name = src.category_name
WHEN NOT MATCHED THEN
INSERT (id, category_name) VALUES (src.id, src.category_name);
SELECT * FROM product_details;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
SELECT * FROM target WHERE id IS NOT NULL ORDER BY id;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = s.id
WHEN NOT MATCHED BY SOURCE THEN
DELETE;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN NOT MATCHED THEN
INSERT (id) VALUES (s.id);
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value;
MERGE INTO nonexistent t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = s.id;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.nonexistent = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
SELECT value FROM target WHERE id = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value)
RETURNING t.id, t.value;

-- ============================================================================
-- Test: test_merge_conditional_update
-- Source: merge_statement_comprehensive_tdd.rs:317
-- ============================================================================
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (id INT64, price INT64);
INSERT INTO prices VALUES (1, 100), (2, 200);
DROP TABLE IF EXISTS new_prices;
CREATE TABLE new_prices (id INT64, price INT64);
INSERT INTO new_prices VALUES (1, 90), (2, 250);
DROP TABLE IF EXISTS high_values;
CREATE TABLE high_values (id INT64, value INT64);
DROP TABLE IF EXISTS candidates;
CREATE TABLE candidates (id INT64, value INT64);
INSERT INTO candidates VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS accounts;
CREATE TABLE accounts (id INT64, balance INT64, status STRING);
INSERT INTO accounts VALUES
(1, 1000, 'active'),
(2, 100, 'active');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64);
INSERT INTO transactions VALUES (1, -1500), (2, 200);
DROP TABLE IF EXISTS summary;
CREATE TABLE summary (category STRING, total INT64);
INSERT INTO summary VALUES ('A', 100), ('B', 200);
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (category STRING, amount INT64);
INSERT INTO transactions VALUES
('A', 10), ('A', 20),
('B', 30),
('C', 40), ('C', 50);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS raw_data;
CREATE TABLE raw_data (id INT64, val1 INT64, val2 INT64);
INSERT INTO raw_data VALUES (1, 5, 10), (2, 15, 20);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category_id INT64);
INSERT INTO products VALUES (1, 'Widget', 1);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING);
INSERT INTO categories VALUES (1, 'Hardware'), (2, 'Software');
DROP TABLE IF EXISTS product_details;
CREATE TABLE product_details (id INT64, category_name STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'one'), (NULL, 'null_target');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'updated'), (NULL, 'null_source');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
INSERT INTO target VALUES (1), (2);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'update1'), (1, 'update2');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64 PRIMARY KEY, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30), (2, 40);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30);

MERGE INTO prices p
USING new_prices np
ON p.id = np.id
WHEN MATCHED AND np.price > p.price THEN
UPDATE SET p.price = np.price;
SELECT * FROM prices ORDER BY id;
MERGE INTO high_values hv
USING candidates c
ON hv.id = c.id
WHEN NOT MATCHED AND c.value > 100 THEN
INSERT (id, value) VALUES (c.id, c.value);
SELECT id FROM high_values ORDER BY id;
MERGE INTO accounts a
USING transactions t
ON a.id = t.id
WHEN MATCHED AND a.balance + t.amount < 0 THEN
UPDATE SET a.status = 'overdrawn'
WHEN MATCHED THEN
UPDATE SET a.balance = a.balance + t.amount;
SELECT * FROM accounts ORDER BY id;
MERGE INTO summary s
USING (
SELECT category, SUM(amount) as total
FROM transactions
GROUP BY category
) t
ON s.category = t.category
WHEN MATCHED THEN
UPDATE SET s.total = s.total + t.total
WHEN NOT MATCHED THEN
INSERT (category, total) VALUES (t.category, t.total);
SELECT * FROM summary ORDER BY category;
WITH computed AS (
SELECT id, val1 + val2 AS total
FROM raw_data
)
MERGE INTO target t
USING computed c
ON t.id = c.id
WHEN MATCHED THEN
UPDATE SET t.value = c.total
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (c.id, c.total);
SELECT * FROM target ORDER BY id;
MERGE INTO product_details pd
USING (
SELECT p.id, c.name as category_name
FROM products p
JOIN categories c ON p.category_id = c.id
) src
ON pd.id = src.id
WHEN MATCHED THEN
UPDATE SET pd.category_name = src.category_name
WHEN NOT MATCHED THEN
INSERT (id, category_name) VALUES (src.id, src.category_name);
SELECT * FROM product_details;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
SELECT * FROM target WHERE id IS NOT NULL ORDER BY id;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = s.id
WHEN NOT MATCHED BY SOURCE THEN
DELETE;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN NOT MATCHED THEN
INSERT (id) VALUES (s.id);
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value;
MERGE INTO nonexistent t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = s.id;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.nonexistent = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
SELECT value FROM target WHERE id = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value)
RETURNING t.id, t.value;

-- ============================================================================
-- Test: test_merge_conditional_insert
-- Source: merge_statement_comprehensive_tdd.rs:369
-- ============================================================================
DROP TABLE IF EXISTS high_values;
CREATE TABLE high_values (id INT64, value INT64);
DROP TABLE IF EXISTS candidates;
CREATE TABLE candidates (id INT64, value INT64);
INSERT INTO candidates VALUES (1, 50), (2, 150), (3, 250);
DROP TABLE IF EXISTS accounts;
CREATE TABLE accounts (id INT64, balance INT64, status STRING);
INSERT INTO accounts VALUES
(1, 1000, 'active'),
(2, 100, 'active');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64);
INSERT INTO transactions VALUES (1, -1500), (2, 200);
DROP TABLE IF EXISTS summary;
CREATE TABLE summary (category STRING, total INT64);
INSERT INTO summary VALUES ('A', 100), ('B', 200);
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (category STRING, amount INT64);
INSERT INTO transactions VALUES
('A', 10), ('A', 20),
('B', 30),
('C', 40), ('C', 50);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS raw_data;
CREATE TABLE raw_data (id INT64, val1 INT64, val2 INT64);
INSERT INTO raw_data VALUES (1, 5, 10), (2, 15, 20);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category_id INT64);
INSERT INTO products VALUES (1, 'Widget', 1);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING);
INSERT INTO categories VALUES (1, 'Hardware'), (2, 'Software');
DROP TABLE IF EXISTS product_details;
CREATE TABLE product_details (id INT64, category_name STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'one'), (NULL, 'null_target');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'updated'), (NULL, 'null_source');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
INSERT INTO target VALUES (1), (2);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'update1'), (1, 'update2');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64 PRIMARY KEY, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30), (2, 40);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30);

MERGE INTO high_values hv
USING candidates c
ON hv.id = c.id
WHEN NOT MATCHED AND c.value > 100 THEN
INSERT (id, value) VALUES (c.id, c.value);
SELECT id FROM high_values ORDER BY id;
MERGE INTO accounts a
USING transactions t
ON a.id = t.id
WHEN MATCHED AND a.balance + t.amount < 0 THEN
UPDATE SET a.status = 'overdrawn'
WHEN MATCHED THEN
UPDATE SET a.balance = a.balance + t.amount;
SELECT * FROM accounts ORDER BY id;
MERGE INTO summary s
USING (
SELECT category, SUM(amount) as total
FROM transactions
GROUP BY category
) t
ON s.category = t.category
WHEN MATCHED THEN
UPDATE SET s.total = s.total + t.total
WHEN NOT MATCHED THEN
INSERT (category, total) VALUES (t.category, t.total);
SELECT * FROM summary ORDER BY category;
WITH computed AS (
SELECT id, val1 + val2 AS total
FROM raw_data
)
MERGE INTO target t
USING computed c
ON t.id = c.id
WHEN MATCHED THEN
UPDATE SET t.value = c.total
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (c.id, c.total);
SELECT * FROM target ORDER BY id;
MERGE INTO product_details pd
USING (
SELECT p.id, c.name as category_name
FROM products p
JOIN categories c ON p.category_id = c.id
) src
ON pd.id = src.id
WHEN MATCHED THEN
UPDATE SET pd.category_name = src.category_name
WHEN NOT MATCHED THEN
INSERT (id, category_name) VALUES (src.id, src.category_name);
SELECT * FROM product_details;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
SELECT * FROM target WHERE id IS NOT NULL ORDER BY id;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = s.id
WHEN NOT MATCHED BY SOURCE THEN
DELETE;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN NOT MATCHED THEN
INSERT (id) VALUES (s.id);
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value;
MERGE INTO nonexistent t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = s.id;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.nonexistent = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
SELECT value FROM target WHERE id = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value)
RETURNING t.id, t.value;

-- ============================================================================
-- Test: test_merge_multiple_when_matched
-- Source: merge_statement_comprehensive_tdd.rs:420
-- ============================================================================
DROP TABLE IF EXISTS accounts;
CREATE TABLE accounts (id INT64, balance INT64, status STRING);
INSERT INTO accounts VALUES
(1, 1000, 'active'),
(2, 100, 'active');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64);
INSERT INTO transactions VALUES (1, -1500), (2, 200);
DROP TABLE IF EXISTS summary;
CREATE TABLE summary (category STRING, total INT64);
INSERT INTO summary VALUES ('A', 100), ('B', 200);
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (category STRING, amount INT64);
INSERT INTO transactions VALUES
('A', 10), ('A', 20),
('B', 30),
('C', 40), ('C', 50);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS raw_data;
CREATE TABLE raw_data (id INT64, val1 INT64, val2 INT64);
INSERT INTO raw_data VALUES (1, 5, 10), (2, 15, 20);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category_id INT64);
INSERT INTO products VALUES (1, 'Widget', 1);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING);
INSERT INTO categories VALUES (1, 'Hardware'), (2, 'Software');
DROP TABLE IF EXISTS product_details;
CREATE TABLE product_details (id INT64, category_name STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'one'), (NULL, 'null_target');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'updated'), (NULL, 'null_source');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
INSERT INTO target VALUES (1), (2);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'update1'), (1, 'update2');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64 PRIMARY KEY, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30), (2, 40);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30);

MERGE INTO accounts a
USING transactions t
ON a.id = t.id
WHEN MATCHED AND a.balance + t.amount < 0 THEN
UPDATE SET a.status = 'overdrawn'
WHEN MATCHED THEN
UPDATE SET a.balance = a.balance + t.amount;
SELECT * FROM accounts ORDER BY id;
MERGE INTO summary s
USING (
SELECT category, SUM(amount) as total
FROM transactions
GROUP BY category
) t
ON s.category = t.category
WHEN MATCHED THEN
UPDATE SET s.total = s.total + t.total
WHEN NOT MATCHED THEN
INSERT (category, total) VALUES (t.category, t.total);
SELECT * FROM summary ORDER BY category;
WITH computed AS (
SELECT id, val1 + val2 AS total
FROM raw_data
)
MERGE INTO target t
USING computed c
ON t.id = c.id
WHEN MATCHED THEN
UPDATE SET t.value = c.total
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (c.id, c.total);
SELECT * FROM target ORDER BY id;
MERGE INTO product_details pd
USING (
SELECT p.id, c.name as category_name
FROM products p
JOIN categories c ON p.category_id = c.id
) src
ON pd.id = src.id
WHEN MATCHED THEN
UPDATE SET pd.category_name = src.category_name
WHEN NOT MATCHED THEN
INSERT (id, category_name) VALUES (src.id, src.category_name);
SELECT * FROM product_details;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
SELECT * FROM target WHERE id IS NOT NULL ORDER BY id;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = s.id
WHEN NOT MATCHED BY SOURCE THEN
DELETE;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN NOT MATCHED THEN
INSERT (id) VALUES (s.id);
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value;
MERGE INTO nonexistent t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = s.id;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.id = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.nonexistent = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
SELECT value FROM target WHERE id = 1;
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value);
MERGE INTO target t
USING source s
ON t.id = s.id
WHEN MATCHED THEN
UPDATE SET t.value = s.value
WHEN NOT MATCHED THEN
INSERT (id, value) VALUES (s.id, s.value)
RETURNING t.id, t.value;

-- ============================================================================
-- Test: test_create_table_if_not_exists_new_table
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:45
-- ============================================================================
CREATE TABLE IF NOT EXISTS test (id INT64, name STRING);
INSERT INTO test VALUES (1, 'Alice');
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 100);
CREATE TABLE IF NOT EXISTS test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
CREATE TABLE IF NOT EXISTS test (x FLOAT64, y FLOAT64);
INSERT INTO test (id, name) VALUES (1, 'Alice');
CREATE TABLE IF NOT EXISTS test (id INT64);
CREATE TABLE IF NOT EXISTS users ( id INT64, email STRING, CONSTRAINT pk_users PRIMARY KEY (id) );
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2), (3);
CREATE TABLE IF NOT EXISTS test (id INT64);
INSERT INTO test VALUES (1);
CREATE TABLE IF NOT EXISTS test (id INT64, name STRING);
INSERT INTO test VALUES (2, 'Bob');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, name STRING);
INSERT INTO source VALUES (1, 'Alice'), (2, 'Bob');
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 50), (3, 200);
CREATE TABLE filtered AS SELECT * FROM source WHERE value > 75;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (5), (10), (15);
CREATE TABLE computed AS SELECT value, value * 2 AS doubled FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('B', 50);
CREATE TABLE summary AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, score INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO scores VALUES (1, 95), (2, 87);
CREATE TABLE results AS SELECT u.name, s.score FROM users u JOIN scores s ON u.user_id = s.user_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100);
CREATE TABLE empty AS SELECT * FROM source WHERE id > 1000;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, 200);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest ORDER BY id;
SELECT doubled FROM computed ORDER BY doubled;
SELECT value FROM dest WHERE id = 1;
SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_create_table_if_not_exists_existing_table
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:68
-- ============================================================================
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, value INT64);
INSERT INTO test VALUES (1, 100);
CREATE TABLE IF NOT EXISTS test (id INT64, value INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
CREATE TABLE IF NOT EXISTS test (x FLOAT64, y FLOAT64);
INSERT INTO test (id, name) VALUES (1, 'Alice');
CREATE TABLE IF NOT EXISTS test (id INT64);
CREATE TABLE IF NOT EXISTS users ( id INT64, email STRING, CONSTRAINT pk_users PRIMARY KEY (id) );
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2), (3);
CREATE TABLE IF NOT EXISTS test (id INT64);
INSERT INTO test VALUES (1);
CREATE TABLE IF NOT EXISTS test (id INT64, name STRING);
INSERT INTO test VALUES (2, 'Bob');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, name STRING);
INSERT INTO source VALUES (1, 'Alice'), (2, 'Bob');
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 50), (3, 200);
CREATE TABLE filtered AS SELECT * FROM source WHERE value > 75;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (5), (10), (15);
CREATE TABLE computed AS SELECT value, value * 2 AS doubled FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('B', 50);
CREATE TABLE summary AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, score INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO scores VALUES (1, 95), (2, 87);
CREATE TABLE results AS SELECT u.name, s.score FROM users u JOIN scores s ON u.user_id = s.user_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100);
CREATE TABLE empty AS SELECT * FROM source WHERE id > 1000;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, 200);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest ORDER BY id;
SELECT doubled FROM computed ORDER BY doubled;
SELECT value FROM dest WHERE id = 1;
SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_create_table_if_not_exists_different_schema
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:91
-- ============================================================================
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64, name STRING);
CREATE TABLE IF NOT EXISTS test (x FLOAT64, y FLOAT64);
INSERT INTO test (id, name) VALUES (1, 'Alice');
CREATE TABLE IF NOT EXISTS test (id INT64);
CREATE TABLE IF NOT EXISTS users ( id INT64, email STRING, CONSTRAINT pk_users PRIMARY KEY (id) );
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2), (3);
CREATE TABLE IF NOT EXISTS test (id INT64);
INSERT INTO test VALUES (1);
CREATE TABLE IF NOT EXISTS test (id INT64, name STRING);
INSERT INTO test VALUES (2, 'Bob');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, name STRING);
INSERT INTO source VALUES (1, 'Alice'), (2, 'Bob');
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 50), (3, 200);
CREATE TABLE filtered AS SELECT * FROM source WHERE value > 75;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (5), (10), (15);
CREATE TABLE computed AS SELECT value, value * 2 AS doubled FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('B', 50);
CREATE TABLE summary AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, score INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO scores VALUES (1, 95), (2, 87);
CREATE TABLE results AS SELECT u.name, s.score FROM users u JOIN scores s ON u.user_id = s.user_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100);
CREATE TABLE empty AS SELECT * FROM source WHERE id > 1000;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, 200);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest ORDER BY id;
SELECT doubled FROM computed ORDER BY doubled;
SELECT value FROM dest WHERE id = 1;
SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_create_table_if_not_exists_multiple_times
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:113
-- ============================================================================
CREATE TABLE IF NOT EXISTS test (id INT64);
CREATE TABLE IF NOT EXISTS users ( id INT64, email STRING, CONSTRAINT pk_users PRIMARY KEY (id) );
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2), (3);
CREATE TABLE IF NOT EXISTS test (id INT64);
INSERT INTO test VALUES (1);
CREATE TABLE IF NOT EXISTS test (id INT64, name STRING);
INSERT INTO test VALUES (2, 'Bob');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, name STRING);
INSERT INTO source VALUES (1, 'Alice'), (2, 'Bob');
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 50), (3, 200);
CREATE TABLE filtered AS SELECT * FROM source WHERE value > 75;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (5), (10), (15);
CREATE TABLE computed AS SELECT value, value * 2 AS doubled FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('B', 50);
CREATE TABLE summary AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, score INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO scores VALUES (1, 95), (2, 87);
CREATE TABLE results AS SELECT u.name, s.score FROM users u JOIN scores s ON u.user_id = s.user_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100);
CREATE TABLE empty AS SELECT * FROM source WHERE id > 1000;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, 200);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest ORDER BY id;
SELECT doubled FROM computed ORDER BY doubled;
SELECT value FROM dest WHERE id = 1;
SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_create_table_if_not_exists_with_constraints
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:127
-- ============================================================================
CREATE TABLE IF NOT EXISTS users ( id INT64, email STRING, CONSTRAINT pk_users PRIMARY KEY (id) );
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2), (3);
CREATE TABLE IF NOT EXISTS test (id INT64);
INSERT INTO test VALUES (1);
CREATE TABLE IF NOT EXISTS test (id INT64, name STRING);
INSERT INTO test VALUES (2, 'Bob');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, name STRING);
INSERT INTO source VALUES (1, 'Alice'), (2, 'Bob');
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 50), (3, 200);
CREATE TABLE filtered AS SELECT * FROM source WHERE value > 75;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (5), (10), (15);
CREATE TABLE computed AS SELECT value, value * 2 AS doubled FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('B', 50);
CREATE TABLE summary AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, score INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO scores VALUES (1, 95), (2, 87);
CREATE TABLE results AS SELECT u.name, s.score FROM users u JOIN scores s ON u.user_id = s.user_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100);
CREATE TABLE empty AS SELECT * FROM source WHERE id > 1000;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, 200);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest ORDER BY id;
SELECT doubled FROM computed ORDER BY doubled;
SELECT value FROM dest WHERE id = 1;
SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_drop_table_if_exists_existing_table
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:153
-- ============================================================================
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2), (3);
CREATE TABLE IF NOT EXISTS test (id INT64);
INSERT INTO test VALUES (1);
CREATE TABLE IF NOT EXISTS test (id INT64, name STRING);
INSERT INTO test VALUES (2, 'Bob');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, name STRING);
INSERT INTO source VALUES (1, 'Alice'), (2, 'Bob');
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 50), (3, 200);
CREATE TABLE filtered AS SELECT * FROM source WHERE value > 75;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (5), (10), (15);
CREATE TABLE computed AS SELECT value, value * 2 AS doubled FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('B', 50);
CREATE TABLE summary AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, score INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO scores VALUES (1, 95), (2, 87);
CREATE TABLE results AS SELECT u.name, s.score FROM users u JOIN scores s ON u.user_id = s.user_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100);
CREATE TABLE empty AS SELECT * FROM source WHERE id > 1000;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, 200);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest ORDER BY id;
SELECT doubled FROM computed ORDER BY doubled;
SELECT value FROM dest WHERE id = 1;
SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_drop_table_if_exists_nonexistent_table
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:172
-- ============================================================================
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2), (3);
CREATE TABLE IF NOT EXISTS test (id INT64);
INSERT INTO test VALUES (1);
CREATE TABLE IF NOT EXISTS test (id INT64, name STRING);
INSERT INTO test VALUES (2, 'Bob');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, name STRING);
INSERT INTO source VALUES (1, 'Alice'), (2, 'Bob');
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 50), (3, 200);
CREATE TABLE filtered AS SELECT * FROM source WHERE value > 75;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (5), (10), (15);
CREATE TABLE computed AS SELECT value, value * 2 AS doubled FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('B', 50);
CREATE TABLE summary AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, score INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO scores VALUES (1, 95), (2, 87);
CREATE TABLE results AS SELECT u.name, s.score FROM users u JOIN scores s ON u.user_id = s.user_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100);
CREATE TABLE empty AS SELECT * FROM source WHERE id > 1000;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, 200);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest ORDER BY id;
SELECT doubled FROM computed ORDER BY doubled;
SELECT value FROM dest WHERE id = 1;
SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_drop_table_if_exists_multiple_times
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:183
-- ============================================================================
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2), (3);
CREATE TABLE IF NOT EXISTS test (id INT64);
INSERT INTO test VALUES (1);
CREATE TABLE IF NOT EXISTS test (id INT64, name STRING);
INSERT INTO test VALUES (2, 'Bob');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, name STRING);
INSERT INTO source VALUES (1, 'Alice'), (2, 'Bob');
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 50), (3, 200);
CREATE TABLE filtered AS SELECT * FROM source WHERE value > 75;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (5), (10), (15);
CREATE TABLE computed AS SELECT value, value * 2 AS doubled FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('B', 50);
CREATE TABLE summary AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, score INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO scores VALUES (1, 95), (2, 87);
CREATE TABLE results AS SELECT u.name, s.score FROM users u JOIN scores s ON u.user_id = s.user_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100);
CREATE TABLE empty AS SELECT * FROM source WHERE id > 1000;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, 200);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest ORDER BY id;
SELECT doubled FROM computed ORDER BY doubled;
SELECT value FROM dest WHERE id = 1;
SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_drop_table_if_exists_with_data
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:200
-- ============================================================================
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2), (3);
CREATE TABLE IF NOT EXISTS test (id INT64);
INSERT INTO test VALUES (1);
CREATE TABLE IF NOT EXISTS test (id INT64, name STRING);
INSERT INTO test VALUES (2, 'Bob');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, name STRING);
INSERT INTO source VALUES (1, 'Alice'), (2, 'Bob');
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 50), (3, 200);
CREATE TABLE filtered AS SELECT * FROM source WHERE value > 75;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (5), (10), (15);
CREATE TABLE computed AS SELECT value, value * 2 AS doubled FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('B', 50);
CREATE TABLE summary AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, score INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO scores VALUES (1, 95), (2, 87);
CREATE TABLE results AS SELECT u.name, s.score FROM users u JOIN scores s ON u.user_id = s.user_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100);
CREATE TABLE empty AS SELECT * FROM source WHERE id > 1000;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, 200);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest ORDER BY id;
SELECT doubled FROM computed ORDER BY doubled;
SELECT value FROM dest WHERE id = 1;
SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_create_drop_create_cycle
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:217
-- ============================================================================
CREATE TABLE IF NOT EXISTS test (id INT64);
INSERT INTO test VALUES (1);
CREATE TABLE IF NOT EXISTS test (id INT64, name STRING);
INSERT INTO test VALUES (2, 'Bob');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, name STRING);
INSERT INTO source VALUES (1, 'Alice'), (2, 'Bob');
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 50), (3, 200);
CREATE TABLE filtered AS SELECT * FROM source WHERE value > 75;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (5), (10), (15);
CREATE TABLE computed AS SELECT value, value * 2 AS doubled FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('B', 50);
CREATE TABLE summary AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, score INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO scores VALUES (1, 95), (2, 87);
CREATE TABLE results AS SELECT u.name, s.score FROM users u JOIN scores s ON u.user_id = s.user_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100);
CREATE TABLE empty AS SELECT * FROM source WHERE id > 1000;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, 200);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest ORDER BY id;
SELECT doubled FROM computed ORDER BY doubled;
SELECT value FROM dest WHERE id = 1;
SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_basic
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:249
-- ============================================================================
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, name STRING);
INSERT INTO source VALUES (1, 'Alice'), (2, 'Bob');
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 50), (3, 200);
CREATE TABLE filtered AS SELECT * FROM source WHERE value > 75;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (5), (10), (15);
CREATE TABLE computed AS SELECT value, value * 2 AS doubled FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('B', 50);
CREATE TABLE summary AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, score INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO scores VALUES (1, 95), (2, 87);
CREATE TABLE results AS SELECT u.name, s.score FROM users u JOIN scores s ON u.user_id = s.user_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100);
CREATE TABLE empty AS SELECT * FROM source WHERE id > 1000;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, 200);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest ORDER BY id;
SELECT doubled FROM computed ORDER BY doubled;
SELECT value FROM dest WHERE id = 1;
SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_where_clause
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:277
-- ============================================================================
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 50), (3, 200);
CREATE TABLE filtered AS SELECT * FROM source WHERE value > 75;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (5), (10), (15);
CREATE TABLE computed AS SELECT value, value * 2 AS doubled FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('B', 50);
CREATE TABLE summary AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, score INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO scores VALUES (1, 95), (2, 87);
CREATE TABLE results AS SELECT u.name, s.score FROM users u JOIN scores s ON u.user_id = s.user_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100);
CREATE TABLE empty AS SELECT * FROM source WHERE id > 1000;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, 200);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT doubled FROM computed ORDER BY doubled;
SELECT value FROM dest WHERE id = 1;
SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_computed_columns
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:297
-- ============================================================================
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (5), (10), (15);
CREATE TABLE computed AS SELECT value, value * 2 AS doubled FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('B', 50);
CREATE TABLE summary AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, score INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO scores VALUES (1, 95), (2, 87);
CREATE TABLE results AS SELECT u.name, s.score FROM users u JOIN scores s ON u.user_id = s.user_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100);
CREATE TABLE empty AS SELECT * FROM source WHERE id > 1000;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, 200);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT doubled FROM computed ORDER BY doubled;
SELECT value FROM dest WHERE id = 1;
SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_aggregation
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:324
-- ============================================================================
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('B', 200), ('A', 150), ('B', 50);
CREATE TABLE summary AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, score INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO scores VALUES (1, 95), (2, 87);
CREATE TABLE results AS SELECT u.name, s.score FROM users u JOIN scores s ON u.user_id = s.user_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100);
CREATE TABLE empty AS SELECT * FROM source WHERE id > 1000;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, 200);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT value FROM dest WHERE id = 1;
SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_join
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:344
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, score INT64);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO scores VALUES (1, 95), (2, 87);
CREATE TABLE results AS SELECT u.name, s.score FROM users u JOIN scores s ON u.user_id = s.user_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100);
CREATE TABLE empty AS SELECT * FROM source WHERE id > 1000;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, 200);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT value FROM dest WHERE id = 1;
SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_empty_result
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:371
-- ============================================================================
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100);
CREATE TABLE empty AS SELECT * FROM source WHERE id > 1000;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, 200);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT value FROM dest WHERE id = 1;
SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_null_values
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:397
-- ============================================================================
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, 200);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT value FROM dest WHERE id = 1;
SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_type_coercion
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:420
-- ============================================================================
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (42);
CREATE TABLE dest AS SELECT CAST(value AS FLOAT64) AS float_val FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT float_val FROM dest;
SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_order_by
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:447
-- ============================================================================
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (30), (10), (20);
CREATE TABLE ordered AS SELECT * FROM source ORDER BY value;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_limit
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:467
-- ============================================================================
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE limited AS SELECT * FROM source LIMIT 2;
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_distinct
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:487
-- ============================================================================
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (1), (2), (2), (3), (3), (3);
CREATE TABLE unique_vals AS SELECT DISTINCT value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_if_not_exists_new_table
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:511
-- ============================================================================
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_if_not_exists_existing_table
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:531
-- ============================================================================
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64, extra STRING);
INSERT INTO dest VALUES (99, 'original');
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT id FROM dest;
SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_create_table_without_if_not_exists_duplicate_should_error
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:567
-- ============================================================================
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_drop_table_without_if_exists_nonexistent_should_error
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:580
-- ============================================================================
DROP TABLE nonexistent;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_duplicate_table_should_error
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:589
-- ============================================================================
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS dest;
CREATE TABLE dest (id INT64);
CREATE TABLE dest AS SELECT * FROM source;
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_from_nonexistent_table_should_error
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:608
-- ============================================================================
CREATE TABLE dest AS SELECT * FROM nonexistent;
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_etl_workflow_with_staging_tables
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:621
-- ============================================================================
CREATE TABLE IF NOT EXISTS staging ( event_id INT64, event_type STRING, value INT64 );
INSERT INTO staging VALUES
(1, 'purchase', 100),
(2, 'refund', -50),
(3, 'purchase', 200);
CREATE TABLE processed AS SELECT event_id, UPPER(event_type) AS category, value FROM staging WHERE event_type = 'purchase' AND value > 0;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_snapshot_table_pattern
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:667
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, active BOOL);
INSERT INTO users VALUES (1, 'Alice', true), (2, 'Bob', false);
CREATE TABLE IF NOT EXISTS users_snapshot AS SELECT * FROM users;
INSERT INTO users VALUES (3, 'Carol', true);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_data_mart_creation
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:699
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders ( order_id INT64, customer_id INT64, amount FLOAT64 );
INSERT INTO orders VALUES
(1, 101, 50.0),
(2, 102, 75.0),
(3, 101, 100.0);
CREATE TABLE customer_summary AS SELECT customer_id, COUNT(*) AS order_count, SUM(amount) AS total_spent FROM orders GROUP BY customer_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_temporary_working_table_pattern
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:739
-- ============================================================================
DROP TABLE IF EXISTS data;
CREATE TABLE data (value INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE working AS SELECT * FROM data WHERE value > 2;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_case_expression
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:776
-- ============================================================================
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 75), ('Carol', 55);
CREATE TABLE graded AS SELECT student, CASE WHEN score >= 90 THEN 'A' WHEN score >= 70 THEN 'B' ELSE 'C' END AS grade FROM scores;
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_string_functions
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:805
-- ============================================================================
DROP TABLE IF EXISTS names;
CREATE TABLE names (first STRING, last STRING);
INSERT INTO names VALUES ('John', 'Doe'), ('Jane', 'Smith');
CREATE TABLE full_names AS SELECT CONCAT(first, ' ', last) AS name, UPPER(last) AS upper_last FROM names;
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_cte
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:830
-- ============================================================================
DROP TABLE IF EXISTS values;
CREATE TABLE values (x INT64);
INSERT INTO values VALUES (1), (2), (3);
CREATE TABLE doubled AS WITH temp AS (SELECT x * 2 AS doubled_value FROM values) SELECT doubled_value FROM temp;
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_union
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:854
-- ============================================================================
DROP TABLE IF EXISTS table1;
CREATE TABLE table1 (id INT64);
DROP TABLE IF EXISTS table2;
CREATE TABLE table2 (id INT64);
INSERT INTO table1 VALUES (1), (2);
INSERT INTO table2 VALUES (3), (4);
CREATE TABLE combined AS SELECT id FROM table1 UNION SELECT id FROM table2;
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_all_data_types
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:884
-- ============================================================================
DROP TABLE IF EXISTS source;
CREATE TABLE source ( i INT64, f FLOAT64, s STRING, b BOOL );
INSERT INTO source VALUES (42, 3.14, 'test', true);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM dest;
SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_table_already_exists_error
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:917
-- ============================================================================
DROP TABLE IF EXISTS existing;
CREATE TABLE existing (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (value INT64);
INSERT INTO source VALUES (100);
CREATE TABLE existing AS SELECT * FROM source;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_from_cte
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:946
-- ============================================================================
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5);
CREATE TABLE even_numbers AS WITH filtered AS ( SELECT n FROM numbers WHERE n % 2 = 0 ) SELECT n FROM filtered;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_from_subquery
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:976
-- ============================================================================
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary INT64);
INSERT INTO employees VALUES (1, 50000), (2, 75000), (3, 60000);
CREATE TABLE high_earners AS SELECT id, salary, (SELECT AVG(salary) FROM employees) AS avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_window_functions
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:1006
-- ============================================================================
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (region STRING, amount INT64);
INSERT INTO sales VALUES
('East', 100), ('East', 150), ('West', 200), ('West', 120);
CREATE TABLE sales_with_rank AS SELECT region, amount, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rank FROM sales;
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES
(1, 'Alice', NULL),
(2, 'Bob', 1),
(3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES
('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES
('A', 10.5), ('A', 12.3), ('A', 11.1),
('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES
(1, 10.0), (1, 20.0), (1, 30.0),
(2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES
('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT * FROM sales_with_rank ORDER BY region, rank;
SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_update_with_inner_join
-- Source: update_enhancements_advanced_tdd.rs:30
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, discount FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0), (3, 300.0);
INSERT INTO discounts VALUES (1, 0.1), (2, 0.2);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 0.0), (2, 60000.0, 0.0);
INSERT INTO bonuses VALUES (1, 5000.0);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING);
DROP TABLE IF EXISTS tier_discounts;
CREATE TABLE tier_discounts (tier STRING, discount FLOAT64);
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0);
INSERT INTO customers VALUES (1, 'Gold'), (2, 'Silver');
INSERT INTO tier_discounts VALUES ('Gold', 0.2), ('Silver', 0.1);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, manager_id INT64, level INT64);
INSERT INTO employees VALUES (1, NULL, 1), (2, 1, 0), (3, 1, 0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, discount FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries_history;
CREATE TABLE salaries_history (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0), (2, 60000.0);
INSERT INTO salaries_history VALUES (1, 55000.0), (1, 58000.0), (2, 65000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0), (3, 300.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary FLOAT64);
INSERT INTO employees VALUES (1, 'Alice', 50000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, rate FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO discounts VALUES (1, 0.1);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, dept_avg FLOAT64);
DROP TABLE IF EXISTS dept_salaries;
CREATE TABLE dept_salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 0.0), (2, 60000.0, 0.0);
INSERT INTO dept_salaries VALUES (1, 50000.0), (1, 55000.0), (2, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64, max_price FLOAT64);
DROP TABLE IF EXISTS price_history;
CREATE TABLE price_history (product_id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0, 0.0), (2, 200.0, 0.0);
INSERT INTO price_history VALUES (1, 120.0), (1, 150.0), (2, 250.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, bonus FLOAT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 0.0), (2, 0.0);
INSERT INTO bonuses VALUES (1, 1000.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries;
CREATE TABLE salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0);
INSERT INTO salaries VALUES (1, 55000.0), (1, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (product_id INT64, quantity INT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO inventory VALUES (1, 10), (2, 5);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE products p
SET price = price * (1.0 - d.discount)
FROM discounts d
WHERE p.id = d.product_id;
SELECT id, price FROM products ORDER BY id;
UPDATE employees e
SET bonus = COALESCE(b.amount, 0.0)
FROM bonuses b
LEFT JOIN employees ON e.id = b.emp_id;
SELECT id, bonus FROM employees ORDER BY id;
UPDATE orders o
SET total = total * (1.0 - t.discount)
FROM customers c
JOIN tier_discounts t ON c.tier = t.tier
WHERE o.customer_id = c.id;
SELECT id, total FROM orders ORDER BY id;
UPDATE employees e
SET level = m.level + 1
FROM employees m
WHERE e.manager_id = m.id;
SELECT id, level FROM employees ORDER BY id;
UPDATE products p
SET price = price * 0.9
FROM discounts d
WHERE p.id = d.product_id;
SELECT price FROM products ORDER BY id;
UPDATE employees e
SET salary = max_sal.amount
FROM (
SELECT emp_id, MAX(amount) as amount
FROM salaries_history
GROUP BY emp_id
) max_sal
WHERE e.id = max_sal.emp_id;
SELECT id, salary FROM employees ORDER BY id;
WITH avg_price AS (
SELECT AVG(price) as avg FROM products
)
UPDATE products
SET price = price * 1.1
FROM avg_price
WHERE price < avg_price.avg;
SELECT id, price FROM products ORDER BY id;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING *;
UPDATE employees SET salary = 55000.0 WHERE id = 1 RETURNING id, salary;
UPDATE products
SET price = price * 1.2
RETURNING id, price as new_price, price / 1.2 as old_price;
UPDATE products SET price = 200.0 WHERE id = 999 RETURNING *;
UPDATE products p
SET price = price * (1.0 - d.rate)
FROM discounts d
WHERE p.id = d.product_id
RETURNING p.id, p.price, d.rate;
UPDATE employees e
SET dept_avg = (
SELECT AVG(amount)
FROM dept_salaries
WHERE emp_id = e.id
);
SELECT id, dept_avg FROM employees ORDER BY id;
UPDATE products p
SET max_price = (
SELECT MAX(price)
FROM price_history h
WHERE h.product_id = p.id
);
SELECT id, max_price FROM products ORDER BY id;
UPDATE employees e
SET bonus = (
SELECT amount FROM bonuses WHERE emp_id = e.id
);
SELECT id, bonus FROM employees ORDER BY id;
UPDATE employees e
SET salary = (
SELECT amount FROM salaries WHERE emp_id = e.id
);
UPDATE products p, inventory i
SET p.price = p.price * 1.1,
i.quantity = i.quantity - 1
WHERE p.id = i.product_id AND i.quantity > 5;
SELECT price FROM products WHERE id = 1;
SELECT quantity FROM inventory WHERE product_id = 1;
UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_with_left_join
-- Source: update_enhancements_advanced_tdd.rs:62
-- ============================================================================
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 0.0), (2, 60000.0, 0.0);
INSERT INTO bonuses VALUES (1, 5000.0);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING);
DROP TABLE IF EXISTS tier_discounts;
CREATE TABLE tier_discounts (tier STRING, discount FLOAT64);
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0);
INSERT INTO customers VALUES (1, 'Gold'), (2, 'Silver');
INSERT INTO tier_discounts VALUES ('Gold', 0.2), ('Silver', 0.1);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, manager_id INT64, level INT64);
INSERT INTO employees VALUES (1, NULL, 1), (2, 1, 0), (3, 1, 0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, discount FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries_history;
CREATE TABLE salaries_history (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0), (2, 60000.0);
INSERT INTO salaries_history VALUES (1, 55000.0), (1, 58000.0), (2, 65000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0), (3, 300.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary FLOAT64);
INSERT INTO employees VALUES (1, 'Alice', 50000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, rate FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO discounts VALUES (1, 0.1);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, dept_avg FLOAT64);
DROP TABLE IF EXISTS dept_salaries;
CREATE TABLE dept_salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 0.0), (2, 60000.0, 0.0);
INSERT INTO dept_salaries VALUES (1, 50000.0), (1, 55000.0), (2, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64, max_price FLOAT64);
DROP TABLE IF EXISTS price_history;
CREATE TABLE price_history (product_id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0, 0.0), (2, 200.0, 0.0);
INSERT INTO price_history VALUES (1, 120.0), (1, 150.0), (2, 250.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, bonus FLOAT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 0.0), (2, 0.0);
INSERT INTO bonuses VALUES (1, 1000.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries;
CREATE TABLE salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0);
INSERT INTO salaries VALUES (1, 55000.0), (1, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (product_id INT64, quantity INT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO inventory VALUES (1, 10), (2, 5);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE employees e
SET bonus = COALESCE(b.amount, 0.0)
FROM bonuses b
LEFT JOIN employees ON e.id = b.emp_id;
SELECT id, bonus FROM employees ORDER BY id;
UPDATE orders o
SET total = total * (1.0 - t.discount)
FROM customers c
JOIN tier_discounts t ON c.tier = t.tier
WHERE o.customer_id = c.id;
SELECT id, total FROM orders ORDER BY id;
UPDATE employees e
SET level = m.level + 1
FROM employees m
WHERE e.manager_id = m.id;
SELECT id, level FROM employees ORDER BY id;
UPDATE products p
SET price = price * 0.9
FROM discounts d
WHERE p.id = d.product_id;
SELECT price FROM products ORDER BY id;
UPDATE employees e
SET salary = max_sal.amount
FROM (
SELECT emp_id, MAX(amount) as amount
FROM salaries_history
GROUP BY emp_id
) max_sal
WHERE e.id = max_sal.emp_id;
SELECT id, salary FROM employees ORDER BY id;
WITH avg_price AS (
SELECT AVG(price) as avg FROM products
)
UPDATE products
SET price = price * 1.1
FROM avg_price
WHERE price < avg_price.avg;
SELECT id, price FROM products ORDER BY id;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING *;
UPDATE employees SET salary = 55000.0 WHERE id = 1 RETURNING id, salary;
UPDATE products
SET price = price * 1.2
RETURNING id, price as new_price, price / 1.2 as old_price;
UPDATE products SET price = 200.0 WHERE id = 999 RETURNING *;
UPDATE products p
SET price = price * (1.0 - d.rate)
FROM discounts d
WHERE p.id = d.product_id
RETURNING p.id, p.price, d.rate;
UPDATE employees e
SET dept_avg = (
SELECT AVG(amount)
FROM dept_salaries
WHERE emp_id = e.id
);
SELECT id, dept_avg FROM employees ORDER BY id;
UPDATE products p
SET max_price = (
SELECT MAX(price)
FROM price_history h
WHERE h.product_id = p.id
);
SELECT id, max_price FROM products ORDER BY id;
UPDATE employees e
SET bonus = (
SELECT amount FROM bonuses WHERE emp_id = e.id
);
SELECT id, bonus FROM employees ORDER BY id;
UPDATE employees e
SET salary = (
SELECT amount FROM salaries WHERE emp_id = e.id
);
UPDATE products p, inventory i
SET p.price = p.price * 1.1,
i.quantity = i.quantity - 1
WHERE p.id = i.product_id AND i.quantity > 5;
SELECT price FROM products WHERE id = 1;
SELECT quantity FROM inventory WHERE product_id = 1;
UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_with_multiple_joins
-- Source: update_enhancements_advanced_tdd.rs:92
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING);
DROP TABLE IF EXISTS tier_discounts;
CREATE TABLE tier_discounts (tier STRING, discount FLOAT64);
INSERT INTO orders VALUES (1, 1, 100.0), (2, 2, 200.0);
INSERT INTO customers VALUES (1, 'Gold'), (2, 'Silver');
INSERT INTO tier_discounts VALUES ('Gold', 0.2), ('Silver', 0.1);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, manager_id INT64, level INT64);
INSERT INTO employees VALUES (1, NULL, 1), (2, 1, 0), (3, 1, 0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, discount FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries_history;
CREATE TABLE salaries_history (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0), (2, 60000.0);
INSERT INTO salaries_history VALUES (1, 55000.0), (1, 58000.0), (2, 65000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0), (3, 300.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary FLOAT64);
INSERT INTO employees VALUES (1, 'Alice', 50000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, rate FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO discounts VALUES (1, 0.1);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, dept_avg FLOAT64);
DROP TABLE IF EXISTS dept_salaries;
CREATE TABLE dept_salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 0.0), (2, 60000.0, 0.0);
INSERT INTO dept_salaries VALUES (1, 50000.0), (1, 55000.0), (2, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64, max_price FLOAT64);
DROP TABLE IF EXISTS price_history;
CREATE TABLE price_history (product_id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0, 0.0), (2, 200.0, 0.0);
INSERT INTO price_history VALUES (1, 120.0), (1, 150.0), (2, 250.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, bonus FLOAT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 0.0), (2, 0.0);
INSERT INTO bonuses VALUES (1, 1000.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries;
CREATE TABLE salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0);
INSERT INTO salaries VALUES (1, 55000.0), (1, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (product_id INT64, quantity INT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO inventory VALUES (1, 10), (2, 5);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE orders o
SET total = total * (1.0 - t.discount)
FROM customers c
JOIN tier_discounts t ON c.tier = t.tier
WHERE o.customer_id = c.id;
SELECT id, total FROM orders ORDER BY id;
UPDATE employees e
SET level = m.level + 1
FROM employees m
WHERE e.manager_id = m.id;
SELECT id, level FROM employees ORDER BY id;
UPDATE products p
SET price = price * 0.9
FROM discounts d
WHERE p.id = d.product_id;
SELECT price FROM products ORDER BY id;
UPDATE employees e
SET salary = max_sal.amount
FROM (
SELECT emp_id, MAX(amount) as amount
FROM salaries_history
GROUP BY emp_id
) max_sal
WHERE e.id = max_sal.emp_id;
SELECT id, salary FROM employees ORDER BY id;
WITH avg_price AS (
SELECT AVG(price) as avg FROM products
)
UPDATE products
SET price = price * 1.1
FROM avg_price
WHERE price < avg_price.avg;
SELECT id, price FROM products ORDER BY id;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING *;
UPDATE employees SET salary = 55000.0 WHERE id = 1 RETURNING id, salary;
UPDATE products
SET price = price * 1.2
RETURNING id, price as new_price, price / 1.2 as old_price;
UPDATE products SET price = 200.0 WHERE id = 999 RETURNING *;
UPDATE products p
SET price = price * (1.0 - d.rate)
FROM discounts d
WHERE p.id = d.product_id
RETURNING p.id, p.price, d.rate;
UPDATE employees e
SET dept_avg = (
SELECT AVG(amount)
FROM dept_salaries
WHERE emp_id = e.id
);
SELECT id, dept_avg FROM employees ORDER BY id;
UPDATE products p
SET max_price = (
SELECT MAX(price)
FROM price_history h
WHERE h.product_id = p.id
);
SELECT id, max_price FROM products ORDER BY id;
UPDATE employees e
SET bonus = (
SELECT amount FROM bonuses WHERE emp_id = e.id
);
SELECT id, bonus FROM employees ORDER BY id;
UPDATE employees e
SET salary = (
SELECT amount FROM salaries WHERE emp_id = e.id
);
UPDATE products p, inventory i
SET p.price = p.price * 1.1,
i.quantity = i.quantity - 1
WHERE p.id = i.product_id AND i.quantity > 5;
SELECT price FROM products WHERE id = 1;
SELECT quantity FROM inventory WHERE product_id = 1;
UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_with_self_join
-- Source: update_enhancements_advanced_tdd.rs:125
-- ============================================================================
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, manager_id INT64, level INT64);
INSERT INTO employees VALUES (1, NULL, 1), (2, 1, 0), (3, 1, 0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, discount FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries_history;
CREATE TABLE salaries_history (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0), (2, 60000.0);
INSERT INTO salaries_history VALUES (1, 55000.0), (1, 58000.0), (2, 65000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0), (3, 300.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary FLOAT64);
INSERT INTO employees VALUES (1, 'Alice', 50000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, rate FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO discounts VALUES (1, 0.1);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, dept_avg FLOAT64);
DROP TABLE IF EXISTS dept_salaries;
CREATE TABLE dept_salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 0.0), (2, 60000.0, 0.0);
INSERT INTO dept_salaries VALUES (1, 50000.0), (1, 55000.0), (2, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64, max_price FLOAT64);
DROP TABLE IF EXISTS price_history;
CREATE TABLE price_history (product_id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0, 0.0), (2, 200.0, 0.0);
INSERT INTO price_history VALUES (1, 120.0), (1, 150.0), (2, 250.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, bonus FLOAT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 0.0), (2, 0.0);
INSERT INTO bonuses VALUES (1, 1000.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries;
CREATE TABLE salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0);
INSERT INTO salaries VALUES (1, 55000.0), (1, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (product_id INT64, quantity INT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO inventory VALUES (1, 10), (2, 5);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE employees e
SET level = m.level + 1
FROM employees m
WHERE e.manager_id = m.id;
SELECT id, level FROM employees ORDER BY id;
UPDATE products p
SET price = price * 0.9
FROM discounts d
WHERE p.id = d.product_id;
SELECT price FROM products ORDER BY id;
UPDATE employees e
SET salary = max_sal.amount
FROM (
SELECT emp_id, MAX(amount) as amount
FROM salaries_history
GROUP BY emp_id
) max_sal
WHERE e.id = max_sal.emp_id;
SELECT id, salary FROM employees ORDER BY id;
WITH avg_price AS (
SELECT AVG(price) as avg FROM products
)
UPDATE products
SET price = price * 1.1
FROM avg_price
WHERE price < avg_price.avg;
SELECT id, price FROM products ORDER BY id;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING *;
UPDATE employees SET salary = 55000.0 WHERE id = 1 RETURNING id, salary;
UPDATE products
SET price = price * 1.2
RETURNING id, price as new_price, price / 1.2 as old_price;
UPDATE products SET price = 200.0 WHERE id = 999 RETURNING *;
UPDATE products p
SET price = price * (1.0 - d.rate)
FROM discounts d
WHERE p.id = d.product_id
RETURNING p.id, p.price, d.rate;
UPDATE employees e
SET dept_avg = (
SELECT AVG(amount)
FROM dept_salaries
WHERE emp_id = e.id
);
SELECT id, dept_avg FROM employees ORDER BY id;
UPDATE products p
SET max_price = (
SELECT MAX(price)
FROM price_history h
WHERE h.product_id = p.id
);
SELECT id, max_price FROM products ORDER BY id;
UPDATE employees e
SET bonus = (
SELECT amount FROM bonuses WHERE emp_id = e.id
);
SELECT id, bonus FROM employees ORDER BY id;
UPDATE employees e
SET salary = (
SELECT amount FROM salaries WHERE emp_id = e.id
);
UPDATE products p, inventory i
SET p.price = p.price * 1.1,
i.quantity = i.quantity - 1
WHERE p.id = i.product_id AND i.quantity > 5;
SELECT price FROM products WHERE id = 1;
SELECT quantity FROM inventory WHERE product_id = 1;
UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_with_join_no_matches
-- Source: update_enhancements_advanced_tdd.rs:154
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, discount FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries_history;
CREATE TABLE salaries_history (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0), (2, 60000.0);
INSERT INTO salaries_history VALUES (1, 55000.0), (1, 58000.0), (2, 65000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0), (3, 300.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary FLOAT64);
INSERT INTO employees VALUES (1, 'Alice', 50000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, rate FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO discounts VALUES (1, 0.1);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, dept_avg FLOAT64);
DROP TABLE IF EXISTS dept_salaries;
CREATE TABLE dept_salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 0.0), (2, 60000.0, 0.0);
INSERT INTO dept_salaries VALUES (1, 50000.0), (1, 55000.0), (2, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64, max_price FLOAT64);
DROP TABLE IF EXISTS price_history;
CREATE TABLE price_history (product_id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0, 0.0), (2, 200.0, 0.0);
INSERT INTO price_history VALUES (1, 120.0), (1, 150.0), (2, 250.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, bonus FLOAT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 0.0), (2, 0.0);
INSERT INTO bonuses VALUES (1, 1000.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries;
CREATE TABLE salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0);
INSERT INTO salaries VALUES (1, 55000.0), (1, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (product_id INT64, quantity INT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO inventory VALUES (1, 10), (2, 5);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE products p
SET price = price * 0.9
FROM discounts d
WHERE p.id = d.product_id;
SELECT price FROM products ORDER BY id;
UPDATE employees e
SET salary = max_sal.amount
FROM (
SELECT emp_id, MAX(amount) as amount
FROM salaries_history
GROUP BY emp_id
) max_sal
WHERE e.id = max_sal.emp_id;
SELECT id, salary FROM employees ORDER BY id;
WITH avg_price AS (
SELECT AVG(price) as avg FROM products
)
UPDATE products
SET price = price * 1.1
FROM avg_price
WHERE price < avg_price.avg;
SELECT id, price FROM products ORDER BY id;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING *;
UPDATE employees SET salary = 55000.0 WHERE id = 1 RETURNING id, salary;
UPDATE products
SET price = price * 1.2
RETURNING id, price as new_price, price / 1.2 as old_price;
UPDATE products SET price = 200.0 WHERE id = 999 RETURNING *;
UPDATE products p
SET price = price * (1.0 - d.rate)
FROM discounts d
WHERE p.id = d.product_id
RETURNING p.id, p.price, d.rate;
UPDATE employees e
SET dept_avg = (
SELECT AVG(amount)
FROM dept_salaries
WHERE emp_id = e.id
);
SELECT id, dept_avg FROM employees ORDER BY id;
UPDATE products p
SET max_price = (
SELECT MAX(price)
FROM price_history h
WHERE h.product_id = p.id
);
SELECT id, max_price FROM products ORDER BY id;
UPDATE employees e
SET bonus = (
SELECT amount FROM bonuses WHERE emp_id = e.id
);
SELECT id, bonus FROM employees ORDER BY id;
UPDATE employees e
SET salary = (
SELECT amount FROM salaries WHERE emp_id = e.id
);
UPDATE products p, inventory i
SET p.price = p.price * 1.1,
i.quantity = i.quantity - 1
WHERE p.id = i.product_id AND i.quantity > 5;
SELECT price FROM products WHERE id = 1;
SELECT quantity FROM inventory WHERE product_id = 1;
UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_from_subquery
-- Source: update_enhancements_advanced_tdd.rs:189
-- ============================================================================
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries_history;
CREATE TABLE salaries_history (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0), (2, 60000.0);
INSERT INTO salaries_history VALUES (1, 55000.0), (1, 58000.0), (2, 65000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0), (3, 300.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary FLOAT64);
INSERT INTO employees VALUES (1, 'Alice', 50000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, rate FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO discounts VALUES (1, 0.1);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, dept_avg FLOAT64);
DROP TABLE IF EXISTS dept_salaries;
CREATE TABLE dept_salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 0.0), (2, 60000.0, 0.0);
INSERT INTO dept_salaries VALUES (1, 50000.0), (1, 55000.0), (2, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64, max_price FLOAT64);
DROP TABLE IF EXISTS price_history;
CREATE TABLE price_history (product_id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0, 0.0), (2, 200.0, 0.0);
INSERT INTO price_history VALUES (1, 120.0), (1, 150.0), (2, 250.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, bonus FLOAT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 0.0), (2, 0.0);
INSERT INTO bonuses VALUES (1, 1000.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries;
CREATE TABLE salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0);
INSERT INTO salaries VALUES (1, 55000.0), (1, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (product_id INT64, quantity INT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO inventory VALUES (1, 10), (2, 5);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE employees e
SET salary = max_sal.amount
FROM (
SELECT emp_id, MAX(amount) as amount
FROM salaries_history
GROUP BY emp_id
) max_sal
WHERE e.id = max_sal.emp_id;
SELECT id, salary FROM employees ORDER BY id;
WITH avg_price AS (
SELECT AVG(price) as avg FROM products
)
UPDATE products
SET price = price * 1.1
FROM avg_price
WHERE price < avg_price.avg;
SELECT id, price FROM products ORDER BY id;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING *;
UPDATE employees SET salary = 55000.0 WHERE id = 1 RETURNING id, salary;
UPDATE products
SET price = price * 1.2
RETURNING id, price as new_price, price / 1.2 as old_price;
UPDATE products SET price = 200.0 WHERE id = 999 RETURNING *;
UPDATE products p
SET price = price * (1.0 - d.rate)
FROM discounts d
WHERE p.id = d.product_id
RETURNING p.id, p.price, d.rate;
UPDATE employees e
SET dept_avg = (
SELECT AVG(amount)
FROM dept_salaries
WHERE emp_id = e.id
);
SELECT id, dept_avg FROM employees ORDER BY id;
UPDATE products p
SET max_price = (
SELECT MAX(price)
FROM price_history h
WHERE h.product_id = p.id
);
SELECT id, max_price FROM products ORDER BY id;
UPDATE employees e
SET bonus = (
SELECT amount FROM bonuses WHERE emp_id = e.id
);
SELECT id, bonus FROM employees ORDER BY id;
UPDATE employees e
SET salary = (
SELECT amount FROM salaries WHERE emp_id = e.id
);
UPDATE products p, inventory i
SET p.price = p.price * 1.1,
i.quantity = i.quantity - 1
WHERE p.id = i.product_id AND i.quantity > 5;
SELECT price FROM products WHERE id = 1;
SELECT quantity FROM inventory WHERE product_id = 1;
UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_from_cte
-- Source: update_enhancements_advanced_tdd.rs:223
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0), (3, 300.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary FLOAT64);
INSERT INTO employees VALUES (1, 'Alice', 50000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, rate FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO discounts VALUES (1, 0.1);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, dept_avg FLOAT64);
DROP TABLE IF EXISTS dept_salaries;
CREATE TABLE dept_salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 0.0), (2, 60000.0, 0.0);
INSERT INTO dept_salaries VALUES (1, 50000.0), (1, 55000.0), (2, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64, max_price FLOAT64);
DROP TABLE IF EXISTS price_history;
CREATE TABLE price_history (product_id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0, 0.0), (2, 200.0, 0.0);
INSERT INTO price_history VALUES (1, 120.0), (1, 150.0), (2, 250.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, bonus FLOAT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 0.0), (2, 0.0);
INSERT INTO bonuses VALUES (1, 1000.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries;
CREATE TABLE salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0);
INSERT INTO salaries VALUES (1, 55000.0), (1, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (product_id INT64, quantity INT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO inventory VALUES (1, 10), (2, 5);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

WITH avg_price AS (
SELECT AVG(price) as avg FROM products
)
UPDATE products
SET price = price * 1.1
FROM avg_price
WHERE price < avg_price.avg;
SELECT id, price FROM products ORDER BY id;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING *;
UPDATE employees SET salary = 55000.0 WHERE id = 1 RETURNING id, salary;
UPDATE products
SET price = price * 1.2
RETURNING id, price as new_price, price / 1.2 as old_price;
UPDATE products SET price = 200.0 WHERE id = 999 RETURNING *;
UPDATE products p
SET price = price * (1.0 - d.rate)
FROM discounts d
WHERE p.id = d.product_id
RETURNING p.id, p.price, d.rate;
UPDATE employees e
SET dept_avg = (
SELECT AVG(amount)
FROM dept_salaries
WHERE emp_id = e.id
);
SELECT id, dept_avg FROM employees ORDER BY id;
UPDATE products p
SET max_price = (
SELECT MAX(price)
FROM price_history h
WHERE h.product_id = p.id
);
SELECT id, max_price FROM products ORDER BY id;
UPDATE employees e
SET bonus = (
SELECT amount FROM bonuses WHERE emp_id = e.id
);
SELECT id, bonus FROM employees ORDER BY id;
UPDATE employees e
SET salary = (
SELECT amount FROM salaries WHERE emp_id = e.id
);
UPDATE products p, inventory i
SET p.price = p.price * 1.1,
i.quantity = i.quantity - 1
WHERE p.id = i.product_id AND i.quantity > 5;
SELECT price FROM products WHERE id = 1;
SELECT quantity FROM inventory WHERE product_id = 1;
UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_returning_all
-- Source: update_enhancements_advanced_tdd.rs:259
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary FLOAT64);
INSERT INTO employees VALUES (1, 'Alice', 50000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, rate FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO discounts VALUES (1, 0.1);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, dept_avg FLOAT64);
DROP TABLE IF EXISTS dept_salaries;
CREATE TABLE dept_salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 0.0), (2, 60000.0, 0.0);
INSERT INTO dept_salaries VALUES (1, 50000.0), (1, 55000.0), (2, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64, max_price FLOAT64);
DROP TABLE IF EXISTS price_history;
CREATE TABLE price_history (product_id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0, 0.0), (2, 200.0, 0.0);
INSERT INTO price_history VALUES (1, 120.0), (1, 150.0), (2, 250.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, bonus FLOAT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 0.0), (2, 0.0);
INSERT INTO bonuses VALUES (1, 1000.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries;
CREATE TABLE salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0);
INSERT INTO salaries VALUES (1, 55000.0), (1, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (product_id INT64, quantity INT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO inventory VALUES (1, 10), (2, 5);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING *;
UPDATE employees SET salary = 55000.0 WHERE id = 1 RETURNING id, salary;
UPDATE products
SET price = price * 1.2
RETURNING id, price as new_price, price / 1.2 as old_price;
UPDATE products SET price = 200.0 WHERE id = 999 RETURNING *;
UPDATE products p
SET price = price * (1.0 - d.rate)
FROM discounts d
WHERE p.id = d.product_id
RETURNING p.id, p.price, d.rate;
UPDATE employees e
SET dept_avg = (
SELECT AVG(amount)
FROM dept_salaries
WHERE emp_id = e.id
);
SELECT id, dept_avg FROM employees ORDER BY id;
UPDATE products p
SET max_price = (
SELECT MAX(price)
FROM price_history h
WHERE h.product_id = p.id
);
SELECT id, max_price FROM products ORDER BY id;
UPDATE employees e
SET bonus = (
SELECT amount FROM bonuses WHERE emp_id = e.id
);
SELECT id, bonus FROM employees ORDER BY id;
UPDATE employees e
SET salary = (
SELECT amount FROM salaries WHERE emp_id = e.id
);
UPDATE products p, inventory i
SET p.price = p.price * 1.1,
i.quantity = i.quantity - 1
WHERE p.id = i.product_id AND i.quantity > 5;
SELECT price FROM products WHERE id = 1;
SELECT quantity FROM inventory WHERE product_id = 1;
UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_returning_specific_columns
-- Source: update_enhancements_advanced_tdd.rs:285
-- ============================================================================
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary FLOAT64);
INSERT INTO employees VALUES (1, 'Alice', 50000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, rate FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO discounts VALUES (1, 0.1);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, dept_avg FLOAT64);
DROP TABLE IF EXISTS dept_salaries;
CREATE TABLE dept_salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 0.0), (2, 60000.0, 0.0);
INSERT INTO dept_salaries VALUES (1, 50000.0), (1, 55000.0), (2, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64, max_price FLOAT64);
DROP TABLE IF EXISTS price_history;
CREATE TABLE price_history (product_id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0, 0.0), (2, 200.0, 0.0);
INSERT INTO price_history VALUES (1, 120.0), (1, 150.0), (2, 250.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, bonus FLOAT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 0.0), (2, 0.0);
INSERT INTO bonuses VALUES (1, 1000.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries;
CREATE TABLE salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0);
INSERT INTO salaries VALUES (1, 55000.0), (1, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (product_id INT64, quantity INT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO inventory VALUES (1, 10), (2, 5);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE employees SET salary = 55000.0 WHERE id = 1 RETURNING id, salary;
UPDATE products
SET price = price * 1.2
RETURNING id, price as new_price, price / 1.2 as old_price;
UPDATE products SET price = 200.0 WHERE id = 999 RETURNING *;
UPDATE products p
SET price = price * (1.0 - d.rate)
FROM discounts d
WHERE p.id = d.product_id
RETURNING p.id, p.price, d.rate;
UPDATE employees e
SET dept_avg = (
SELECT AVG(amount)
FROM dept_salaries
WHERE emp_id = e.id
);
SELECT id, dept_avg FROM employees ORDER BY id;
UPDATE products p
SET max_price = (
SELECT MAX(price)
FROM price_history h
WHERE h.product_id = p.id
);
SELECT id, max_price FROM products ORDER BY id;
UPDATE employees e
SET bonus = (
SELECT amount FROM bonuses WHERE emp_id = e.id
);
SELECT id, bonus FROM employees ORDER BY id;
UPDATE employees e
SET salary = (
SELECT amount FROM salaries WHERE emp_id = e.id
);
UPDATE products p, inventory i
SET p.price = p.price * 1.1,
i.quantity = i.quantity - 1
WHERE p.id = i.product_id AND i.quantity > 5;
SELECT price FROM products WHERE id = 1;
SELECT quantity FROM inventory WHERE product_id = 1;
UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_returning_expressions
-- Source: update_enhancements_advanced_tdd.rs:307
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, rate FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO discounts VALUES (1, 0.1);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, dept_avg FLOAT64);
DROP TABLE IF EXISTS dept_salaries;
CREATE TABLE dept_salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 0.0), (2, 60000.0, 0.0);
INSERT INTO dept_salaries VALUES (1, 50000.0), (1, 55000.0), (2, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64, max_price FLOAT64);
DROP TABLE IF EXISTS price_history;
CREATE TABLE price_history (product_id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0, 0.0), (2, 200.0, 0.0);
INSERT INTO price_history VALUES (1, 120.0), (1, 150.0), (2, 250.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, bonus FLOAT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 0.0), (2, 0.0);
INSERT INTO bonuses VALUES (1, 1000.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries;
CREATE TABLE salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0);
INSERT INTO salaries VALUES (1, 55000.0), (1, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (product_id INT64, quantity INT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO inventory VALUES (1, 10), (2, 5);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE products
SET price = price * 1.2
RETURNING id, price as new_price, price / 1.2 as old_price;
UPDATE products SET price = 200.0 WHERE id = 999 RETURNING *;
UPDATE products p
SET price = price * (1.0 - d.rate)
FROM discounts d
WHERE p.id = d.product_id
RETURNING p.id, p.price, d.rate;
UPDATE employees e
SET dept_avg = (
SELECT AVG(amount)
FROM dept_salaries
WHERE emp_id = e.id
);
SELECT id, dept_avg FROM employees ORDER BY id;
UPDATE products p
SET max_price = (
SELECT MAX(price)
FROM price_history h
WHERE h.product_id = p.id
);
SELECT id, max_price FROM products ORDER BY id;
UPDATE employees e
SET bonus = (
SELECT amount FROM bonuses WHERE emp_id = e.id
);
SELECT id, bonus FROM employees ORDER BY id;
UPDATE employees e
SET salary = (
SELECT amount FROM salaries WHERE emp_id = e.id
);
UPDATE products p, inventory i
SET p.price = p.price * 1.1,
i.quantity = i.quantity - 1
WHERE p.id = i.product_id AND i.quantity > 5;
SELECT price FROM products WHERE id = 1;
SELECT quantity FROM inventory WHERE product_id = 1;
UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_returning_no_rows
-- Source: update_enhancements_advanced_tdd.rs:333
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, rate FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO discounts VALUES (1, 0.1);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, dept_avg FLOAT64);
DROP TABLE IF EXISTS dept_salaries;
CREATE TABLE dept_salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 0.0), (2, 60000.0, 0.0);
INSERT INTO dept_salaries VALUES (1, 50000.0), (1, 55000.0), (2, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64, max_price FLOAT64);
DROP TABLE IF EXISTS price_history;
CREATE TABLE price_history (product_id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0, 0.0), (2, 200.0, 0.0);
INSERT INTO price_history VALUES (1, 120.0), (1, 150.0), (2, 250.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, bonus FLOAT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 0.0), (2, 0.0);
INSERT INTO bonuses VALUES (1, 1000.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries;
CREATE TABLE salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0);
INSERT INTO salaries VALUES (1, 55000.0), (1, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (product_id INT64, quantity INT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO inventory VALUES (1, 10), (2, 5);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE products SET price = 200.0 WHERE id = 999 RETURNING *;
UPDATE products p
SET price = price * (1.0 - d.rate)
FROM discounts d
WHERE p.id = d.product_id
RETURNING p.id, p.price, d.rate;
UPDATE employees e
SET dept_avg = (
SELECT AVG(amount)
FROM dept_salaries
WHERE emp_id = e.id
);
SELECT id, dept_avg FROM employees ORDER BY id;
UPDATE products p
SET max_price = (
SELECT MAX(price)
FROM price_history h
WHERE h.product_id = p.id
);
SELECT id, max_price FROM products ORDER BY id;
UPDATE employees e
SET bonus = (
SELECT amount FROM bonuses WHERE emp_id = e.id
);
SELECT id, bonus FROM employees ORDER BY id;
UPDATE employees e
SET salary = (
SELECT amount FROM salaries WHERE emp_id = e.id
);
UPDATE products p, inventory i
SET p.price = p.price * 1.1,
i.quantity = i.quantity - 1
WHERE p.id = i.product_id AND i.quantity > 5;
SELECT price FROM products WHERE id = 1;
SELECT quantity FROM inventory WHERE product_id = 1;
UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_returning_with_join
-- Source: update_enhancements_advanced_tdd.rs:351
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS discounts;
CREATE TABLE discounts (product_id INT64, rate FLOAT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO discounts VALUES (1, 0.1);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, dept_avg FLOAT64);
DROP TABLE IF EXISTS dept_salaries;
CREATE TABLE dept_salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 0.0), (2, 60000.0, 0.0);
INSERT INTO dept_salaries VALUES (1, 50000.0), (1, 55000.0), (2, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64, max_price FLOAT64);
DROP TABLE IF EXISTS price_history;
CREATE TABLE price_history (product_id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0, 0.0), (2, 200.0, 0.0);
INSERT INTO price_history VALUES (1, 120.0), (1, 150.0), (2, 250.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, bonus FLOAT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 0.0), (2, 0.0);
INSERT INTO bonuses VALUES (1, 1000.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries;
CREATE TABLE salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0);
INSERT INTO salaries VALUES (1, 55000.0), (1, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (product_id INT64, quantity INT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO inventory VALUES (1, 10), (2, 5);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE products p
SET price = price * (1.0 - d.rate)
FROM discounts d
WHERE p.id = d.product_id
RETURNING p.id, p.price, d.rate;
UPDATE employees e
SET dept_avg = (
SELECT AVG(amount)
FROM dept_salaries
WHERE emp_id = e.id
);
SELECT id, dept_avg FROM employees ORDER BY id;
UPDATE products p
SET max_price = (
SELECT MAX(price)
FROM price_history h
WHERE h.product_id = p.id
);
SELECT id, max_price FROM products ORDER BY id;
UPDATE employees e
SET bonus = (
SELECT amount FROM bonuses WHERE emp_id = e.id
);
SELECT id, bonus FROM employees ORDER BY id;
UPDATE employees e
SET salary = (
SELECT amount FROM salaries WHERE emp_id = e.id
);
UPDATE products p, inventory i
SET p.price = p.price * 1.1,
i.quantity = i.quantity - 1
WHERE p.id = i.product_id AND i.quantity > 5;
SELECT price FROM products WHERE id = 1;
SELECT quantity FROM inventory WHERE product_id = 1;
UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_set_scalar_subquery
-- Source: update_enhancements_advanced_tdd.rs:386
-- ============================================================================
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, dept_avg FLOAT64);
DROP TABLE IF EXISTS dept_salaries;
CREATE TABLE dept_salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 0.0), (2, 60000.0, 0.0);
INSERT INTO dept_salaries VALUES (1, 50000.0), (1, 55000.0), (2, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64, max_price FLOAT64);
DROP TABLE IF EXISTS price_history;
CREATE TABLE price_history (product_id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0, 0.0), (2, 200.0, 0.0);
INSERT INTO price_history VALUES (1, 120.0), (1, 150.0), (2, 250.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, bonus FLOAT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 0.0), (2, 0.0);
INSERT INTO bonuses VALUES (1, 1000.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries;
CREATE TABLE salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0);
INSERT INTO salaries VALUES (1, 55000.0), (1, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (product_id INT64, quantity INT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO inventory VALUES (1, 10), (2, 5);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE employees e
SET dept_avg = (
SELECT AVG(amount)
FROM dept_salaries
WHERE emp_id = e.id
);
SELECT id, dept_avg FROM employees ORDER BY id;
UPDATE products p
SET max_price = (
SELECT MAX(price)
FROM price_history h
WHERE h.product_id = p.id
);
SELECT id, max_price FROM products ORDER BY id;
UPDATE employees e
SET bonus = (
SELECT amount FROM bonuses WHERE emp_id = e.id
);
SELECT id, bonus FROM employees ORDER BY id;
UPDATE employees e
SET salary = (
SELECT amount FROM salaries WHERE emp_id = e.id
);
UPDATE products p, inventory i
SET p.price = p.price * 1.1,
i.quantity = i.quantity - 1
WHERE p.id = i.product_id AND i.quantity > 5;
SELECT price FROM products WHERE id = 1;
SELECT quantity FROM inventory WHERE product_id = 1;
UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_set_correlated_subquery
-- Source: update_enhancements_advanced_tdd.rs:418
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64, max_price FLOAT64);
DROP TABLE IF EXISTS price_history;
CREATE TABLE price_history (product_id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0, 0.0), (2, 200.0, 0.0);
INSERT INTO price_history VALUES (1, 120.0), (1, 150.0), (2, 250.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, bonus FLOAT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 0.0), (2, 0.0);
INSERT INTO bonuses VALUES (1, 1000.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries;
CREATE TABLE salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0);
INSERT INTO salaries VALUES (1, 55000.0), (1, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (product_id INT64, quantity INT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO inventory VALUES (1, 10), (2, 5);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE products p
SET max_price = (
SELECT MAX(price)
FROM price_history h
WHERE h.product_id = p.id
);
SELECT id, max_price FROM products ORDER BY id;
UPDATE employees e
SET bonus = (
SELECT amount FROM bonuses WHERE emp_id = e.id
);
SELECT id, bonus FROM employees ORDER BY id;
UPDATE employees e
SET salary = (
SELECT amount FROM salaries WHERE emp_id = e.id
);
UPDATE products p, inventory i
SET p.price = p.price * 1.1,
i.quantity = i.quantity - 1
WHERE p.id = i.product_id AND i.quantity > 5;
SELECT price FROM products WHERE id = 1;
SELECT quantity FROM inventory WHERE product_id = 1;
UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_set_subquery_null
-- Source: update_enhancements_advanced_tdd.rs:450
-- ============================================================================
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, bonus FLOAT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 0.0), (2, 0.0);
INSERT INTO bonuses VALUES (1, 1000.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries;
CREATE TABLE salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0);
INSERT INTO salaries VALUES (1, 55000.0), (1, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (product_id INT64, quantity INT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO inventory VALUES (1, 10), (2, 5);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE employees e
SET bonus = (
SELECT amount FROM bonuses WHERE emp_id = e.id
);
SELECT id, bonus FROM employees ORDER BY id;
UPDATE employees e
SET salary = (
SELECT amount FROM salaries WHERE emp_id = e.id
);
UPDATE products p, inventory i
SET p.price = p.price * 1.1,
i.quantity = i.quantity - 1
WHERE p.id = i.product_id AND i.quantity > 5;
SELECT price FROM products WHERE id = 1;
SELECT quantity FROM inventory WHERE product_id = 1;
UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_set_subquery_multiple_rows_error
-- Source: update_enhancements_advanced_tdd.rs:480
-- ============================================================================
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64);
DROP TABLE IF EXISTS salaries;
CREATE TABLE salaries (emp_id INT64, amount FLOAT64);
INSERT INTO employees VALUES (1, 50000.0);
INSERT INTO salaries VALUES (1, 55000.0), (1, 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (product_id INT64, quantity INT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO inventory VALUES (1, 10), (2, 5);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE employees e
SET salary = (
SELECT amount FROM salaries WHERE emp_id = e.id
);
UPDATE products p, inventory i
SET p.price = p.price * 1.1,
i.quantity = i.quantity - 1
WHERE p.id = i.product_id AND i.quantity > 5;
SELECT price FROM products WHERE id = 1;
SELECT quantity FROM inventory WHERE product_id = 1;
UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_multi_table_update
-- Source: update_enhancements_advanced_tdd.rs:512
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory (product_id INT64, quantity INT64);
INSERT INTO products VALUES (1, 100.0), (2, 200.0);
INSERT INTO inventory VALUES (1, 10), (2, 5);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE products p, inventory i
SET p.price = p.price * 1.1,
i.quantity = i.quantity - 1
WHERE p.id = i.product_id AND i.quantity > 5;
SELECT price FROM products WHERE id = 1;
SELECT quantity FROM inventory WHERE product_id = 1;
UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_unique_constraint_violation
-- Source: update_enhancements_advanced_tdd.rs:551
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE users SET email = 'alice@example.com' WHERE id = 2;
UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_check_constraint_violation
-- Source: update_enhancements_advanced_tdd.rs:573
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64 CHECK (price > 0));
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE products SET price = -50.0 WHERE id = 1;
UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_not_null_violation
-- Source: update_enhancements_advanced_tdd.rs:595
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING NOT NULL);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE users SET name = NULL WHERE id = 1;
UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_with_case
-- Source: update_enhancements_advanced_tdd.rs:619
-- ============================================================================
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, performance STRING);
INSERT INTO employees VALUES (1, 50000.0, 'Excellent'), (2, 60000.0, 'Good'), (3, 55000.0, 'Average');
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE employees
SET salary = CASE performance
WHEN 'Excellent' THEN salary * 1.15
WHEN 'Good' THEN salary * 1.10
WHEN 'Average' THEN salary * 1.05
ELSE salary
END;
SELECT id, salary FROM employees ORDER BY id;
UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;

-- ============================================================================
-- Test: test_update_with_window_function
-- Source: update_enhancements_advanced_tdd.rs:650
-- ============================================================================
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, amount FLOAT64, rank INT64);
INSERT INTO sales VALUES (1, 100.0, 0), (2, 200.0, 0), (3, 150.0, 0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, salary FLOAT64, bonus FLOAT64, total FLOAT64);
DROP TABLE IF EXISTS sal_adj;
CREATE TABLE sal_adj (emp_id INT64, new_sal FLOAT64);
DROP TABLE IF EXISTS bon_adj;
CREATE TABLE bon_adj (emp_id INT64, new_bon FLOAT64);
INSERT INTO employees VALUES (1, 50000.0, 5000.0, 0.0);
INSERT INTO sal_adj VALUES (1, 55000.0);
INSERT INTO bon_adj VALUES (1, 6000.0);
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64, doubled INT64);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64, total FLOAT64, status STRING);
DROP TABLE IF EXISTS customers;
CREATE TABLE customers (id INT64, tier STRING, lifetime_value FLOAT64);
DROP TABLE IF EXISTS tier_config;
CREATE TABLE tier_config (tier STRING, discount FLOAT64, min_value FLOAT64);
INSERT INTO orders VALUES (1, 1, 1000.0, 'pending'), (2, 2, 500.0, 'pending');
INSERT INTO customers VALUES (1, 'Gold', 5000.0), (2, 'Silver', 2000.0);
INSERT INTO tier_config VALUES ('Gold', 0.15, 3000.0), ('Silver', 0.05, 1000.0);

UPDATE sales
SET rank = (
SELECT ROW_NUMBER() OVER (ORDER BY amount DESC)
FROM (SELECT 1) dummy
WHERE sales.id = sales.id
);
UPDATE employees e
SET salary = (SELECT new_sal FROM sal_adj WHERE emp_id = e.id),
bonus = (SELECT new_bon FROM bon_adj WHERE emp_id = e.id),
total = salary + bonus;
SELECT salary, bonus, total FROM employees WHERE id = 1;
UPDATE numbers SET doubled = n * 2;
SELECT n, doubled FROM numbers WHERE n IN (0, 100, 9999);
UPDATE orders o
SET total = total * (1.0 - t.discount),
status = 'processed'
FROM customers c
JOIN tier_config t ON c.tier = t.tier
WHERE o.customer_id = c.id
AND c.lifetime_value >= t.min_value
AND o.status = 'pending'
RETURNING o.id, o.total, o.status;
