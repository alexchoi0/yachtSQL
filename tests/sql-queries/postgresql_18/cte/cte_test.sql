-- ============================================================================
-- Cte - PostgreSQL 18
-- ============================================================================
-- Source: Migrated from delete_enhancements_advanced_tdd.rs, distinct_on_comprehensive_tdd.rs, insert_on_conflict_upsert_comprehensive_tdd.rs, join_based_dml_comprehensive_tdd.rs, materialized_views_comprehensive_tdd.rs, merge_statement_comprehensive_tdd.rs, returning_clause_comprehensive_tdd.rs, table_ddl_enhancements_comprehensive_tdd.rs, timestamp_with_time_zone_comprehensive_tdd.rs
-- Description: Common Table Expressions (WITH clause) for query organization
--
-- PostgreSQL: Full support
-- BigQuery: Limited or no support
-- SQL Standard: PostgreSQL 18 specific
-- ============================================================================

DROP TABLE IF EXISTS orphan_check;
CREATE TABLE orphan_check (id INT64, parent_id INT64);
DROP TABLE IF EXISTS parents;
CREATE TABLE parents (id INT64);
INSERT INTO orphan_check VALUES (1, 1), (2, 2), (3, 999);
INSERT INTO parents VALUES (1), (2);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, timestamp INT64);
INSERT INTO logs VALUES (1, 1, 100), (2, 1, 200), (3, 1, 300), (4, 2, 150);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 10.0), (2, 50.0), (3, 100.0), (4, 25.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0), (3, 'Gizmo', 300.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary FLOAT64);
INSERT INTO employees VALUES (1, 'Alice', 50000.0), (2, 'Bob', 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category_id INT64, name STRING);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, deprecated BOOL);
INSERT INTO items VALUES (1, 1, 'Item1'), (2, 2, 'Item2'), (3, 1, 'Item3');
INSERT INTO categories VALUES (1, TRUE), (2, FALSE);
DROP TABLE IF EXISTS active_orders;
CREATE TABLE active_orders (id INT64, total FLOAT64, created_at INT64);
DROP TABLE IF EXISTS archived_orders;
CREATE TABLE archived_orders (id INT64, total FLOAT64, created_at INT64, deleted_at INT64);
INSERT INTO active_orders VALUES (1, 100.0, 1000), (2, 200.0, 2000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, product_id INT64);
INSERT INTO orders VALUES (1, 1), (2, 2);
INSERT INTO order_items VALUES (1, 100), (1, 200), (2, 300);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id));
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees ( id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id) ON DELETE CASCADE );
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1), (2, 1);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees ( id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id) ON DELETE SET NULL );
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1), (2, 1);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 10.0), (2, 50.0), (3, 100.0), (4, 25.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 1, 100.0), (2, 1, 200.0), (3, 2, 150.0), (4, 2, 300.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64);
INSERT INTO products VALUES (1, 'Popular'), (2, 'Unpopular'), (3, 'Popular2');
INSERT INTO orders VALUES (1), (1), (3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept STRING);
DROP TABLE IF EXISTS closed_depts;
CREATE TABLE closed_depts (name STRING);
INSERT INTO employees VALUES (1, 'Sales'), (2, 'Engineering'), (3, 'Marketing');
INSERT INTO closed_depts VALUES ('Sales'), ('Marketing');
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, level STRING, timestamp INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, active BOOL);
DROP TABLE IF EXISTS retention_policy;
CREATE TABLE retention_policy (level STRING, days INT64);
INSERT INTO logs VALUES (1, 1, 'DEBUG', 100), (2, 1, 'INFO', 200), (3, 2, 'ERROR', 150);
INSERT INTO users VALUES (1, FALSE), (2, TRUE);
INSERT INTO retention_policy VALUES ('DEBUG', 7), ('INFO', 30), ('ERROR', 90);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2), (3);
DROP TABLE IF EXISTS queue;
CREATE TABLE queue (id INT64, priority INT64);
INSERT INTO queue VALUES (1, 1), (2, 1), (3, 2), (4, 1);

DELETE FROM orphan_check o USING (SELECT * FROM orphan_check) oc LEFT JOIN parents p ON oc.parent_id = p.id WHERE o.id = oc.id AND p.id IS NULL;
SELECT id FROM orphan_check ORDER BY id;
DELETE FROM logs l USING ( SELECT user_id, MAX(timestamp) as max_ts FROM logs GROUP BY user_id ) recent WHERE l.user_id = recent.user_id AND l.timestamp < recent.max_ts;
SELECT id, user_id FROM logs ORDER BY id;
WITH high_price AS ( SELECT AVG(price) * 2 as threshold FROM products ) DELETE FROM products p USING high_price h WHERE p.price > h.threshold;
SELECT id FROM products ORDER BY id;
DELETE FROM products WHERE price > 150.0 RETURNING *;
DELETE FROM employees WHERE id = 1 RETURNING id, name;
DELETE FROM products WHERE id <= 2 RETURNING id, name, price, price * 0.8 as discounted_price;
DELETE FROM products WHERE id = 999 RETURNING *;
DELETE FROM items i USING categories c WHERE i.category_id = c.id AND c.deprecated = TRUE RETURNING i.id, i.name, c.id as category_id;
DELETE FROM active_orders WHERE created_at < 1500 RETURNING id, total, created_at;
DELETE orders, order_items FROM orders JOIN order_items ON orders.id = order_items.order_id WHERE orders.id = 1;
SELECT id FROM orders;
SELECT order_id FROM order_items;
DELETE FROM departments WHERE id = 1;
DELETE FROM departments WHERE id = 1;
SELECT COUNT(*) FROM employees;
DELETE FROM departments WHERE id = 1;
SELECT dept_id FROM employees;
DELETE FROM products WHERE price > (SELECT AVG(price) FROM products);
SELECT id FROM products ORDER BY id;
DELETE FROM sales s1 WHERE amount < ( SELECT AVG(amount) FROM sales s2 WHERE s2.product_id = s1.product_id );
SELECT id FROM sales ORDER BY id;
DELETE FROM products p WHERE NOT EXISTS ( SELECT 1 FROM orders o WHERE o.product_id = p.id );
SELECT id FROM products ORDER BY id;
DELETE FROM employees WHERE dept IN (SELECT name FROM closed_depts);
SELECT id FROM employees;
DELETE FROM numbers WHERE n < 5000;
SELECT COUNT(*) FROM numbers;
DELETE FROM logs l USING users u JOIN retention_policy r ON l.level = r.level WHERE l.user_id = u.id AND u.active = FALSE AND l.timestamp < (300 - r.days) RETURNING l.id, l.level;
DELETE FROM test;
SELECT COUNT(*) FROM test;
DELETE FROM queue WHERE priority = 1 LIMIT 2;
SELECT id FROM queue ORDER BY id;

-- ============================================================================
-- Test: test_delete_using_subquery
-- Source: delete_enhancements_advanced_tdd.rs:177
-- ============================================================================
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, timestamp INT64);
INSERT INTO logs VALUES (1, 1, 100), (2, 1, 200), (3, 1, 300), (4, 2, 150);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 10.0), (2, 50.0), (3, 100.0), (4, 25.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0), (3, 'Gizmo', 300.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary FLOAT64);
INSERT INTO employees VALUES (1, 'Alice', 50000.0), (2, 'Bob', 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category_id INT64, name STRING);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, deprecated BOOL);
INSERT INTO items VALUES (1, 1, 'Item1'), (2, 2, 'Item2'), (3, 1, 'Item3');
INSERT INTO categories VALUES (1, TRUE), (2, FALSE);
DROP TABLE IF EXISTS active_orders;
CREATE TABLE active_orders (id INT64, total FLOAT64, created_at INT64);
DROP TABLE IF EXISTS archived_orders;
CREATE TABLE archived_orders (id INT64, total FLOAT64, created_at INT64, deleted_at INT64);
INSERT INTO active_orders VALUES (1, 100.0, 1000), (2, 200.0, 2000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, product_id INT64);
INSERT INTO orders VALUES (1, 1), (2, 2);
INSERT INTO order_items VALUES (1, 100), (1, 200), (2, 300);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id));
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees ( id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id) ON DELETE CASCADE );
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1), (2, 1);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees ( id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id) ON DELETE SET NULL );
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1), (2, 1);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 10.0), (2, 50.0), (3, 100.0), (4, 25.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 1, 100.0), (2, 1, 200.0), (3, 2, 150.0), (4, 2, 300.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64);
INSERT INTO products VALUES (1, 'Popular'), (2, 'Unpopular'), (3, 'Popular2');
INSERT INTO orders VALUES (1), (1), (3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept STRING);
DROP TABLE IF EXISTS closed_depts;
CREATE TABLE closed_depts (name STRING);
INSERT INTO employees VALUES (1, 'Sales'), (2, 'Engineering'), (3, 'Marketing');
INSERT INTO closed_depts VALUES ('Sales'), ('Marketing');
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, level STRING, timestamp INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, active BOOL);
DROP TABLE IF EXISTS retention_policy;
CREATE TABLE retention_policy (level STRING, days INT64);
INSERT INTO logs VALUES (1, 1, 'DEBUG', 100), (2, 1, 'INFO', 200), (3, 2, 'ERROR', 150);
INSERT INTO users VALUES (1, FALSE), (2, TRUE);
INSERT INTO retention_policy VALUES ('DEBUG', 7), ('INFO', 30), ('ERROR', 90);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2), (3);
DROP TABLE IF EXISTS queue;
CREATE TABLE queue (id INT64, priority INT64);
INSERT INTO queue VALUES (1, 1), (2, 1), (3, 2), (4, 1);

DELETE FROM logs l USING ( SELECT user_id, MAX(timestamp) as max_ts FROM logs GROUP BY user_id ) recent WHERE l.user_id = recent.user_id AND l.timestamp < recent.max_ts;
SELECT id, user_id FROM logs ORDER BY id;
WITH high_price AS ( SELECT AVG(price) * 2 as threshold FROM products ) DELETE FROM products p USING high_price h WHERE p.price > h.threshold;
SELECT id FROM products ORDER BY id;
DELETE FROM products WHERE price > 150.0 RETURNING *;
DELETE FROM employees WHERE id = 1 RETURNING id, name;
DELETE FROM products WHERE id <= 2 RETURNING id, name, price, price * 0.8 as discounted_price;
DELETE FROM products WHERE id = 999 RETURNING *;
DELETE FROM items i USING categories c WHERE i.category_id = c.id AND c.deprecated = TRUE RETURNING i.id, i.name, c.id as category_id;
DELETE FROM active_orders WHERE created_at < 1500 RETURNING id, total, created_at;
DELETE orders, order_items FROM orders JOIN order_items ON orders.id = order_items.order_id WHERE orders.id = 1;
SELECT id FROM orders;
SELECT order_id FROM order_items;
DELETE FROM departments WHERE id = 1;
DELETE FROM departments WHERE id = 1;
SELECT COUNT(*) FROM employees;
DELETE FROM departments WHERE id = 1;
SELECT dept_id FROM employees;
DELETE FROM products WHERE price > (SELECT AVG(price) FROM products);
SELECT id FROM products ORDER BY id;
DELETE FROM sales s1 WHERE amount < ( SELECT AVG(amount) FROM sales s2 WHERE s2.product_id = s1.product_id );
SELECT id FROM sales ORDER BY id;
DELETE FROM products p WHERE NOT EXISTS ( SELECT 1 FROM orders o WHERE o.product_id = p.id );
SELECT id FROM products ORDER BY id;
DELETE FROM employees WHERE dept IN (SELECT name FROM closed_depts);
SELECT id FROM employees;
DELETE FROM numbers WHERE n < 5000;
SELECT COUNT(*) FROM numbers;
DELETE FROM logs l USING users u JOIN retention_policy r ON l.level = r.level WHERE l.user_id = u.id AND u.active = FALSE AND l.timestamp < (300 - r.days) RETURNING l.id, l.level;
DELETE FROM test;
SELECT COUNT(*) FROM test;
DELETE FROM queue WHERE priority = 1 LIMIT 2;
SELECT id FROM queue ORDER BY id;

-- ============================================================================
-- Test: test_delete_using_cte
-- Source: delete_enhancements_advanced_tdd.rs:209
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 10.0), (2, 50.0), (3, 100.0), (4, 25.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0), (3, 'Gizmo', 300.0);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, salary FLOAT64);
INSERT INTO employees VALUES (1, 'Alice', 50000.0), (2, 'Bob', 60000.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, price FLOAT64);
INSERT INTO products VALUES (1, 'Widget', 100.0), (2, 'Gadget', 200.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category_id INT64, name STRING);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, deprecated BOOL);
INSERT INTO items VALUES (1, 1, 'Item1'), (2, 2, 'Item2'), (3, 1, 'Item3');
INSERT INTO categories VALUES (1, TRUE), (2, FALSE);
DROP TABLE IF EXISTS active_orders;
CREATE TABLE active_orders (id INT64, total FLOAT64, created_at INT64);
DROP TABLE IF EXISTS archived_orders;
CREATE TABLE archived_orders (id INT64, total FLOAT64, created_at INT64, deleted_at INT64);
INSERT INTO active_orders VALUES (1, 100.0, 1000), (2, 200.0, 2000);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, customer_id INT64);
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (order_id INT64, product_id INT64);
INSERT INTO orders VALUES (1, 1), (2, 2);
INSERT INTO order_items VALUES (1, 100), (1, 200), (2, 300);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id));
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees ( id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id) ON DELETE CASCADE );
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1), (2, 1);
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees ( id INT64, dept_id INT64, FOREIGN KEY (dept_id) REFERENCES departments(id) ON DELETE SET NULL );
INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO employees VALUES (1, 1), (2, 1);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 10.0), (2, 50.0), (3, 100.0), (4, 25.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product_id INT64, amount FLOAT64);
INSERT INTO sales VALUES (1, 1, 100.0), (2, 1, 200.0), (3, 2, 150.0), (4, 2, 300.0);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (product_id INT64);
INSERT INTO products VALUES (1, 'Popular'), (2, 'Unpopular'), (3, 'Popular2');
INSERT INTO orders VALUES (1), (1), (3);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, dept STRING);
DROP TABLE IF EXISTS closed_depts;
CREATE TABLE closed_depts (name STRING);
INSERT INTO employees VALUES (1, 'Sales'), (2, 'Engineering'), (3, 'Marketing');
INSERT INTO closed_depts VALUES ('Sales'), ('Marketing');
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, level STRING, timestamp INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, active BOOL);
DROP TABLE IF EXISTS retention_policy;
CREATE TABLE retention_policy (level STRING, days INT64);
INSERT INTO logs VALUES (1, 1, 'DEBUG', 100), (2, 1, 'INFO', 200), (3, 2, 'ERROR', 150);
INSERT INTO users VALUES (1, FALSE), (2, TRUE);
INSERT INTO retention_policy VALUES ('DEBUG', 7), ('INFO', 30), ('ERROR', 90);
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
INSERT INTO test VALUES (1), (2), (3);
DROP TABLE IF EXISTS queue;
CREATE TABLE queue (id INT64, priority INT64);
INSERT INTO queue VALUES (1, 1), (2, 1), (3, 2), (4, 1);

WITH high_price AS ( SELECT AVG(price) * 2 as threshold FROM products ) DELETE FROM products p USING high_price h WHERE p.price > h.threshold;
SELECT id FROM products ORDER BY id;
DELETE FROM products WHERE price > 150.0 RETURNING *;
DELETE FROM employees WHERE id = 1 RETURNING id, name;
DELETE FROM products WHERE id <= 2 RETURNING id, name, price, price * 0.8 as discounted_price;
DELETE FROM products WHERE id = 999 RETURNING *;
DELETE FROM items i USING categories c WHERE i.category_id = c.id AND c.deprecated = TRUE RETURNING i.id, i.name, c.id as category_id;
DELETE FROM active_orders WHERE created_at < 1500 RETURNING id, total, created_at;
DELETE orders, order_items FROM orders JOIN order_items ON orders.id = order_items.order_id WHERE orders.id = 1;
SELECT id FROM orders;
SELECT order_id FROM order_items;
DELETE FROM departments WHERE id = 1;
DELETE FROM departments WHERE id = 1;
SELECT COUNT(*) FROM employees;
DELETE FROM departments WHERE id = 1;
SELECT dept_id FROM employees;
DELETE FROM products WHERE price > (SELECT AVG(price) FROM products);
SELECT id FROM products ORDER BY id;
DELETE FROM sales s1 WHERE amount < ( SELECT AVG(amount) FROM sales s2 WHERE s2.product_id = s1.product_id );
SELECT id FROM sales ORDER BY id;
DELETE FROM products p WHERE NOT EXISTS ( SELECT 1 FROM orders o WHERE o.product_id = p.id );
SELECT id FROM products ORDER BY id;
DELETE FROM employees WHERE dept IN (SELECT name FROM closed_depts);
SELECT id FROM employees;
DELETE FROM numbers WHERE n < 5000;
SELECT COUNT(*) FROM numbers;
DELETE FROM logs l USING users u JOIN retention_policy r ON l.level = r.level WHERE l.user_id = u.id AND u.active = FALSE AND l.timestamp < (300 - r.days) RETURNING l.id, l.level;
DELETE FROM test;
SELECT COUNT(*) FROM test;
DELETE FROM queue WHERE priority = 1 LIMIT 2;
SELECT id FROM queue ORDER BY id;

-- ============================================================================
-- Test: test_distinct_on_single_column
-- Source: distinct_on_comprehensive_tdd.rs:36
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, action STRING, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 'login', 100), \ (2, 1, 'click', 200), \ (3, 2, 'login', 150), \ (4, 2, 'logout', 300);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (id INT64, product STRING, date INT64, price FLOAT64);
INSERT INTO prices VALUES \ (1, 'widget', 1, 10.0), \ (2, 'widget', 2, 12.0), \ (3, 'widget', 3, 11.0), \ (4, 'gadget', 1, 20.0), \ (5, 'gadget', 2, 18.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, region STRING, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'North', 'widget', 100.0, 1), \ (2, 'North', 'widget', 150.0, 2), \ (3, 'North', 'gadget', 200.0, 1), \ (4, 'South', 'widget', 120.0, 1), \ (5, 'South', 'widget', 110.0, 2);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING, created_at INT64);
INSERT INTO users VALUES \ (1, 'alice@example.com', 100), \ (2, 'ALICE@EXAMPLE.COM', 200), \ (3, 'bob@example.com', 150);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value STRING);
INSERT INTO data VALUES \ (1, 'A', 'first'), \ (2, 'A', 'second'), \ (3, 'A', 'third');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, NULL, 10), \ (2, NULL, 20), \ (3, 'A', 30), \ (4, 'A', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES \ (1, 'A'), \ (2, NULL), \ (3, 'B'), \ (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, 'A', 100), \ (2, 'A', 200), \ (3, 'B', 150);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, type STRING, priority INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 'alert', 1, 100), \ (2, 1, 'info', 3, 200), \ (3, 1, 'alert', 2, 150);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (id INT64, player STRING, score INT64);
INSERT INTO scores VALUES \ (1, 'Alice', 100), \ (2, 'Alice', 150), \ (3, 'Bob', 200);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, user_id INT64, message STRING);
INSERT INTO logs VALUES \ (1, 'ERROR', 1, 'msg1'), \ (2, 'INFO', 1, 'msg2'), \ (3, 'ERROR', 2, 'msg3'), \ (4, 'WARN', 2, 'msg4');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64, date INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO orders VALUES \ (1, 1, 100.0, 1), \ (2, 1, 200.0, 2), \ (3, 2, 150.0, 1);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 100), \ (2, 1, 200), \ (3, 2, 150);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

SELECT DISTINCT ON (user_id) user_id, action, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC;
SELECT DISTINCT ON (product) product, price, date \ FROM prices \ ORDER BY product, date ASC;
SELECT DISTINCT ON (region, product) region, product, amount, date \ FROM sales \ ORDER BY region, product, date DESC;
SELECT DISTINCT ON (LOWER(email)) id, email, created_at \ FROM users \ ORDER BY LOWER(email), created_at DESC;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category, id;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (value) value, id \ FROM data \ ORDER BY value;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value ASC;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category NULLS FIRST, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value DESC;
SELECT DISTINCT ON (user_id) user_id, type, priority, timestamp \ FROM events \ ORDER BY user_id, priority ASC, timestamp DESC;
SELECT DISTINCT ON (player) player, score \ FROM scores \ ORDER BY player ASC, score DESC;
SELECT DISTINCT ON (user_id) user_id, message \ FROM logs \ WHERE level = 'ERROR' \ ORDER BY user_id, id ASC;
SELECT DISTINCT ON (users.id) users.name, orders.total, orders.date \ FROM orders \ JOIN users ON orders.user_id = users.id \ ORDER BY users.id, orders.date DESC;
SELECT DISTINCT ON (category) category, SUM(value) \ FROM data \ GROUP BY category \ ORDER BY category;
SELECT user_id, timestamp \ FROM ( \ SELECT DISTINCT ON (user_id) user_id, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC \ ) AS latest;
WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_distinct_on_returns_first_row_per_group
-- Source: distinct_on_comprehensive_tdd.rs:76
-- ============================================================================
DROP TABLE IF EXISTS prices;
CREATE TABLE prices (id INT64, product STRING, date INT64, price FLOAT64);
INSERT INTO prices VALUES \ (1, 'widget', 1, 10.0), \ (2, 'widget', 2, 12.0), \ (3, 'widget', 3, 11.0), \ (4, 'gadget', 1, 20.0), \ (5, 'gadget', 2, 18.0);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, region STRING, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'North', 'widget', 100.0, 1), \ (2, 'North', 'widget', 150.0, 2), \ (3, 'North', 'gadget', 200.0, 1), \ (4, 'South', 'widget', 120.0, 1), \ (5, 'South', 'widget', 110.0, 2);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING, created_at INT64);
INSERT INTO users VALUES \ (1, 'alice@example.com', 100), \ (2, 'ALICE@EXAMPLE.COM', 200), \ (3, 'bob@example.com', 150);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value STRING);
INSERT INTO data VALUES \ (1, 'A', 'first'), \ (2, 'A', 'second'), \ (3, 'A', 'third');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, NULL, 10), \ (2, NULL, 20), \ (3, 'A', 30), \ (4, 'A', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES \ (1, 'A'), \ (2, NULL), \ (3, 'B'), \ (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, 'A', 100), \ (2, 'A', 200), \ (3, 'B', 150);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, type STRING, priority INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 'alert', 1, 100), \ (2, 1, 'info', 3, 200), \ (3, 1, 'alert', 2, 150);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (id INT64, player STRING, score INT64);
INSERT INTO scores VALUES \ (1, 'Alice', 100), \ (2, 'Alice', 150), \ (3, 'Bob', 200);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, user_id INT64, message STRING);
INSERT INTO logs VALUES \ (1, 'ERROR', 1, 'msg1'), \ (2, 'INFO', 1, 'msg2'), \ (3, 'ERROR', 2, 'msg3'), \ (4, 'WARN', 2, 'msg4');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64, date INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO orders VALUES \ (1, 1, 100.0, 1), \ (2, 1, 200.0, 2), \ (3, 2, 150.0, 1);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 100), \ (2, 1, 200), \ (3, 2, 150);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

SELECT DISTINCT ON (product) product, price, date \ FROM prices \ ORDER BY product, date ASC;
SELECT DISTINCT ON (region, product) region, product, amount, date \ FROM sales \ ORDER BY region, product, date DESC;
SELECT DISTINCT ON (LOWER(email)) id, email, created_at \ FROM users \ ORDER BY LOWER(email), created_at DESC;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category, id;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (value) value, id \ FROM data \ ORDER BY value;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value ASC;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category NULLS FIRST, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value DESC;
SELECT DISTINCT ON (user_id) user_id, type, priority, timestamp \ FROM events \ ORDER BY user_id, priority ASC, timestamp DESC;
SELECT DISTINCT ON (player) player, score \ FROM scores \ ORDER BY player ASC, score DESC;
SELECT DISTINCT ON (user_id) user_id, message \ FROM logs \ WHERE level = 'ERROR' \ ORDER BY user_id, id ASC;
SELECT DISTINCT ON (users.id) users.name, orders.total, orders.date \ FROM orders \ JOIN users ON orders.user_id = users.id \ ORDER BY users.id, orders.date DESC;
SELECT DISTINCT ON (category) category, SUM(value) \ FROM data \ GROUP BY category \ ORDER BY category;
SELECT user_id, timestamp \ FROM ( \ SELECT DISTINCT ON (user_id) user_id, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC \ ) AS latest;
WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_distinct_on_multiple_columns
-- Source: distinct_on_comprehensive_tdd.rs:115
-- ============================================================================
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, region STRING, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'North', 'widget', 100.0, 1), \ (2, 'North', 'widget', 150.0, 2), \ (3, 'North', 'gadget', 200.0, 1), \ (4, 'South', 'widget', 120.0, 1), \ (5, 'South', 'widget', 110.0, 2);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING, created_at INT64);
INSERT INTO users VALUES \ (1, 'alice@example.com', 100), \ (2, 'ALICE@EXAMPLE.COM', 200), \ (3, 'bob@example.com', 150);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value STRING);
INSERT INTO data VALUES \ (1, 'A', 'first'), \ (2, 'A', 'second'), \ (3, 'A', 'third');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, NULL, 10), \ (2, NULL, 20), \ (3, 'A', 30), \ (4, 'A', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES \ (1, 'A'), \ (2, NULL), \ (3, 'B'), \ (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, 'A', 100), \ (2, 'A', 200), \ (3, 'B', 150);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, type STRING, priority INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 'alert', 1, 100), \ (2, 1, 'info', 3, 200), \ (3, 1, 'alert', 2, 150);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (id INT64, player STRING, score INT64);
INSERT INTO scores VALUES \ (1, 'Alice', 100), \ (2, 'Alice', 150), \ (3, 'Bob', 200);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, user_id INT64, message STRING);
INSERT INTO logs VALUES \ (1, 'ERROR', 1, 'msg1'), \ (2, 'INFO', 1, 'msg2'), \ (3, 'ERROR', 2, 'msg3'), \ (4, 'WARN', 2, 'msg4');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64, date INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO orders VALUES \ (1, 1, 100.0, 1), \ (2, 1, 200.0, 2), \ (3, 2, 150.0, 1);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 100), \ (2, 1, 200), \ (3, 2, 150);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

SELECT DISTINCT ON (region, product) region, product, amount, date \ FROM sales \ ORDER BY region, product, date DESC;
SELECT DISTINCT ON (LOWER(email)) id, email, created_at \ FROM users \ ORDER BY LOWER(email), created_at DESC;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category, id;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (value) value, id \ FROM data \ ORDER BY value;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value ASC;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category NULLS FIRST, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value DESC;
SELECT DISTINCT ON (user_id) user_id, type, priority, timestamp \ FROM events \ ORDER BY user_id, priority ASC, timestamp DESC;
SELECT DISTINCT ON (player) player, score \ FROM scores \ ORDER BY player ASC, score DESC;
SELECT DISTINCT ON (user_id) user_id, message \ FROM logs \ WHERE level = 'ERROR' \ ORDER BY user_id, id ASC;
SELECT DISTINCT ON (users.id) users.name, orders.total, orders.date \ FROM orders \ JOIN users ON orders.user_id = users.id \ ORDER BY users.id, orders.date DESC;
SELECT DISTINCT ON (category) category, SUM(value) \ FROM data \ GROUP BY category \ ORDER BY category;
SELECT user_id, timestamp \ FROM ( \ SELECT DISTINCT ON (user_id) user_id, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC \ ) AS latest;
WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_distinct_on_with_expression
-- Source: distinct_on_comprehensive_tdd.rs:151
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING, created_at INT64);
INSERT INTO users VALUES \ (1, 'alice@example.com', 100), \ (2, 'ALICE@EXAMPLE.COM', 200), \ (3, 'bob@example.com', 150);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value STRING);
INSERT INTO data VALUES \ (1, 'A', 'first'), \ (2, 'A', 'second'), \ (3, 'A', 'third');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, NULL, 10), \ (2, NULL, 20), \ (3, 'A', 30), \ (4, 'A', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES \ (1, 'A'), \ (2, NULL), \ (3, 'B'), \ (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, 'A', 100), \ (2, 'A', 200), \ (3, 'B', 150);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, type STRING, priority INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 'alert', 1, 100), \ (2, 1, 'info', 3, 200), \ (3, 1, 'alert', 2, 150);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (id INT64, player STRING, score INT64);
INSERT INTO scores VALUES \ (1, 'Alice', 100), \ (2, 'Alice', 150), \ (3, 'Bob', 200);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, user_id INT64, message STRING);
INSERT INTO logs VALUES \ (1, 'ERROR', 1, 'msg1'), \ (2, 'INFO', 1, 'msg2'), \ (3, 'ERROR', 2, 'msg3'), \ (4, 'WARN', 2, 'msg4');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64, date INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO orders VALUES \ (1, 1, 100.0, 1), \ (2, 1, 200.0, 2), \ (3, 2, 150.0, 1);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 100), \ (2, 1, 200), \ (3, 2, 150);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

SELECT DISTINCT ON (LOWER(email)) id, email, created_at \ FROM users \ ORDER BY LOWER(email), created_at DESC;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category, id;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (value) value, id \ FROM data \ ORDER BY value;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value ASC;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category NULLS FIRST, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value DESC;
SELECT DISTINCT ON (user_id) user_id, type, priority, timestamp \ FROM events \ ORDER BY user_id, priority ASC, timestamp DESC;
SELECT DISTINCT ON (player) player, score \ FROM scores \ ORDER BY player ASC, score DESC;
SELECT DISTINCT ON (user_id) user_id, message \ FROM logs \ WHERE level = 'ERROR' \ ORDER BY user_id, id ASC;
SELECT DISTINCT ON (users.id) users.name, orders.total, orders.date \ FROM orders \ JOIN users ON orders.user_id = users.id \ ORDER BY users.id, orders.date DESC;
SELECT DISTINCT ON (category) category, SUM(value) \ FROM data \ GROUP BY category \ ORDER BY category;
SELECT user_id, timestamp \ FROM ( \ SELECT DISTINCT ON (user_id) user_id, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC \ ) AS latest;
WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_distinct_on_empty_result
-- Source: distinct_on_comprehensive_tdd.rs:189
-- ============================================================================
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value STRING);
INSERT INTO data VALUES \ (1, 'A', 'first'), \ (2, 'A', 'second'), \ (3, 'A', 'third');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, NULL, 10), \ (2, NULL, 20), \ (3, 'A', 30), \ (4, 'A', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES \ (1, 'A'), \ (2, NULL), \ (3, 'B'), \ (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, 'A', 100), \ (2, 'A', 200), \ (3, 'B', 150);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, type STRING, priority INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 'alert', 1, 100), \ (2, 1, 'info', 3, 200), \ (3, 1, 'alert', 2, 150);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (id INT64, player STRING, score INT64);
INSERT INTO scores VALUES \ (1, 'Alice', 100), \ (2, 'Alice', 150), \ (3, 'Bob', 200);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, user_id INT64, message STRING);
INSERT INTO logs VALUES \ (1, 'ERROR', 1, 'msg1'), \ (2, 'INFO', 1, 'msg2'), \ (3, 'ERROR', 2, 'msg3'), \ (4, 'WARN', 2, 'msg4');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64, date INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO orders VALUES \ (1, 1, 100.0, 1), \ (2, 1, 200.0, 2), \ (3, 2, 150.0, 1);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 100), \ (2, 1, 200), \ (3, 2, 150);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category, id;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (value) value, id \ FROM data \ ORDER BY value;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value ASC;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category NULLS FIRST, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value DESC;
SELECT DISTINCT ON (user_id) user_id, type, priority, timestamp \ FROM events \ ORDER BY user_id, priority ASC, timestamp DESC;
SELECT DISTINCT ON (player) player, score \ FROM scores \ ORDER BY player ASC, score DESC;
SELECT DISTINCT ON (user_id) user_id, message \ FROM logs \ WHERE level = 'ERROR' \ ORDER BY user_id, id ASC;
SELECT DISTINCT ON (users.id) users.name, orders.total, orders.date \ FROM orders \ JOIN users ON orders.user_id = users.id \ ORDER BY users.id, orders.date DESC;
SELECT DISTINCT ON (category) category, SUM(value) \ FROM data \ GROUP BY category \ ORDER BY category;
SELECT user_id, timestamp \ FROM ( \ SELECT DISTINCT ON (user_id) user_id, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC \ ) AS latest;
WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_distinct_on_single_row
-- Source: distinct_on_comprehensive_tdd.rs:209
-- ============================================================================
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES (1, 'A');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value STRING);
INSERT INTO data VALUES \ (1, 'A', 'first'), \ (2, 'A', 'second'), \ (3, 'A', 'third');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, NULL, 10), \ (2, NULL, 20), \ (3, 'A', 30), \ (4, 'A', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES \ (1, 'A'), \ (2, NULL), \ (3, 'B'), \ (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, 'A', 100), \ (2, 'A', 200), \ (3, 'B', 150);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, type STRING, priority INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 'alert', 1, 100), \ (2, 1, 'info', 3, 200), \ (3, 1, 'alert', 2, 150);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (id INT64, player STRING, score INT64);
INSERT INTO scores VALUES \ (1, 'Alice', 100), \ (2, 'Alice', 150), \ (3, 'Bob', 200);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, user_id INT64, message STRING);
INSERT INTO logs VALUES \ (1, 'ERROR', 1, 'msg1'), \ (2, 'INFO', 1, 'msg2'), \ (3, 'ERROR', 2, 'msg3'), \ (4, 'WARN', 2, 'msg4');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64, date INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO orders VALUES \ (1, 1, 100.0, 1), \ (2, 1, 200.0, 2), \ (3, 2, 150.0, 1);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 100), \ (2, 1, 200), \ (3, 2, 150);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (value) value, id \ FROM data \ ORDER BY value;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value ASC;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category NULLS FIRST, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value DESC;
SELECT DISTINCT ON (user_id) user_id, type, priority, timestamp \ FROM events \ ORDER BY user_id, priority ASC, timestamp DESC;
SELECT DISTINCT ON (player) player, score \ FROM scores \ ORDER BY player ASC, score DESC;
SELECT DISTINCT ON (user_id) user_id, message \ FROM logs \ WHERE level = 'ERROR' \ ORDER BY user_id, id ASC;
SELECT DISTINCT ON (users.id) users.name, orders.total, orders.date \ FROM orders \ JOIN users ON orders.user_id = users.id \ ORDER BY users.id, orders.date DESC;
SELECT DISTINCT ON (category) category, SUM(value) \ FROM data \ GROUP BY category \ ORDER BY category;
SELECT user_id, timestamp \ FROM ( \ SELECT DISTINCT ON (user_id) user_id, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC \ ) AS latest;
WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_distinct_on_all_unique
-- Source: distinct_on_comprehensive_tdd.rs:232
-- ============================================================================
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value STRING);
INSERT INTO data VALUES (1, 'A'), (2, 'B'), (3, 'C');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value STRING);
INSERT INTO data VALUES \ (1, 'A', 'first'), \ (2, 'A', 'second'), \ (3, 'A', 'third');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, NULL, 10), \ (2, NULL, 20), \ (3, 'A', 30), \ (4, 'A', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES \ (1, 'A'), \ (2, NULL), \ (3, 'B'), \ (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, 'A', 100), \ (2, 'A', 200), \ (3, 'B', 150);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, type STRING, priority INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 'alert', 1, 100), \ (2, 1, 'info', 3, 200), \ (3, 1, 'alert', 2, 150);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (id INT64, player STRING, score INT64);
INSERT INTO scores VALUES \ (1, 'Alice', 100), \ (2, 'Alice', 150), \ (3, 'Bob', 200);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, user_id INT64, message STRING);
INSERT INTO logs VALUES \ (1, 'ERROR', 1, 'msg1'), \ (2, 'INFO', 1, 'msg2'), \ (3, 'ERROR', 2, 'msg3'), \ (4, 'WARN', 2, 'msg4');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64, date INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO orders VALUES \ (1, 1, 100.0, 1), \ (2, 1, 200.0, 2), \ (3, 2, 150.0, 1);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 100), \ (2, 1, 200), \ (3, 2, 150);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

SELECT DISTINCT ON (value) value, id \ FROM data \ ORDER BY value;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value ASC;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category NULLS FIRST, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value DESC;
SELECT DISTINCT ON (user_id) user_id, type, priority, timestamp \ FROM events \ ORDER BY user_id, priority ASC, timestamp DESC;
SELECT DISTINCT ON (player) player, score \ FROM scores \ ORDER BY player ASC, score DESC;
SELECT DISTINCT ON (user_id) user_id, message \ FROM logs \ WHERE level = 'ERROR' \ ORDER BY user_id, id ASC;
SELECT DISTINCT ON (users.id) users.name, orders.total, orders.date \ FROM orders \ JOIN users ON orders.user_id = users.id \ ORDER BY users.id, orders.date DESC;
SELECT DISTINCT ON (category) category, SUM(value) \ FROM data \ GROUP BY category \ ORDER BY category;
SELECT user_id, timestamp \ FROM ( \ SELECT DISTINCT ON (user_id) user_id, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC \ ) AS latest;
WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_distinct_on_all_same
-- Source: distinct_on_comprehensive_tdd.rs:255
-- ============================================================================
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value STRING);
INSERT INTO data VALUES \ (1, 'A', 'first'), \ (2, 'A', 'second'), \ (3, 'A', 'third');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, NULL, 10), \ (2, NULL, 20), \ (3, 'A', 30), \ (4, 'A', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES \ (1, 'A'), \ (2, NULL), \ (3, 'B'), \ (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, 'A', 100), \ (2, 'A', 200), \ (3, 'B', 150);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, type STRING, priority INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 'alert', 1, 100), \ (2, 1, 'info', 3, 200), \ (3, 1, 'alert', 2, 150);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (id INT64, player STRING, score INT64);
INSERT INTO scores VALUES \ (1, 'Alice', 100), \ (2, 'Alice', 150), \ (3, 'Bob', 200);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, user_id INT64, message STRING);
INSERT INTO logs VALUES \ (1, 'ERROR', 1, 'msg1'), \ (2, 'INFO', 1, 'msg2'), \ (3, 'ERROR', 2, 'msg3'), \ (4, 'WARN', 2, 'msg4');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64, date INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO orders VALUES \ (1, 1, 100.0, 1), \ (2, 1, 200.0, 2), \ (3, 2, 150.0, 1);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 100), \ (2, 1, 200), \ (3, 2, 150);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value ASC;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category NULLS FIRST, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value DESC;
SELECT DISTINCT ON (user_id) user_id, type, priority, timestamp \ FROM events \ ORDER BY user_id, priority ASC, timestamp DESC;
SELECT DISTINCT ON (player) player, score \ FROM scores \ ORDER BY player ASC, score DESC;
SELECT DISTINCT ON (user_id) user_id, message \ FROM logs \ WHERE level = 'ERROR' \ ORDER BY user_id, id ASC;
SELECT DISTINCT ON (users.id) users.name, orders.total, orders.date \ FROM orders \ JOIN users ON orders.user_id = users.id \ ORDER BY users.id, orders.date DESC;
SELECT DISTINCT ON (category) category, SUM(value) \ FROM data \ GROUP BY category \ ORDER BY category;
SELECT user_id, timestamp \ FROM ( \ SELECT DISTINCT ON (user_id) user_id, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC \ ) AS latest;
WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_distinct_on_with_null_values
-- Source: distinct_on_comprehensive_tdd.rs:285
-- ============================================================================
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, NULL, 10), \ (2, NULL, 20), \ (3, 'A', 30), \ (4, 'A', 40);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES \ (1, 'A'), \ (2, NULL), \ (3, 'B'), \ (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, 'A', 100), \ (2, 'A', 200), \ (3, 'B', 150);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, type STRING, priority INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 'alert', 1, 100), \ (2, 1, 'info', 3, 200), \ (3, 1, 'alert', 2, 150);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (id INT64, player STRING, score INT64);
INSERT INTO scores VALUES \ (1, 'Alice', 100), \ (2, 'Alice', 150), \ (3, 'Bob', 200);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, user_id INT64, message STRING);
INSERT INTO logs VALUES \ (1, 'ERROR', 1, 'msg1'), \ (2, 'INFO', 1, 'msg2'), \ (3, 'ERROR', 2, 'msg3'), \ (4, 'WARN', 2, 'msg4');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64, date INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO orders VALUES \ (1, 1, 100.0, 1), \ (2, 1, 200.0, 2), \ (3, 2, 150.0, 1);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 100), \ (2, 1, 200), \ (3, 2, 150);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value ASC;
SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category NULLS FIRST, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value DESC;
SELECT DISTINCT ON (user_id) user_id, type, priority, timestamp \ FROM events \ ORDER BY user_id, priority ASC, timestamp DESC;
SELECT DISTINCT ON (player) player, score \ FROM scores \ ORDER BY player ASC, score DESC;
SELECT DISTINCT ON (user_id) user_id, message \ FROM logs \ WHERE level = 'ERROR' \ ORDER BY user_id, id ASC;
SELECT DISTINCT ON (users.id) users.name, orders.total, orders.date \ FROM orders \ JOIN users ON orders.user_id = users.id \ ORDER BY users.id, orders.date DESC;
SELECT DISTINCT ON (category) category, SUM(value) \ FROM data \ GROUP BY category \ ORDER BY category;
SELECT user_id, timestamp \ FROM ( \ SELECT DISTINCT ON (user_id) user_id, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC \ ) AS latest;
WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_distinct_on_null_sorting
-- Source: distinct_on_comprehensive_tdd.rs:323
-- ============================================================================
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
INSERT INTO data VALUES \ (1, 'A'), \ (2, NULL), \ (3, 'B'), \ (4, NULL);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, 'A', 100), \ (2, 'A', 200), \ (3, 'B', 150);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, type STRING, priority INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 'alert', 1, 100), \ (2, 1, 'info', 3, 200), \ (3, 1, 'alert', 2, 150);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (id INT64, player STRING, score INT64);
INSERT INTO scores VALUES \ (1, 'Alice', 100), \ (2, 'Alice', 150), \ (3, 'Bob', 200);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, user_id INT64, message STRING);
INSERT INTO logs VALUES \ (1, 'ERROR', 1, 'msg1'), \ (2, 'INFO', 1, 'msg2'), \ (3, 'ERROR', 2, 'msg3'), \ (4, 'WARN', 2, 'msg4');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64, date INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO orders VALUES \ (1, 1, 100.0, 1), \ (2, 1, 200.0, 2), \ (3, 2, 150.0, 1);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 100), \ (2, 1, 200), \ (3, 2, 150);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

SELECT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category NULLS FIRST, id ASC;
SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value DESC;
SELECT DISTINCT ON (user_id) user_id, type, priority, timestamp \ FROM events \ ORDER BY user_id, priority ASC, timestamp DESC;
SELECT DISTINCT ON (player) player, score \ FROM scores \ ORDER BY player ASC, score DESC;
SELECT DISTINCT ON (user_id) user_id, message \ FROM logs \ WHERE level = 'ERROR' \ ORDER BY user_id, id ASC;
SELECT DISTINCT ON (users.id) users.name, orders.total, orders.date \ FROM orders \ JOIN users ON orders.user_id = users.id \ ORDER BY users.id, orders.date DESC;
SELECT DISTINCT ON (category) category, SUM(value) \ FROM data \ GROUP BY category \ ORDER BY category;
SELECT user_id, timestamp \ FROM ( \ SELECT DISTINCT ON (user_id) user_id, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC \ ) AS latest;
WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_distinct_on_order_by_same_column
-- Source: distinct_on_comprehensive_tdd.rs:358
-- ============================================================================
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
INSERT INTO data VALUES \ (1, 'A', 100), \ (2, 'A', 200), \ (3, 'B', 150);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, type STRING, priority INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 'alert', 1, 100), \ (2, 1, 'info', 3, 200), \ (3, 1, 'alert', 2, 150);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (id INT64, player STRING, score INT64);
INSERT INTO scores VALUES \ (1, 'Alice', 100), \ (2, 'Alice', 150), \ (3, 'Bob', 200);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, user_id INT64, message STRING);
INSERT INTO logs VALUES \ (1, 'ERROR', 1, 'msg1'), \ (2, 'INFO', 1, 'msg2'), \ (3, 'ERROR', 2, 'msg3'), \ (4, 'WARN', 2, 'msg4');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64, date INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO orders VALUES \ (1, 1, 100.0, 1), \ (2, 1, 200.0, 2), \ (3, 2, 150.0, 1);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 100), \ (2, 1, 200), \ (3, 2, 150);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

SELECT DISTINCT ON (category) category, value \ FROM data \ ORDER BY category, value DESC;
SELECT DISTINCT ON (user_id) user_id, type, priority, timestamp \ FROM events \ ORDER BY user_id, priority ASC, timestamp DESC;
SELECT DISTINCT ON (player) player, score \ FROM scores \ ORDER BY player ASC, score DESC;
SELECT DISTINCT ON (user_id) user_id, message \ FROM logs \ WHERE level = 'ERROR' \ ORDER BY user_id, id ASC;
SELECT DISTINCT ON (users.id) users.name, orders.total, orders.date \ FROM orders \ JOIN users ON orders.user_id = users.id \ ORDER BY users.id, orders.date DESC;
SELECT DISTINCT ON (category) category, SUM(value) \ FROM data \ GROUP BY category \ ORDER BY category;
SELECT user_id, timestamp \ FROM ( \ SELECT DISTINCT ON (user_id) user_id, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC \ ) AS latest;
WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_distinct_on_order_by_additional_columns
-- Source: distinct_on_comprehensive_tdd.rs:390
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, type STRING, priority INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 'alert', 1, 100), \ (2, 1, 'info', 3, 200), \ (3, 1, 'alert', 2, 150);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (id INT64, player STRING, score INT64);
INSERT INTO scores VALUES \ (1, 'Alice', 100), \ (2, 'Alice', 150), \ (3, 'Bob', 200);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, user_id INT64, message STRING);
INSERT INTO logs VALUES \ (1, 'ERROR', 1, 'msg1'), \ (2, 'INFO', 1, 'msg2'), \ (3, 'ERROR', 2, 'msg3'), \ (4, 'WARN', 2, 'msg4');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64, date INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO orders VALUES \ (1, 1, 100.0, 1), \ (2, 1, 200.0, 2), \ (3, 2, 150.0, 1);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 100), \ (2, 1, 200), \ (3, 2, 150);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

SELECT DISTINCT ON (user_id) user_id, type, priority, timestamp \ FROM events \ ORDER BY user_id, priority ASC, timestamp DESC;
SELECT DISTINCT ON (player) player, score \ FROM scores \ ORDER BY player ASC, score DESC;
SELECT DISTINCT ON (user_id) user_id, message \ FROM logs \ WHERE level = 'ERROR' \ ORDER BY user_id, id ASC;
SELECT DISTINCT ON (users.id) users.name, orders.total, orders.date \ FROM orders \ JOIN users ON orders.user_id = users.id \ ORDER BY users.id, orders.date DESC;
SELECT DISTINCT ON (category) category, SUM(value) \ FROM data \ GROUP BY category \ ORDER BY category;
SELECT user_id, timestamp \ FROM ( \ SELECT DISTINCT ON (user_id) user_id, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC \ ) AS latest;
WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_distinct_on_order_by_desc
-- Source: distinct_on_comprehensive_tdd.rs:422
-- ============================================================================
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (id INT64, player STRING, score INT64);
INSERT INTO scores VALUES \ (1, 'Alice', 100), \ (2, 'Alice', 150), \ (3, 'Bob', 200);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, user_id INT64, message STRING);
INSERT INTO logs VALUES \ (1, 'ERROR', 1, 'msg1'), \ (2, 'INFO', 1, 'msg2'), \ (3, 'ERROR', 2, 'msg3'), \ (4, 'WARN', 2, 'msg4');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64, date INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO orders VALUES \ (1, 1, 100.0, 1), \ (2, 1, 200.0, 2), \ (3, 2, 150.0, 1);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 100), \ (2, 1, 200), \ (3, 2, 150);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

SELECT DISTINCT ON (player) player, score \ FROM scores \ ORDER BY player ASC, score DESC;
SELECT DISTINCT ON (user_id) user_id, message \ FROM logs \ WHERE level = 'ERROR' \ ORDER BY user_id, id ASC;
SELECT DISTINCT ON (users.id) users.name, orders.total, orders.date \ FROM orders \ JOIN users ON orders.user_id = users.id \ ORDER BY users.id, orders.date DESC;
SELECT DISTINCT ON (category) category, SUM(value) \ FROM data \ GROUP BY category \ ORDER BY category;
SELECT user_id, timestamp \ FROM ( \ SELECT DISTINCT ON (user_id) user_id, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC \ ) AS latest;
WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_distinct_on_with_where_clause
-- Source: distinct_on_comprehensive_tdd.rs:458
-- ============================================================================
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, user_id INT64, message STRING);
INSERT INTO logs VALUES \ (1, 'ERROR', 1, 'msg1'), \ (2, 'INFO', 1, 'msg2'), \ (3, 'ERROR', 2, 'msg3'), \ (4, 'WARN', 2, 'msg4');
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64, date INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO orders VALUES \ (1, 1, 100.0, 1), \ (2, 1, 200.0, 2), \ (3, 2, 150.0, 1);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 100), \ (2, 1, 200), \ (3, 2, 150);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

SELECT DISTINCT ON (user_id) user_id, message \ FROM logs \ WHERE level = 'ERROR' \ ORDER BY user_id, id ASC;
SELECT DISTINCT ON (users.id) users.name, orders.total, orders.date \ FROM orders \ JOIN users ON orders.user_id = users.id \ ORDER BY users.id, orders.date DESC;
SELECT DISTINCT ON (category) category, SUM(value) \ FROM data \ GROUP BY category \ ORDER BY category;
SELECT user_id, timestamp \ FROM ( \ SELECT DISTINCT ON (user_id) user_id, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC \ ) AS latest;
WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_distinct_on_with_join
-- Source: distinct_on_comprehensive_tdd.rs:488
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, total FLOAT64, date INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO orders VALUES \ (1, 1, 100.0, 1), \ (2, 1, 200.0, 2), \ (3, 2, 150.0, 1);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 100), \ (2, 1, 200), \ (3, 2, 150);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

SELECT DISTINCT ON (users.id) users.name, orders.total, orders.date \ FROM orders \ JOIN users ON orders.user_id = users.id \ ORDER BY users.id, orders.date DESC;
SELECT DISTINCT ON (category) category, SUM(value) \ FROM data \ GROUP BY category \ ORDER BY category;
SELECT user_id, timestamp \ FROM ( \ SELECT DISTINCT ON (user_id) user_id, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC \ ) AS latest;
WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_distinct_on_with_group_by_error
-- Source: distinct_on_comprehensive_tdd.rs:528
-- ============================================================================
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING, value INT64);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 100), \ (2, 1, 200), \ (3, 2, 150);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

SELECT DISTINCT ON (category) category, SUM(value) \ FROM data \ GROUP BY category \ ORDER BY category;
SELECT user_id, timestamp \ FROM ( \ SELECT DISTINCT ON (user_id) user_id, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC \ ) AS latest;
WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_distinct_on_in_subquery
-- Source: distinct_on_comprehensive_tdd.rs:548
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, user_id INT64, timestamp INT64);
INSERT INTO events VALUES \ (1, 1, 100), \ (2, 1, 200), \ (3, 2, 150);
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

SELECT user_id, timestamp \ FROM ( \ SELECT DISTINCT ON (user_id) user_id, timestamp \ FROM events \ ORDER BY user_id, timestamp DESC \ ) AS latest;
WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_distinct_on_with_cte
-- Source: distinct_on_comprehensive_tdd.rs:579
-- ============================================================================
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (id INT64, product STRING, amount FLOAT64, date INT64);
INSERT INTO sales VALUES \ (1, 'widget', 100.0, 1), \ (2, 'widget', 200.0, 2), \ (3, 'gadget', 150.0, 1);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, a STRING, b STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, category STRING);
DROP TABLE IF EXISTS user_snapshots;
CREATE TABLE user_snapshots (id INT64, email STRING, name STRING, updated_at INT64);
INSERT INTO user_snapshots VALUES \ (1, 'alice@example.com', 'Alice A', 1), \ (2, 'alice@example.com', 'Alice B', 2), \ (3, 'bob@example.com', 'Bob', 1), \ (4, 'alice@example.com', 'Alice C', 3);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, category STRING, sales INT64);
INSERT INTO products VALUES \ (1, 'electronics', 1000), \ (2, 'electronics', 1500), \ (3, 'books', 500), \ (4, 'books', 800);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'A', 20), \ (3, 'B', 30), \ (4, 'C', 40);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, category STRING, value INT64);
INSERT INTO items VALUES \ (1, 'A', 10), \ (2, 'B', 20), \ (3, 'C', 30);

WITH latest_sales AS ( \ SELECT DISTINCT ON (product) product, amount, date \ FROM sales \ ORDER BY product, date DESC \ ) \ SELECT * FROM latest_sales ORDER BY product;
SELECT DISTINCT ON (a) a, b \ FROM data \ ORDER BY b;
SELECT DISTINCT ON (category) category, id \ FROM data;
SELECT DISTINCT ON (nonexistent) category, id \ FROM data \ ORDER BY nonexistent;
SELECT DISTINCT DISTINCT ON (category) category, id \ FROM data \ ORDER BY category;
SELECT DISTINCT ON (email) email, name, updated_at \ FROM user_snapshots \ ORDER BY email, updated_at DESC;
SELECT DISTINCT ON (category) category, id, sales \ FROM products \ ORDER BY category, sales DESC;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category, value DESC \ LIMIT 2;
SELECT DISTINCT ON (category) category, value \ FROM items \ ORDER BY category \ OFFSET 1;

-- ============================================================================
-- Test: test_basic_upsert_single_column_conflict
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:45
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', 'alice.new@example.com') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64 PRIMARY KEY, name STRING, quantity INT64);
INSERT INTO products VALUES (1, 'Widget', 10);
INSERT INTO products VALUES (1, 'Widget', 5) ON CONFLICT (id) DO UPDATE SET quantity = products.quantity + EXCLUDED.quantity;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', 30);
INSERT INTO users VALUES (1, 'Alice Updated', 'new@example.com', 35) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob') ON CONFLICT (id) DO NOTHING;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob'), (3, 'Charlie') ON CONFLICT (id) DO NOTHING;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, 'alice@example.com', 'Alice');
INSERT INTO users VALUES (2, 'alice@example.com', 'Alice Duplicate') ON CONFLICT DO NOTHING;
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items ( order_id INT64, product_id INT64, quantity INT64, PRIMARY KEY (order_id, product_id) );
INSERT INTO order_items VALUES (1, 101, 5);
INSERT INTO order_items VALUES (1, 101, 10) ON CONFLICT (order_id, product_id) DO UPDATE SET quantity = EXCLUDED.quantity;
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items ( order_id INT64, product_id INT64, quantity INT64, PRIMARY KEY (order_id, product_id) );
INSERT INTO order_items VALUES (1, 101, 5);
INSERT INTO order_items VALUES (1, 102, 10) ON CONFLICT (order_id, product_id) DO UPDATE SET quantity = EXCLUDED.quantity;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, 'alice@example.com', 'Alice');
INSERT INTO users VALUES (2, 'alice@example.com', 'Alice Updated') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS products;
CREATE TABLE products ( id INT64 PRIMARY KEY, name STRING, price FLOAT64, stock INT64 );
INSERT INTO products VALUES (1, 'Widget', 10.0, 100);
INSERT INTO products VALUES (1, 'Widget', 15.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
INSERT INTO products VALUES (1, 'Widget', 5.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, active BOOL );
INSERT INTO users VALUES (1, 'Alice', NULL);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name WHERE products.active = TRUE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1 RETURNING id, name, version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob'), (2, 'Charlie') ON CONFLICT (id) DO NOTHING RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, NULL, 'Alice');
INSERT INTO users VALUES (2, NULL, 'Bob') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT id, name, email FROM users WHERE id = 1;
SELECT COUNT(*) FROM users;
SELECT quantity FROM products WHERE id = 1;
SELECT name, email, age FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT COUNT(*) FROM users;
SELECT quantity FROM order_items WHERE order_id = 1 AND product_id = 101;
SELECT COUNT(*) FROM order_items;
SELECT id, name FROM users WHERE email = 'alice@example.com';
SELECT price FROM products WHERE id = 1;
SELECT price FROM products WHERE id = 1;
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users;
SELECT id, name FROM users;
SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_upsert_inserts_when_no_conflict
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:83
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64 PRIMARY KEY, name STRING, quantity INT64);
INSERT INTO products VALUES (1, 'Widget', 10);
INSERT INTO products VALUES (1, 'Widget', 5) ON CONFLICT (id) DO UPDATE SET quantity = products.quantity + EXCLUDED.quantity;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', 30);
INSERT INTO users VALUES (1, 'Alice Updated', 'new@example.com', 35) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob') ON CONFLICT (id) DO NOTHING;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob'), (3, 'Charlie') ON CONFLICT (id) DO NOTHING;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, 'alice@example.com', 'Alice');
INSERT INTO users VALUES (2, 'alice@example.com', 'Alice Duplicate') ON CONFLICT DO NOTHING;
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items ( order_id INT64, product_id INT64, quantity INT64, PRIMARY KEY (order_id, product_id) );
INSERT INTO order_items VALUES (1, 101, 5);
INSERT INTO order_items VALUES (1, 101, 10) ON CONFLICT (order_id, product_id) DO UPDATE SET quantity = EXCLUDED.quantity;
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items ( order_id INT64, product_id INT64, quantity INT64, PRIMARY KEY (order_id, product_id) );
INSERT INTO order_items VALUES (1, 101, 5);
INSERT INTO order_items VALUES (1, 102, 10) ON CONFLICT (order_id, product_id) DO UPDATE SET quantity = EXCLUDED.quantity;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, 'alice@example.com', 'Alice');
INSERT INTO users VALUES (2, 'alice@example.com', 'Alice Updated') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS products;
CREATE TABLE products ( id INT64 PRIMARY KEY, name STRING, price FLOAT64, stock INT64 );
INSERT INTO products VALUES (1, 'Widget', 10.0, 100);
INSERT INTO products VALUES (1, 'Widget', 15.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
INSERT INTO products VALUES (1, 'Widget', 5.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, active BOOL );
INSERT INTO users VALUES (1, 'Alice', NULL);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name WHERE products.active = TRUE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1 RETURNING id, name, version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob'), (2, 'Charlie') ON CONFLICT (id) DO NOTHING RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, NULL, 'Alice');
INSERT INTO users VALUES (2, NULL, 'Bob') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT COUNT(*) FROM users;
SELECT quantity FROM products WHERE id = 1;
SELECT name, email, age FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT COUNT(*) FROM users;
SELECT quantity FROM order_items WHERE order_id = 1 AND product_id = 101;
SELECT COUNT(*) FROM order_items;
SELECT id, name FROM users WHERE email = 'alice@example.com';
SELECT price FROM products WHERE id = 1;
SELECT price FROM products WHERE id = 1;
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users;
SELECT id, name FROM users;
SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_upsert_with_excluded_reference
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:111
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64 PRIMARY KEY, name STRING, quantity INT64);
INSERT INTO products VALUES (1, 'Widget', 10);
INSERT INTO products VALUES (1, 'Widget', 5) ON CONFLICT (id) DO UPDATE SET quantity = products.quantity + EXCLUDED.quantity;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', 30);
INSERT INTO users VALUES (1, 'Alice Updated', 'new@example.com', 35) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob') ON CONFLICT (id) DO NOTHING;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob'), (3, 'Charlie') ON CONFLICT (id) DO NOTHING;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, 'alice@example.com', 'Alice');
INSERT INTO users VALUES (2, 'alice@example.com', 'Alice Duplicate') ON CONFLICT DO NOTHING;
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items ( order_id INT64, product_id INT64, quantity INT64, PRIMARY KEY (order_id, product_id) );
INSERT INTO order_items VALUES (1, 101, 5);
INSERT INTO order_items VALUES (1, 101, 10) ON CONFLICT (order_id, product_id) DO UPDATE SET quantity = EXCLUDED.quantity;
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items ( order_id INT64, product_id INT64, quantity INT64, PRIMARY KEY (order_id, product_id) );
INSERT INTO order_items VALUES (1, 101, 5);
INSERT INTO order_items VALUES (1, 102, 10) ON CONFLICT (order_id, product_id) DO UPDATE SET quantity = EXCLUDED.quantity;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, 'alice@example.com', 'Alice');
INSERT INTO users VALUES (2, 'alice@example.com', 'Alice Updated') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS products;
CREATE TABLE products ( id INT64 PRIMARY KEY, name STRING, price FLOAT64, stock INT64 );
INSERT INTO products VALUES (1, 'Widget', 10.0, 100);
INSERT INTO products VALUES (1, 'Widget', 15.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
INSERT INTO products VALUES (1, 'Widget', 5.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, active BOOL );
INSERT INTO users VALUES (1, 'Alice', NULL);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name WHERE products.active = TRUE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1 RETURNING id, name, version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob'), (2, 'Charlie') ON CONFLICT (id) DO NOTHING RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, NULL, 'Alice');
INSERT INTO users VALUES (2, NULL, 'Bob') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT quantity FROM products WHERE id = 1;
SELECT name, email, age FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT COUNT(*) FROM users;
SELECT quantity FROM order_items WHERE order_id = 1 AND product_id = 101;
SELECT COUNT(*) FROM order_items;
SELECT id, name FROM users WHERE email = 'alice@example.com';
SELECT price FROM products WHERE id = 1;
SELECT price FROM products WHERE id = 1;
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users;
SELECT id, name FROM users;
SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_upsert_partial_column_update
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:145
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', 30);
INSERT INTO users VALUES (1, 'Alice Updated', 'new@example.com', 35) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob') ON CONFLICT (id) DO NOTHING;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob'), (3, 'Charlie') ON CONFLICT (id) DO NOTHING;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, 'alice@example.com', 'Alice');
INSERT INTO users VALUES (2, 'alice@example.com', 'Alice Duplicate') ON CONFLICT DO NOTHING;
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items ( order_id INT64, product_id INT64, quantity INT64, PRIMARY KEY (order_id, product_id) );
INSERT INTO order_items VALUES (1, 101, 5);
INSERT INTO order_items VALUES (1, 101, 10) ON CONFLICT (order_id, product_id) DO UPDATE SET quantity = EXCLUDED.quantity;
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items ( order_id INT64, product_id INT64, quantity INT64, PRIMARY KEY (order_id, product_id) );
INSERT INTO order_items VALUES (1, 101, 5);
INSERT INTO order_items VALUES (1, 102, 10) ON CONFLICT (order_id, product_id) DO UPDATE SET quantity = EXCLUDED.quantity;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, 'alice@example.com', 'Alice');
INSERT INTO users VALUES (2, 'alice@example.com', 'Alice Updated') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS products;
CREATE TABLE products ( id INT64 PRIMARY KEY, name STRING, price FLOAT64, stock INT64 );
INSERT INTO products VALUES (1, 'Widget', 10.0, 100);
INSERT INTO products VALUES (1, 'Widget', 15.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
INSERT INTO products VALUES (1, 'Widget', 5.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, active BOOL );
INSERT INTO users VALUES (1, 'Alice', NULL);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name WHERE products.active = TRUE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1 RETURNING id, name, version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob'), (2, 'Charlie') ON CONFLICT (id) DO NOTHING RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, NULL, 'Alice');
INSERT INTO users VALUES (2, NULL, 'Bob') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT name, email, age FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT COUNT(*) FROM users;
SELECT quantity FROM order_items WHERE order_id = 1 AND product_id = 101;
SELECT COUNT(*) FROM order_items;
SELECT id, name FROM users WHERE email = 'alice@example.com';
SELECT price FROM products WHERE id = 1;
SELECT price FROM products WHERE id = 1;
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users;
SELECT id, name FROM users;
SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_on_conflict_do_nothing_single_column
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:195
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob') ON CONFLICT (id) DO NOTHING;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob'), (3, 'Charlie') ON CONFLICT (id) DO NOTHING;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, 'alice@example.com', 'Alice');
INSERT INTO users VALUES (2, 'alice@example.com', 'Alice Duplicate') ON CONFLICT DO NOTHING;
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items ( order_id INT64, product_id INT64, quantity INT64, PRIMARY KEY (order_id, product_id) );
INSERT INTO order_items VALUES (1, 101, 5);
INSERT INTO order_items VALUES (1, 101, 10) ON CONFLICT (order_id, product_id) DO UPDATE SET quantity = EXCLUDED.quantity;
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items ( order_id INT64, product_id INT64, quantity INT64, PRIMARY KEY (order_id, product_id) );
INSERT INTO order_items VALUES (1, 101, 5);
INSERT INTO order_items VALUES (1, 102, 10) ON CONFLICT (order_id, product_id) DO UPDATE SET quantity = EXCLUDED.quantity;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, 'alice@example.com', 'Alice');
INSERT INTO users VALUES (2, 'alice@example.com', 'Alice Updated') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS products;
CREATE TABLE products ( id INT64 PRIMARY KEY, name STRING, price FLOAT64, stock INT64 );
INSERT INTO products VALUES (1, 'Widget', 10.0, 100);
INSERT INTO products VALUES (1, 'Widget', 15.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
INSERT INTO products VALUES (1, 'Widget', 5.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, active BOOL );
INSERT INTO users VALUES (1, 'Alice', NULL);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name WHERE products.active = TRUE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1 RETURNING id, name, version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob'), (2, 'Charlie') ON CONFLICT (id) DO NOTHING RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, NULL, 'Alice');
INSERT INTO users VALUES (2, NULL, 'Bob') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT name FROM users WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT COUNT(*) FROM users;
SELECT quantity FROM order_items WHERE order_id = 1 AND product_id = 101;
SELECT COUNT(*) FROM order_items;
SELECT id, name FROM users WHERE email = 'alice@example.com';
SELECT price FROM products WHERE id = 1;
SELECT price FROM products WHERE id = 1;
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users;
SELECT id, name FROM users;
SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_do_nothing_with_multiple_rows
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:229
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob'), (3, 'Charlie') ON CONFLICT (id) DO NOTHING;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, 'alice@example.com', 'Alice');
INSERT INTO users VALUES (2, 'alice@example.com', 'Alice Duplicate') ON CONFLICT DO NOTHING;
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items ( order_id INT64, product_id INT64, quantity INT64, PRIMARY KEY (order_id, product_id) );
INSERT INTO order_items VALUES (1, 101, 5);
INSERT INTO order_items VALUES (1, 101, 10) ON CONFLICT (order_id, product_id) DO UPDATE SET quantity = EXCLUDED.quantity;
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items ( order_id INT64, product_id INT64, quantity INT64, PRIMARY KEY (order_id, product_id) );
INSERT INTO order_items VALUES (1, 101, 5);
INSERT INTO order_items VALUES (1, 102, 10) ON CONFLICT (order_id, product_id) DO UPDATE SET quantity = EXCLUDED.quantity;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, 'alice@example.com', 'Alice');
INSERT INTO users VALUES (2, 'alice@example.com', 'Alice Updated') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS products;
CREATE TABLE products ( id INT64 PRIMARY KEY, name STRING, price FLOAT64, stock INT64 );
INSERT INTO products VALUES (1, 'Widget', 10.0, 100);
INSERT INTO products VALUES (1, 'Widget', 15.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
INSERT INTO products VALUES (1, 'Widget', 5.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, active BOOL );
INSERT INTO users VALUES (1, 'Alice', NULL);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name WHERE products.active = TRUE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1 RETURNING id, name, version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob'), (2, 'Charlie') ON CONFLICT (id) DO NOTHING RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, NULL, 'Alice');
INSERT INTO users VALUES (2, NULL, 'Bob') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT id, name FROM users ORDER BY id;
SELECT COUNT(*) FROM users;
SELECT quantity FROM order_items WHERE order_id = 1 AND product_id = 101;
SELECT COUNT(*) FROM order_items;
SELECT id, name FROM users WHERE email = 'alice@example.com';
SELECT price FROM products WHERE id = 1;
SELECT price FROM products WHERE id = 1;
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users;
SELECT id, name FROM users;
SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_do_nothing_without_conflict_target
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:272
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, 'alice@example.com', 'Alice');
INSERT INTO users VALUES (2, 'alice@example.com', 'Alice Duplicate') ON CONFLICT DO NOTHING;
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items ( order_id INT64, product_id INT64, quantity INT64, PRIMARY KEY (order_id, product_id) );
INSERT INTO order_items VALUES (1, 101, 5);
INSERT INTO order_items VALUES (1, 101, 10) ON CONFLICT (order_id, product_id) DO UPDATE SET quantity = EXCLUDED.quantity;
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items ( order_id INT64, product_id INT64, quantity INT64, PRIMARY KEY (order_id, product_id) );
INSERT INTO order_items VALUES (1, 101, 5);
INSERT INTO order_items VALUES (1, 102, 10) ON CONFLICT (order_id, product_id) DO UPDATE SET quantity = EXCLUDED.quantity;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, 'alice@example.com', 'Alice');
INSERT INTO users VALUES (2, 'alice@example.com', 'Alice Updated') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS products;
CREATE TABLE products ( id INT64 PRIMARY KEY, name STRING, price FLOAT64, stock INT64 );
INSERT INTO products VALUES (1, 'Widget', 10.0, 100);
INSERT INTO products VALUES (1, 'Widget', 15.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
INSERT INTO products VALUES (1, 'Widget', 5.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, active BOOL );
INSERT INTO users VALUES (1, 'Alice', NULL);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name WHERE products.active = TRUE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1 RETURNING id, name, version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob'), (2, 'Charlie') ON CONFLICT (id) DO NOTHING RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, NULL, 'Alice');
INSERT INTO users VALUES (2, NULL, 'Bob') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT COUNT(*) FROM users;
SELECT quantity FROM order_items WHERE order_id = 1 AND product_id = 101;
SELECT COUNT(*) FROM order_items;
SELECT id, name FROM users WHERE email = 'alice@example.com';
SELECT price FROM products WHERE id = 1;
SELECT price FROM products WHERE id = 1;
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users;
SELECT id, name FROM users;
SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_upsert_compound_primary_key
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:314
-- ============================================================================
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items ( order_id INT64, product_id INT64, quantity INT64, PRIMARY KEY (order_id, product_id) );
INSERT INTO order_items VALUES (1, 101, 5);
INSERT INTO order_items VALUES (1, 101, 10) ON CONFLICT (order_id, product_id) DO UPDATE SET quantity = EXCLUDED.quantity;
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items ( order_id INT64, product_id INT64, quantity INT64, PRIMARY KEY (order_id, product_id) );
INSERT INTO order_items VALUES (1, 101, 5);
INSERT INTO order_items VALUES (1, 102, 10) ON CONFLICT (order_id, product_id) DO UPDATE SET quantity = EXCLUDED.quantity;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, 'alice@example.com', 'Alice');
INSERT INTO users VALUES (2, 'alice@example.com', 'Alice Updated') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS products;
CREATE TABLE products ( id INT64 PRIMARY KEY, name STRING, price FLOAT64, stock INT64 );
INSERT INTO products VALUES (1, 'Widget', 10.0, 100);
INSERT INTO products VALUES (1, 'Widget', 15.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
INSERT INTO products VALUES (1, 'Widget', 5.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, active BOOL );
INSERT INTO users VALUES (1, 'Alice', NULL);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name WHERE products.active = TRUE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1 RETURNING id, name, version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob'), (2, 'Charlie') ON CONFLICT (id) DO NOTHING RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, NULL, 'Alice');
INSERT INTO users VALUES (2, NULL, 'Bob') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT quantity FROM order_items WHERE order_id = 1 AND product_id = 101;
SELECT COUNT(*) FROM order_items;
SELECT id, name FROM users WHERE email = 'alice@example.com';
SELECT price FROM products WHERE id = 1;
SELECT price FROM products WHERE id = 1;
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users;
SELECT id, name FROM users;
SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_compound_key_partial_match_no_conflict
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:355
-- ============================================================================
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items ( order_id INT64, product_id INT64, quantity INT64, PRIMARY KEY (order_id, product_id) );
INSERT INTO order_items VALUES (1, 101, 5);
INSERT INTO order_items VALUES (1, 102, 10) ON CONFLICT (order_id, product_id) DO UPDATE SET quantity = EXCLUDED.quantity;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, 'alice@example.com', 'Alice');
INSERT INTO users VALUES (2, 'alice@example.com', 'Alice Updated') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS products;
CREATE TABLE products ( id INT64 PRIMARY KEY, name STRING, price FLOAT64, stock INT64 );
INSERT INTO products VALUES (1, 'Widget', 10.0, 100);
INSERT INTO products VALUES (1, 'Widget', 15.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
INSERT INTO products VALUES (1, 'Widget', 5.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, active BOOL );
INSERT INTO users VALUES (1, 'Alice', NULL);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name WHERE products.active = TRUE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1 RETURNING id, name, version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob'), (2, 'Charlie') ON CONFLICT (id) DO NOTHING RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, NULL, 'Alice');
INSERT INTO users VALUES (2, NULL, 'Bob') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT COUNT(*) FROM order_items;
SELECT id, name FROM users WHERE email = 'alice@example.com';
SELECT price FROM products WHERE id = 1;
SELECT price FROM products WHERE id = 1;
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users;
SELECT id, name FROM users;
SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_upsert_on_unique_constraint_not_primary_key
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:396
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, 'alice@example.com', 'Alice');
INSERT INTO users VALUES (2, 'alice@example.com', 'Alice Updated') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS products;
CREATE TABLE products ( id INT64 PRIMARY KEY, name STRING, price FLOAT64, stock INT64 );
INSERT INTO products VALUES (1, 'Widget', 10.0, 100);
INSERT INTO products VALUES (1, 'Widget', 15.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
INSERT INTO products VALUES (1, 'Widget', 5.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, active BOOL );
INSERT INTO users VALUES (1, 'Alice', NULL);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name WHERE products.active = TRUE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1 RETURNING id, name, version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob'), (2, 'Charlie') ON CONFLICT (id) DO NOTHING RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, NULL, 'Alice');
INSERT INTO users VALUES (2, NULL, 'Bob') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT id, name FROM users WHERE email = 'alice@example.com';
SELECT price FROM products WHERE id = 1;
SELECT price FROM products WHERE id = 1;
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users;
SELECT id, name FROM users;
SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_upsert_with_where_clause
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:446
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products ( id INT64 PRIMARY KEY, name STRING, price FLOAT64, stock INT64 );
INSERT INTO products VALUES (1, 'Widget', 10.0, 100);
INSERT INTO products VALUES (1, 'Widget', 15.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
INSERT INTO products VALUES (1, 'Widget', 5.0, 100) ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price WHERE EXCLUDED.price > products.price;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, active BOOL );
INSERT INTO users VALUES (1, 'Alice', NULL);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name WHERE products.active = TRUE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1 RETURNING id, name, version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob'), (2, 'Charlie') ON CONFLICT (id) DO NOTHING RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, NULL, 'Alice');
INSERT INTO users VALUES (2, NULL, 'Bob') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT price FROM products WHERE id = 1;
SELECT price FROM products WHERE id = 1;
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users;
SELECT id, name FROM users;
SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_upsert_where_clause_with_null
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:507
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, active BOOL );
INSERT INTO users VALUES (1, 'Alice', NULL);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name WHERE products.active = TRUE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1 RETURNING id, name, version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob'), (2, 'Charlie') ON CONFLICT (id) DO NOTHING RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, NULL, 'Alice');
INSERT INTO users VALUES (2, NULL, 'Bob') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users;
SELECT id, name FROM users;
SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_upsert_with_returning_inserted
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:552
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1 RETURNING id, name, version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob'), (2, 'Charlie') ON CONFLICT (id) DO NOTHING RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, NULL, 'Alice');
INSERT INTO users VALUES (2, NULL, 'Bob') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT COUNT(*) FROM users;
SELECT id, name FROM users;
SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_upsert_with_returning_updated
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:583
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1 RETURNING id, name, version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob'), (2, 'Charlie') ON CONFLICT (id) DO NOTHING RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, NULL, 'Alice');
INSERT INTO users VALUES (2, NULL, 'Bob') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT COUNT(*) FROM users;
SELECT id, name FROM users;
SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_do_nothing_with_returning
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:618
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (1, 'Bob'), (2, 'Charlie') ON CONFLICT (id) DO NOTHING RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, NULL, 'Alice');
INSERT INTO users VALUES (2, NULL, 'Bob') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT COUNT(*) FROM users;
SELECT id, name FROM users;
SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_upsert_with_null_in_conflict_column
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:654
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, email STRING UNIQUE, name STRING );
INSERT INTO users VALUES (1, NULL, 'Alice');
INSERT INTO users VALUES (2, NULL, 'Bob') ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT COUNT(*) FROM users;
SELECT id, name FROM users;
SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_upsert_empty_table
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:694
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT id, name FROM users;
SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_upsert_all_rows_conflict
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:722
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
INSERT INTO users VALUES (1, 'Alice', 1), (2, 'Bob', 1);
INSERT INTO users VALUES (1, 'Alice Updated', 1), (2, 'Bob Updated', 1) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = users.version + 1;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT COUNT(*) FROM users WHERE version = 2;
SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_upsert_with_default_values
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:756
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP(), updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP() );
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name, updated_at) VALUES (1, 'Alice Updated', CURRENT_TIMESTAMP()) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated_at = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT name FROM users WHERE id = 1;
UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_error_invalid_conflict_target
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:801
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (nonexistent_column) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_error_conflict_target_not_unique
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:830
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) ON CONFLICT (age) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_error_excluded_in_wrong_context
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:853
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

UPDATE users SET name = EXCLUDED.name WHERE id = 1;
SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_error_type_mismatch_in_excluded
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:873
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 'thirty') ON CONFLICT (id) DO UPDATE SET age = EXCLUDED.age;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_error_do_update_without_set_clause
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:896
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_upsert_with_subquery_in_insert
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:920
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS staging;
CREATE TABLE staging (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
INSERT INTO staging VALUES (1, 'Alice Updated'), (2, 'Bob');
INSERT INTO users SELECT id, name FROM staging ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT id, name FROM users ORDER BY id;
SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_upsert_with_expression_in_update
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:964
-- ============================================================================
DROP TABLE IF EXISTS counters;
CREATE TABLE counters ( key STRING PRIMARY KEY, count INT64, last_updated TIMESTAMP );
INSERT INTO counters VALUES ('page_views', 100, CURRENT_TIMESTAMP());
INSERT INTO counters VALUES ('page_views', 50, CURRENT_TIMESTAMP()) ON CONFLICT (key) DO UPDATE SET count = counters.count + EXCLUDED.count, last_updated = CURRENT_TIMESTAMP();
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

SELECT count FROM counters WHERE key = 'page_views';
WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_upsert_with_cte
-- Source: insert_on_conflict_upsert_comprehensive_tdd.rs:1006
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS metrics;
CREATE TABLE metrics (id INT64 PRIMARY KEY, value INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, version INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users (id, name) VALUES (1, 'Alice') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (1, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, updated BOOL);
INSERT INTO users VALUES (1, 'Alice', FALSE), (3, 'Charlie', FALSE);
INSERT INTO users VALUES (1, 'Alice Updated', TRUE), (2, 'Bob', FALSE), (3, 'Charlie Updated', TRUE) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, updated = EXCLUDED.updated;
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (session_id UUID PRIMARY KEY, user_id INT64, active BOOL);
DROP TABLE IF EXISTS prices;
CREATE TABLE prices ( price NUMERIC(10, 2) PRIMARY KEY, product STRING, currency STRING );
INSERT INTO prices VALUES (99.99, 'Widget', 'USD');
INSERT INTO prices VALUES (99.99, 'Widget Pro', 'USD') ON CONFLICT (price) DO UPDATE SET product = EXCLUDED.product;
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory ( product_id INT64 PRIMARY KEY, quantity INT64, reserved INT64, last_updated TIMESTAMP );
INSERT INTO inventory VALUES (1, 100, 10, TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO inventory VALUES (1, 50, 5, TIMESTAMP '2024-01-02 00:00:00') ON CONFLICT (product_id) DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity, reserved = CASE WHEN inventory.reserved > EXCLUDED.reserved THEN inventory.reserved ELSE EXCLUDED.reserved END, last_updated = EXCLUDED.last_updated;
DROP TABLE IF EXISTS users;
CREATE TABLE users ( id INT64 PRIMARY KEY, name STRING, version INT64 );
INSERT INTO users VALUES (1, 'Alice', 5);
INSERT INTO users VALUES (1, 'Alice Old', 3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, version = EXCLUDED.version WHERE EXCLUDED.version > users.version;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING, created_at TIMESTAMP);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com', TIMESTAMP '2024-01-01 00:00:00');
INSERT INTO users VALUES (1, 'Alice Updated', 'newemail@example.com', TIMESTAMP '2024-12-01 00:00:00') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64 PRIMARY KEY, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (1, 'Alice Updated', NULL) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, email = EXCLUDED.email;

WITH upserted AS ( INSERT INTO users VALUES (1, 'Alice Updated'), (2, 'Bob') ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name RETURNING id, name ) SELECT * FROM upserted ORDER BY id;
SELECT COUNT(*) FROM metrics WHERE value % 20 = 0;
SELECT name, version FROM users WHERE id = 1;
SELECT name FROM users WHERE id = 1;
MERGE users T USING (SELECT 1 as id, 'Alice Updated' as name) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET name = S.name WHEN NOT MATCHED THEN INSERT (id, name) VALUES (S.id, S.name);
SELECT name FROM users WHERE id = 1;
SELECT COUNT(*) FROM users WHERE updated = TRUE;
SELECT COUNT(*) FROM users;
SELECT product FROM prices WHERE price = 99.99;
SELECT quantity, reserved FROM inventory WHERE product_id = 1;
SELECT name, version FROM users WHERE id = 1;
SELECT name, email FROM users WHERE id = 1;
SELECT EXCLUDED.name FROM users;
SELECT name, email FROM users WHERE id = 1;

-- ============================================================================
-- Test: test_delete_using_with_complex_condition
-- Source: join_based_dml_comprehensive_tdd.rs:475
-- ============================================================================
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (id INT64, user_id INT64, amount FLOAT64, status STRING);
DROP TABLE IF EXISTS cancelled_users;
CREATE TABLE cancelled_users (user_id INT64);
INSERT INTO orders VALUES \ (1, 1, 100.0, 'pending'), \ (2, 1, 200.0, 'completed'), \ (3, 2, 150.0, 'pending');
INSERT INTO cancelled_users VALUES (1);
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, type STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (user_id INT64);
DROP TABLE IF EXISTS log_types_to_clean;
CREATE TABLE log_types_to_clean (type STRING);
INSERT INTO logs VALUES \ (1, 1, 'debug'), \ (2, 1, 'error'), \ (3, 2, 'debug');
INSERT INTO inactive_users VALUES (1);
INSERT INTO log_types_to_clean VALUES ('debug');
DROP TABLE IF EXISTS contacts;
CREATE TABLE contacts (id INT64, email STRING, created_at INT64);
INSERT INTO contacts VALUES \ (1, 'alice@example.com', 1), \ (2, 'alice@example.com', 2), \ (3, 'bob@example.com', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, score INT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (user_id INT64, bonus INT64);
INSERT INTO users VALUES (1, 100), (2, 200);
INSERT INTO bonuses VALUES (1, 50);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category STRING);
DROP TABLE IF EXISTS discontinued_categories;
CREATE TABLE discontinued_categories (category STRING);
INSERT INTO products VALUES \ (1, 'Widget', 'tools'), \ (2, 'Gadget', 'electronics');
INSERT INTO discontinued_categories VALUES ('tools');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, level STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, points INT64);
INSERT INTO users VALUES (1, 'beginner'), (2, 'beginner');
INSERT INTO scores VALUES (1, 1000), (2, 500);
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

DELETE FROM orders \ USING cancelled_users \ WHERE orders.user_id = cancelled_users.user_id \ AND orders.status = 'pending';
SELECT id FROM orders WHERE user_id = 1 ORDER BY id;
DELETE FROM logs \ USING inactive_users, log_types_to_clean \ WHERE logs.user_id = inactive_users.user_id \ AND logs.type = log_types_to_clean.type;
SELECT id FROM logs ORDER BY id;
DELETE FROM contacts c1 \ USING contacts c2 \ WHERE c1.email = c2.email \ AND c1.created_at < c2.created_at;
SELECT id FROM contacts ORDER BY id;
UPDATE users \ SET score = users.score + bonuses.bonus \ FROM bonuses \ WHERE users.id = bonuses.user_id \ RETURNING users.id, users.score;
DELETE FROM products \ USING discontinued_categories \ WHERE products.category = discontinued_categories.category \ RETURNING products.id, products.name;
WITH high_scorers AS ( \ SELECT user_id FROM scores WHERE points >= 1000 \ ) \ UPDATE users \ SET level = 'advanced' \ FROM high_scorers \ WHERE users.id = high_scorers.user_id;
SELECT level FROM users WHERE id = 1;
WITH inactive AS ( \ SELECT user_id FROM activity WHERE last_active > 60 \ ) \ DELETE FROM sessions \ USING inactive \ WHERE sessions.user_id = inactive.user_id;
SELECT COUNT(*) FROM sessions;
UPDATE t1 \ SET value = t2.value \ FROM t2 \ WHERE id = t2.id;
DELETE FROM users \ USING filter \ WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \ SET value = n2.value + 1 \ FROM nums n2 \ WHERE n1.id = n2.id;
SELECT value FROM nums WHERE id = 1;
UPDATE items \ SET price = items.price * price_changes.multiplier \ FROM price_changes \ WHERE items.id = price_changes.item_id;
SELECT price FROM items WHERE id = 1;
SELECT price FROM items WHERE id = 100;
DELETE FROM records \ USING to_remove \ WHERE records.id = to_remove.record_id;
SELECT COUNT(*) FROM records;

-- ============================================================================
-- Test: test_delete_using_multiple_tables
-- Source: join_based_dml_comprehensive_tdd.rs:517
-- ============================================================================
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, user_id INT64, type STRING);
DROP TABLE IF EXISTS inactive_users;
CREATE TABLE inactive_users (user_id INT64);
DROP TABLE IF EXISTS log_types_to_clean;
CREATE TABLE log_types_to_clean (type STRING);
INSERT INTO logs VALUES \ (1, 1, 'debug'), \ (2, 1, 'error'), \ (3, 2, 'debug');
INSERT INTO inactive_users VALUES (1);
INSERT INTO log_types_to_clean VALUES ('debug');
DROP TABLE IF EXISTS contacts;
CREATE TABLE contacts (id INT64, email STRING, created_at INT64);
INSERT INTO contacts VALUES \ (1, 'alice@example.com', 1), \ (2, 'alice@example.com', 2), \ (3, 'bob@example.com', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, score INT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (user_id INT64, bonus INT64);
INSERT INTO users VALUES (1, 100), (2, 200);
INSERT INTO bonuses VALUES (1, 50);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category STRING);
DROP TABLE IF EXISTS discontinued_categories;
CREATE TABLE discontinued_categories (category STRING);
INSERT INTO products VALUES \ (1, 'Widget', 'tools'), \ (2, 'Gadget', 'electronics');
INSERT INTO discontinued_categories VALUES ('tools');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, level STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, points INT64);
INSERT INTO users VALUES (1, 'beginner'), (2, 'beginner');
INSERT INTO scores VALUES (1, 1000), (2, 500);
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

DELETE FROM logs \ USING inactive_users, log_types_to_clean \ WHERE logs.user_id = inactive_users.user_id \ AND logs.type = log_types_to_clean.type;
SELECT id FROM logs ORDER BY id;
DELETE FROM contacts c1 \ USING contacts c2 \ WHERE c1.email = c2.email \ AND c1.created_at < c2.created_at;
SELECT id FROM contacts ORDER BY id;
UPDATE users \ SET score = users.score + bonuses.bonus \ FROM bonuses \ WHERE users.id = bonuses.user_id \ RETURNING users.id, users.score;
DELETE FROM products \ USING discontinued_categories \ WHERE products.category = discontinued_categories.category \ RETURNING products.id, products.name;
WITH high_scorers AS ( \ SELECT user_id FROM scores WHERE points >= 1000 \ ) \ UPDATE users \ SET level = 'advanced' \ FROM high_scorers \ WHERE users.id = high_scorers.user_id;
SELECT level FROM users WHERE id = 1;
WITH inactive AS ( \ SELECT user_id FROM activity WHERE last_active > 60 \ ) \ DELETE FROM sessions \ USING inactive \ WHERE sessions.user_id = inactive.user_id;
SELECT COUNT(*) FROM sessions;
UPDATE t1 \ SET value = t2.value \ FROM t2 \ WHERE id = t2.id;
DELETE FROM users \ USING filter \ WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \ SET value = n2.value + 1 \ FROM nums n2 \ WHERE n1.id = n2.id;
SELECT value FROM nums WHERE id = 1;
UPDATE items \ SET price = items.price * price_changes.multiplier \ FROM price_changes \ WHERE items.id = price_changes.item_id;
SELECT price FROM items WHERE id = 1;
SELECT price FROM items WHERE id = 100;
DELETE FROM records \ USING to_remove \ WHERE records.id = to_remove.record_id;
SELECT COUNT(*) FROM records;

-- ============================================================================
-- Test: test_delete_using_self_join
-- Source: join_based_dml_comprehensive_tdd.rs:566
-- ============================================================================
DROP TABLE IF EXISTS contacts;
CREATE TABLE contacts (id INT64, email STRING, created_at INT64);
INSERT INTO contacts VALUES \ (1, 'alice@example.com', 1), \ (2, 'alice@example.com', 2), \ (3, 'bob@example.com', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, score INT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (user_id INT64, bonus INT64);
INSERT INTO users VALUES (1, 100), (2, 200);
INSERT INTO bonuses VALUES (1, 50);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category STRING);
DROP TABLE IF EXISTS discontinued_categories;
CREATE TABLE discontinued_categories (category STRING);
INSERT INTO products VALUES \ (1, 'Widget', 'tools'), \ (2, 'Gadget', 'electronics');
INSERT INTO discontinued_categories VALUES ('tools');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, level STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, points INT64);
INSERT INTO users VALUES (1, 'beginner'), (2, 'beginner');
INSERT INTO scores VALUES (1, 1000), (2, 500);
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

DELETE FROM contacts c1 \ USING contacts c2 \ WHERE c1.email = c2.email \ AND c1.created_at < c2.created_at;
SELECT id FROM contacts ORDER BY id;
UPDATE users \ SET score = users.score + bonuses.bonus \ FROM bonuses \ WHERE users.id = bonuses.user_id \ RETURNING users.id, users.score;
DELETE FROM products \ USING discontinued_categories \ WHERE products.category = discontinued_categories.category \ RETURNING products.id, products.name;
WITH high_scorers AS ( \ SELECT user_id FROM scores WHERE points >= 1000 \ ) \ UPDATE users \ SET level = 'advanced' \ FROM high_scorers \ WHERE users.id = high_scorers.user_id;
SELECT level FROM users WHERE id = 1;
WITH inactive AS ( \ SELECT user_id FROM activity WHERE last_active > 60 \ ) \ DELETE FROM sessions \ USING inactive \ WHERE sessions.user_id = inactive.user_id;
SELECT COUNT(*) FROM sessions;
UPDATE t1 \ SET value = t2.value \ FROM t2 \ WHERE id = t2.id;
DELETE FROM users \ USING filter \ WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \ SET value = n2.value + 1 \ FROM nums n2 \ WHERE n1.id = n2.id;
SELECT value FROM nums WHERE id = 1;
UPDATE items \ SET price = items.price * price_changes.multiplier \ FROM price_changes \ WHERE items.id = price_changes.item_id;
SELECT price FROM items WHERE id = 1;
SELECT price FROM items WHERE id = 100;
DELETE FROM records \ USING to_remove \ WHERE records.id = to_remove.record_id;
SELECT COUNT(*) FROM records;

-- ============================================================================
-- Test: test_update_from_with_returning
-- Source: join_based_dml_comprehensive_tdd.rs:608
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, score INT64);
DROP TABLE IF EXISTS bonuses;
CREATE TABLE bonuses (user_id INT64, bonus INT64);
INSERT INTO users VALUES (1, 100), (2, 200);
INSERT INTO bonuses VALUES (1, 50);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category STRING);
DROP TABLE IF EXISTS discontinued_categories;
CREATE TABLE discontinued_categories (category STRING);
INSERT INTO products VALUES \ (1, 'Widget', 'tools'), \ (2, 'Gadget', 'electronics');
INSERT INTO discontinued_categories VALUES ('tools');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, level STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, points INT64);
INSERT INTO users VALUES (1, 'beginner'), (2, 'beginner');
INSERT INTO scores VALUES (1, 1000), (2, 500);
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

UPDATE users \ SET score = users.score + bonuses.bonus \ FROM bonuses \ WHERE users.id = bonuses.user_id \ RETURNING users.id, users.score;
DELETE FROM products \ USING discontinued_categories \ WHERE products.category = discontinued_categories.category \ RETURNING products.id, products.name;
WITH high_scorers AS ( \ SELECT user_id FROM scores WHERE points >= 1000 \ ) \ UPDATE users \ SET level = 'advanced' \ FROM high_scorers \ WHERE users.id = high_scorers.user_id;
SELECT level FROM users WHERE id = 1;
WITH inactive AS ( \ SELECT user_id FROM activity WHERE last_active > 60 \ ) \ DELETE FROM sessions \ USING inactive \ WHERE sessions.user_id = inactive.user_id;
SELECT COUNT(*) FROM sessions;
UPDATE t1 \ SET value = t2.value \ FROM t2 \ WHERE id = t2.id;
DELETE FROM users \ USING filter \ WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \ SET value = n2.value + 1 \ FROM nums n2 \ WHERE n1.id = n2.id;
SELECT value FROM nums WHERE id = 1;
UPDATE items \ SET price = items.price * price_changes.multiplier \ FROM price_changes \ WHERE items.id = price_changes.item_id;
SELECT price FROM items WHERE id = 1;
SELECT price FROM items WHERE id = 100;
DELETE FROM records \ USING to_remove \ WHERE records.id = to_remove.record_id;
SELECT COUNT(*) FROM records;

-- ============================================================================
-- Test: test_delete_using_with_returning
-- Source: join_based_dml_comprehensive_tdd.rs:643
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category STRING);
DROP TABLE IF EXISTS discontinued_categories;
CREATE TABLE discontinued_categories (category STRING);
INSERT INTO products VALUES \ (1, 'Widget', 'tools'), \ (2, 'Gadget', 'electronics');
INSERT INTO discontinued_categories VALUES ('tools');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, level STRING);
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (user_id INT64, points INT64);
INSERT INTO users VALUES (1, 'beginner'), (2, 'beginner');
INSERT INTO scores VALUES (1, 1000), (2, 500);
DROP TABLE IF EXISTS sessions;
CREATE TABLE sessions (id INT64, user_id INT64);
DROP TABLE IF EXISTS activity;
CREATE TABLE activity (user_id INT64, last_active INT64);
INSERT INTO sessions VALUES (1, 1), (2, 2);
INSERT INTO activity VALUES (1, 30), (2, 90);
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT64, value STRING);
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (id INT64, value STRING);
INSERT INTO t1 VALUES (1, 'old');
INSERT INTO t2 VALUES (1, 'new');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64);
DROP TABLE IF EXISTS filter;
CREATE TABLE filter (user_id INT64);
DROP TABLE IF EXISTS nums;
CREATE TABLE nums (id INT64, value INT64);
INSERT INTO nums VALUES (1, 10);
DROP TABLE IF EXISTS items;
CREATE TABLE items (id INT64, price FLOAT64);
DROP TABLE IF EXISTS price_changes;
CREATE TABLE price_changes (item_id INT64, multiplier FLOAT64);
DROP TABLE IF EXISTS records;
CREATE TABLE records (id INT64);
DROP TABLE IF EXISTS to_remove;
CREATE TABLE to_remove (record_id INT64);

DELETE FROM products \ USING discontinued_categories \ WHERE products.category = discontinued_categories.category \ RETURNING products.id, products.name;
WITH high_scorers AS ( \ SELECT user_id FROM scores WHERE points >= 1000 \ ) \ UPDATE users \ SET level = 'advanced' \ FROM high_scorers \ WHERE users.id = high_scorers.user_id;
SELECT level FROM users WHERE id = 1;
WITH inactive AS ( \ SELECT user_id FROM activity WHERE last_active > 60 \ ) \ DELETE FROM sessions \ USING inactive \ WHERE sessions.user_id = inactive.user_id;
SELECT COUNT(*) FROM sessions;
UPDATE t1 \ SET value = t2.value \ FROM t2 \ WHERE id = t2.id;
DELETE FROM users \ USING filter \ WHERE users.nonexistent = filter.user_id;
UPDATE nums n1 \ SET value = n2.value + 1 \ FROM nums n2 \ WHERE n1.id = n2.id;
SELECT value FROM nums WHERE id = 1;
UPDATE items \ SET price = items.price * price_changes.multiplier \ FROM price_changes \ WHERE items.id = price_changes.item_id;
SELECT price FROM items WHERE id = 1;
SELECT price FROM items WHERE id = 100;
DELETE FROM records \ USING to_remove \ WHERE records.id = to_remove.record_id;
SELECT COUNT(*) FROM records;

-- ============================================================================
-- Test: test_materialized_view_with_cte
-- Source: materialized_views_comprehensive_tdd.rs:589
-- ============================================================================
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions ( account_id INT64, amount FLOAT64, tx_type STRING );
INSERT INTO transactions VALUES (1, 100.00, 'credit'), (1, 50.00, 'debit'), (1, 200.00, 'credit'), (2, 300.00, 'credit'), (2, 150.00, 'debit');
DROP MATERIALIZED VIEW IF EXISTS account_balances;
CREATE MATERIALIZED VIEW account_balances AS WITH credits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'credit' GROUP BY account_id ), debits AS ( SELECT account_id, SUM(amount) as total FROM transactions WHERE tx_type = 'debit' GROUP BY account_id ) SELECT COALESCE(c.account_id, d.account_id) as account_id, COALESCE(c.total, 0) - COALESCE(d.total, 0) as balance FROM credits c FULL OUTER JOIN debits d ON c.account_id = d.account_id;
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (dept_id INT64, dept_name STRING);
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (emp_id INT64, dept_id INT64, salary FLOAT64);
INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES (1, 1, 100000.00), (2, 1, 120000.00), (3, 2, 80000.00), (4, 2, 90000.00);
DROP MATERIALIZED VIEW IF EXISTS dept_avg_salary;
CREATE MATERIALIZED VIEW dept_avg_salary AS SELECT d.dept_name, (SELECT AVG(salary) FROM employees e WHERE e.dept_id = d.dept_id) as avg_salary FROM departments d;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, 10), (2, 20);
DROP MATERIALIZED VIEW IF EXISTS filtered_data;
CREATE MATERIALIZED VIEW filtered_data AS SELECT * FROM data WHERE value > 1000;
DROP TABLE IF EXISTS large_table;
CREATE TABLE large_table (id INT64, value FLOAT64);
DROP MATERIALIZED VIEW IF EXISTS large_mv;
CREATE MATERIALIZED VIEW large_mv AS SELECT * FROM large_table WHERE value > 500.0;
DROP TABLE IF EXISTS nullable_data;
CREATE TABLE nullable_data (id INT64, value INT64);
INSERT INTO nullable_data VALUES (1, 10), (2, NULL), (3, 30), (4, NULL);
DROP MATERIALIZED VIEW IF EXISTS non_null_data;
CREATE MATERIALIZED VIEW non_null_data AS SELECT * FROM nullable_data WHERE value IS NOT NULL;
DROP MATERIALIZED VIEW IF EXISTS invalid_mv;
CREATE MATERIALIZED VIEW invalid_mv AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS shared_name;
CREATE TABLE shared_name (id INT64);
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP VIEW IF EXISTS shared_name;
CREATE VIEW shared_name AS SELECT * FROM base;
DROP MATERIALIZED VIEW IF EXISTS shared_name;
CREATE MATERIALIZED VIEW shared_name AS SELECT 1 as id;
DROP TABLE IF EXISTS test;
CREATE TABLE test (id INT64);
DROP MATERIALIZED VIEW IF EXISTS test_mv;
CREATE MATERIALIZED VIEW test_mv AS SELECT * FROM test WHERE id > 10;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
DROP MATERIALIZED VIEW IF EXISTS even_numbers;
CREATE MATERIALIZED VIEW even_numbers AS SELECT * FROM numbers WHERE n % 2 = 0;
DROP MATERIALIZED VIEW IF EXISTS odd_numbers;
CREATE MATERIALIZED VIEW odd_numbers AS SELECT * FROM numbers WHERE n % 2 = 1;
DROP MATERIALIZED VIEW IF EXISTS large_numbers;
CREATE MATERIALIZED VIEW large_numbers AS SELECT * FROM numbers WHERE n > 5;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
INSERT INTO mv VALUES (1);
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS base;
CREATE TABLE base (id INT64);
INSERT INTO base VALUES (1);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM base;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200);
DROP MATERIALIZED VIEW IF EXISTS mv;
CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WHERE value > 50;
CREATE TABLE copy AS SELECT * FROM mv;

SELECT account_id, balance FROM account_balances ORDER BY account_id;
SELECT dept_name, avg_salary FROM dept_avg_salary ORDER BY dept_name;
SELECT COUNT(*) FROM filtered_data;
SELECT COUNT(*) FROM large_mv;
SELECT COUNT(*) FROM non_null_data;
REFRESH MATERIALIZED VIEW test_mv;
SELECT COUNT(*) FROM even_numbers;
SELECT COUNT(*) FROM odd_numbers;
SELECT COUNT(*) FROM large_numbers;
UPDATE mv SET id = 2 WHERE id = 1;
DELETE FROM mv WHERE id = 1;
SELECT COUNT(*) FROM copy;

-- ============================================================================
-- Test: test_merge_with_subquery_source
-- Source: merge_statement_comprehensive_tdd.rs:489
-- ============================================================================
DROP TABLE IF EXISTS summary;
CREATE TABLE summary (category STRING, total INT64);
INSERT INTO summary VALUES ('A', 100), ('B', 200);
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (category STRING, amount INT64);
INSERT INTO transactions VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40), ('C', 50);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS raw_data;
CREATE TABLE raw_data (id INT64, val1 INT64, val2 INT64);
INSERT INTO raw_data VALUES (1, 5, 10), (2, 15, 20);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category_id INT64);
INSERT INTO products VALUES (1, 'Widget', 1);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING);
INSERT INTO categories VALUES (1, 'Hardware'), (2, 'Software');
DROP TABLE IF EXISTS product_details;
CREATE TABLE product_details (id INT64, category_name STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'one'), (NULL, 'null_target');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'updated'), (NULL, 'null_source');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
INSERT INTO target VALUES (1), (2);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'update1'), (1, 'update2');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64 PRIMARY KEY, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30), (2, 40);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30);

MERGE INTO summary s USING ( SELECT category, SUM(amount) as total FROM transactions GROUP BY category ) t ON s.category = t.category WHEN MATCHED THEN UPDATE SET s.total = s.total + t.total WHEN NOT MATCHED THEN INSERT (category, total) VALUES (t.category, t.total);
SELECT * FROM summary ORDER BY category;
WITH computed AS ( SELECT id, val1 + val2 AS total FROM raw_data ) MERGE INTO target t USING computed c ON t.id = c.id WHEN MATCHED THEN UPDATE SET t.value = c.total WHEN NOT MATCHED THEN INSERT (id, value) VALUES (c.id, c.total);
SELECT * FROM target ORDER BY id;
MERGE INTO product_details pd USING ( SELECT p.id, c.name as category_name FROM products p JOIN categories c ON p.category_id = c.id ) src ON pd.id = src.id WHEN MATCHED THEN UPDATE SET pd.category_name = src.category_name WHEN NOT MATCHED THEN INSERT (id, category_name) VALUES (src.id, src.category_name);
SELECT * FROM product_details;
MERGE INTO target t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.value = s.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (s.id, s.value);
SELECT * FROM target WHERE id IS NOT NULL ORDER BY id;
MERGE INTO target t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.id = s.id WHEN NOT MATCHED BY SOURCE THEN DELETE;
MERGE INTO target t USING source s ON t.id = s.id WHEN NOT MATCHED THEN INSERT (id) VALUES (s.id);
MERGE INTO target t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.value = s.value;
MERGE INTO nonexistent t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.id = s.id;
MERGE INTO target t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.id = 1;
MERGE INTO target t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.nonexistent = 1;
MERGE INTO target t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.value = s.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (s.id, s.value);
SELECT value FROM target WHERE id = 1;
MERGE INTO target t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.value = s.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (s.id, s.value);
MERGE INTO target t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.value = s.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (s.id, s.value) RETURNING t.id, t.value;

-- ============================================================================
-- Test: test_merge_with_cte
-- Source: merge_statement_comprehensive_tdd.rs:546
-- ============================================================================
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS raw_data;
CREATE TABLE raw_data (id INT64, val1 INT64, val2 INT64);
INSERT INTO raw_data VALUES (1, 5, 10), (2, 15, 20);
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, name STRING, category_id INT64);
INSERT INTO products VALUES (1, 'Widget', 1);
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (id INT64, name STRING);
INSERT INTO categories VALUES (1, 'Hardware'), (2, 'Software');
DROP TABLE IF EXISTS product_details;
CREATE TABLE product_details (id INT64, category_name STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'one'), (NULL, 'null_target');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'updated'), (NULL, 'null_source');
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
INSERT INTO target VALUES (1), (2);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO target VALUES (1, 'original');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
INSERT INTO source VALUES (1, 'update1'), (1, 'update2');
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64 PRIMARY KEY, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30), (2, 40);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value INT64);
INSERT INTO target VALUES (1, 10);
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 20), (2, 30);

WITH computed AS ( SELECT id, val1 + val2 AS total FROM raw_data ) MERGE INTO target t USING computed c ON t.id = c.id WHEN MATCHED THEN UPDATE SET t.value = c.total WHEN NOT MATCHED THEN INSERT (id, value) VALUES (c.id, c.total);
SELECT * FROM target ORDER BY id;
MERGE INTO product_details pd USING ( SELECT p.id, c.name as category_name FROM products p JOIN categories c ON p.category_id = c.id ) src ON pd.id = src.id WHEN MATCHED THEN UPDATE SET pd.category_name = src.category_name WHEN NOT MATCHED THEN INSERT (id, category_name) VALUES (src.id, src.category_name);
SELECT * FROM product_details;
MERGE INTO target t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.value = s.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (s.id, s.value);
SELECT * FROM target WHERE id IS NOT NULL ORDER BY id;
MERGE INTO target t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.id = s.id WHEN NOT MATCHED BY SOURCE THEN DELETE;
MERGE INTO target t USING source s ON t.id = s.id WHEN NOT MATCHED THEN INSERT (id) VALUES (s.id);
MERGE INTO target t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.value = s.value;
MERGE INTO nonexistent t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.id = s.id;
MERGE INTO target t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.id = 1;
MERGE INTO target t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.nonexistent = 1;
MERGE INTO target t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.value = s.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (s.id, s.value);
SELECT value FROM target WHERE id = 1;
MERGE INTO target t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.value = s.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (s.id, s.value);
MERGE INTO target t USING source s ON t.id = s.id WHEN MATCHED THEN UPDATE SET t.value = s.value WHEN NOT MATCHED THEN INSERT (id, value) VALUES (s.id, s.value) RETURNING t.id, t.value;

-- ============================================================================
-- Test: test_insert_returning_single_column
-- Source: returning_clause_comprehensive_tdd.rs:28
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING *;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie') RETURNING id, name;
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0) RETURNING id, price * 1.1 AS price_with_tax;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', NULL) RETURNING *;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO source VALUES (1, 'test');
INSERT INTO target SELECT * FROM source RETURNING id, value;
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, name STRING);
INSERT INTO events VALUES (1, 'test') RETURNING id, UPPER(name) AS name_upper;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES () RETURNING *;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, status STRING);
INSERT INTO users VALUES (1, 'active'), (2, 'active'), (3, 'inactive');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

UPDATE users SET age = 31 WHERE id = 1 RETURNING id, age;
UPDATE users SET status = 'archived' WHERE status = 'active' RETURNING id, status;
UPDATE users SET age = 31 WHERE id = 1 RETURNING *;
UPDATE counters SET value = value + 5 WHERE id = 1 RETURNING id, value;
UPDATE users SET name = 'Bob' WHERE id = 999 RETURNING id, name;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING id, price, price * 0.2 AS tax;
UPDATE users SET email = NULL WHERE id = 1 RETURNING id, email;
DELETE FROM users WHERE id = 1 RETURNING id, name;
SELECT COUNT(*) FROM users;
DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_insert_returning_multiple_columns
-- Source: returning_clause_comprehensive_tdd.rs:45
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30) RETURNING id, name;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING *;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie') RETURNING id, name;
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0) RETURNING id, price * 1.1 AS price_with_tax;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', NULL) RETURNING *;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO source VALUES (1, 'test');
INSERT INTO target SELECT * FROM source RETURNING id, value;
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, name STRING);
INSERT INTO events VALUES (1, 'test') RETURNING id, UPPER(name) AS name_upper;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES () RETURNING *;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, status STRING);
INSERT INTO users VALUES (1, 'active'), (2, 'active'), (3, 'inactive');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

UPDATE users SET age = 31 WHERE id = 1 RETURNING id, age;
UPDATE users SET status = 'archived' WHERE status = 'active' RETURNING id, status;
UPDATE users SET age = 31 WHERE id = 1 RETURNING *;
UPDATE counters SET value = value + 5 WHERE id = 1 RETURNING id, value;
UPDATE users SET name = 'Bob' WHERE id = 999 RETURNING id, name;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING id, price, price * 0.2 AS tax;
UPDATE users SET email = NULL WHERE id = 1 RETURNING id, email;
DELETE FROM users WHERE id = 1 RETURNING id, name;
SELECT COUNT(*) FROM users;
DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_insert_returning_star
-- Source: returning_clause_comprehensive_tdd.rs:66
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING *;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie') RETURNING id, name;
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0) RETURNING id, price * 1.1 AS price_with_tax;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', NULL) RETURNING *;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO source VALUES (1, 'test');
INSERT INTO target SELECT * FROM source RETURNING id, value;
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, name STRING);
INSERT INTO events VALUES (1, 'test') RETURNING id, UPPER(name) AS name_upper;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES () RETURNING *;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, status STRING);
INSERT INTO users VALUES (1, 'active'), (2, 'active'), (3, 'inactive');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

UPDATE users SET age = 31 WHERE id = 1 RETURNING id, age;
UPDATE users SET status = 'archived' WHERE status = 'active' RETURNING id, status;
UPDATE users SET age = 31 WHERE id = 1 RETURNING *;
UPDATE counters SET value = value + 5 WHERE id = 1 RETURNING id, value;
UPDATE users SET name = 'Bob' WHERE id = 999 RETURNING id, name;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING id, price, price * 0.2 AS tax;
UPDATE users SET email = NULL WHERE id = 1 RETURNING id, email;
DELETE FROM users WHERE id = 1 RETURNING id, name;
SELECT COUNT(*) FROM users;
DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_insert_returning_multi_row
-- Source: returning_clause_comprehensive_tdd.rs:87
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie') RETURNING id, name;
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0) RETURNING id, price * 1.1 AS price_with_tax;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', NULL) RETURNING *;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO source VALUES (1, 'test');
INSERT INTO target SELECT * FROM source RETURNING id, value;
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, name STRING);
INSERT INTO events VALUES (1, 'test') RETURNING id, UPPER(name) AS name_upper;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES () RETURNING *;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, status STRING);
INSERT INTO users VALUES (1, 'active'), (2, 'active'), (3, 'inactive');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

UPDATE users SET age = 31 WHERE id = 1 RETURNING id, age;
UPDATE users SET status = 'archived' WHERE status = 'active' RETURNING id, status;
UPDATE users SET age = 31 WHERE id = 1 RETURNING *;
UPDATE counters SET value = value + 5 WHERE id = 1 RETURNING id, value;
UPDATE users SET name = 'Bob' WHERE id = 999 RETURNING id, name;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING id, price, price * 0.2 AS tax;
UPDATE users SET email = NULL WHERE id = 1 RETURNING id, email;
DELETE FROM users WHERE id = 1 RETURNING id, name;
SELECT COUNT(*) FROM users;
DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_insert_returning_with_expression
-- Source: returning_clause_comprehensive_tdd.rs:110
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0) RETURNING id, price * 1.1 AS price_with_tax;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', NULL) RETURNING *;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO source VALUES (1, 'test');
INSERT INTO target SELECT * FROM source RETURNING id, value;
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, name STRING);
INSERT INTO events VALUES (1, 'test') RETURNING id, UPPER(name) AS name_upper;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES () RETURNING *;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, status STRING);
INSERT INTO users VALUES (1, 'active'), (2, 'active'), (3, 'inactive');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

UPDATE users SET age = 31 WHERE id = 1 RETURNING id, age;
UPDATE users SET status = 'archived' WHERE status = 'active' RETURNING id, status;
UPDATE users SET age = 31 WHERE id = 1 RETURNING *;
UPDATE counters SET value = value + 5 WHERE id = 1 RETURNING id, value;
UPDATE users SET name = 'Bob' WHERE id = 999 RETURNING id, name;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING id, price, price * 0.2 AS tax;
UPDATE users SET email = NULL WHERE id = 1 RETURNING id, email;
DELETE FROM users WHERE id = 1 RETURNING id, name;
SELECT COUNT(*) FROM users;
DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_insert_returning_with_null_values
-- Source: returning_clause_comprehensive_tdd.rs:130
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, email STRING);
INSERT INTO users VALUES (1, 'Alice', NULL) RETURNING *;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO source VALUES (1, 'test');
INSERT INTO target SELECT * FROM source RETURNING id, value;
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, name STRING);
INSERT INTO events VALUES (1, 'test') RETURNING id, UPPER(name) AS name_upper;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES () RETURNING *;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, status STRING);
INSERT INTO users VALUES (1, 'active'), (2, 'active'), (3, 'inactive');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

UPDATE users SET age = 31 WHERE id = 1 RETURNING id, age;
UPDATE users SET status = 'archived' WHERE status = 'active' RETURNING id, status;
UPDATE users SET age = 31 WHERE id = 1 RETURNING *;
UPDATE counters SET value = value + 5 WHERE id = 1 RETURNING id, value;
UPDATE users SET name = 'Bob' WHERE id = 999 RETURNING id, name;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING id, price, price * 0.2 AS tax;
UPDATE users SET email = NULL WHERE id = 1 RETURNING id, email;
DELETE FROM users WHERE id = 1 RETURNING id, name;
SELECT COUNT(*) FROM users;
DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_insert_select_returning
-- Source: returning_clause_comprehensive_tdd.rs:148
-- ============================================================================
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value STRING);
DROP TABLE IF EXISTS target;
CREATE TABLE target (id INT64, value STRING);
INSERT INTO source VALUES (1, 'test');
INSERT INTO target SELECT * FROM source RETURNING id, value;
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, name STRING);
INSERT INTO events VALUES (1, 'test') RETURNING id, UPPER(name) AS name_upper;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES () RETURNING *;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, status STRING);
INSERT INTO users VALUES (1, 'active'), (2, 'active'), (3, 'inactive');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

UPDATE users SET age = 31 WHERE id = 1 RETURNING id, age;
UPDATE users SET status = 'archived' WHERE status = 'active' RETURNING id, status;
UPDATE users SET age = 31 WHERE id = 1 RETURNING *;
UPDATE counters SET value = value + 5 WHERE id = 1 RETURNING id, value;
UPDATE users SET name = 'Bob' WHERE id = 999 RETURNING id, name;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING id, price, price * 0.2 AS tax;
UPDATE users SET email = NULL WHERE id = 1 RETURNING id, email;
DELETE FROM users WHERE id = 1 RETURNING id, name;
SELECT COUNT(*) FROM users;
DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_insert_returning_computed_column
-- Source: returning_clause_comprehensive_tdd.rs:170
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, name STRING);
INSERT INTO events VALUES (1, 'test') RETURNING id, UPPER(name) AS name_upper;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES () RETURNING *;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, status STRING);
INSERT INTO users VALUES (1, 'active'), (2, 'active'), (3, 'inactive');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

UPDATE users SET age = 31 WHERE id = 1 RETURNING id, age;
UPDATE users SET status = 'archived' WHERE status = 'active' RETURNING id, status;
UPDATE users SET age = 31 WHERE id = 1 RETURNING *;
UPDATE counters SET value = value + 5 WHERE id = 1 RETURNING id, value;
UPDATE users SET name = 'Bob' WHERE id = 999 RETURNING id, name;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING id, price, price * 0.2 AS tax;
UPDATE users SET email = NULL WHERE id = 1 RETURNING id, email;
DELETE FROM users WHERE id = 1 RETURNING id, name;
SELECT COUNT(*) FROM users;
DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_insert_returning_empty_result
-- Source: returning_clause_comprehensive_tdd.rs:188
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES () RETURNING *;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, status STRING);
INSERT INTO users VALUES (1, 'active'), (2, 'active'), (3, 'inactive');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

UPDATE users SET age = 31 WHERE id = 1 RETURNING id, age;
UPDATE users SET status = 'archived' WHERE status = 'active' RETURNING id, status;
UPDATE users SET age = 31 WHERE id = 1 RETURNING *;
UPDATE counters SET value = value + 5 WHERE id = 1 RETURNING id, value;
UPDATE users SET name = 'Bob' WHERE id = 999 RETURNING id, name;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING id, price, price * 0.2 AS tax;
UPDATE users SET email = NULL WHERE id = 1 RETURNING id, email;
DELETE FROM users WHERE id = 1 RETURNING id, name;
SELECT COUNT(*) FROM users;
DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_update_returning_single_row
-- Source: returning_clause_comprehensive_tdd.rs:206
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, status STRING);
INSERT INTO users VALUES (1, 'active'), (2, 'active'), (3, 'inactive');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

UPDATE users SET age = 31 WHERE id = 1 RETURNING id, age;
UPDATE users SET status = 'archived' WHERE status = 'active' RETURNING id, status;
UPDATE users SET age = 31 WHERE id = 1 RETURNING *;
UPDATE counters SET value = value + 5 WHERE id = 1 RETURNING id, value;
UPDATE users SET name = 'Bob' WHERE id = 999 RETURNING id, name;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING id, price, price * 0.2 AS tax;
UPDATE users SET email = NULL WHERE id = 1 RETURNING id, email;
DELETE FROM users WHERE id = 1 RETURNING id, name;
SELECT COUNT(*) FROM users;
DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_update_returning_multiple_rows
-- Source: returning_clause_comprehensive_tdd.rs:227
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, status STRING);
INSERT INTO users VALUES (1, 'active'), (2, 'active'), (3, 'inactive');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

UPDATE users SET status = 'archived' WHERE status = 'active' RETURNING id, status;
UPDATE users SET age = 31 WHERE id = 1 RETURNING *;
UPDATE counters SET value = value + 5 WHERE id = 1 RETURNING id, value;
UPDATE users SET name = 'Bob' WHERE id = 999 RETURNING id, name;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING id, price, price * 0.2 AS tax;
UPDATE users SET email = NULL WHERE id = 1 RETURNING id, email;
DELETE FROM users WHERE id = 1 RETURNING id, name;
SELECT COUNT(*) FROM users;
DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_update_returning_star
-- Source: returning_clause_comprehensive_tdd.rs:257
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

UPDATE users SET age = 31 WHERE id = 1 RETURNING *;
UPDATE counters SET value = value + 5 WHERE id = 1 RETURNING id, value;
UPDATE users SET name = 'Bob' WHERE id = 999 RETURNING id, name;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING id, price, price * 0.2 AS tax;
UPDATE users SET email = NULL WHERE id = 1 RETURNING id, email;
DELETE FROM users WHERE id = 1 RETURNING id, name;
SELECT COUNT(*) FROM users;
DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_update_returning_old_and_new_values
-- Source: returning_clause_comprehensive_tdd.rs:278
-- ============================================================================
DROP TABLE IF EXISTS counters;
CREATE TABLE counters (id INT64, value INT64);
INSERT INTO counters VALUES (1, 10);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

UPDATE counters SET value = value + 5 WHERE id = 1 RETURNING id, value;
UPDATE users SET name = 'Bob' WHERE id = 999 RETURNING id, name;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING id, price, price * 0.2 AS tax;
UPDATE users SET email = NULL WHERE id = 1 RETURNING id, email;
DELETE FROM users WHERE id = 1 RETURNING id, name;
SELECT COUNT(*) FROM users;
DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_update_returning_no_rows_matched
-- Source: returning_clause_comprehensive_tdd.rs:300
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

UPDATE users SET name = 'Bob' WHERE id = 999 RETURNING id, name;
UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING id, price, price * 0.2 AS tax;
UPDATE users SET email = NULL WHERE id = 1 RETURNING id, email;
DELETE FROM users WHERE id = 1 RETURNING id, name;
SELECT COUNT(*) FROM users;
DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_update_returning_with_expression
-- Source: returning_clause_comprehensive_tdd.rs:319
-- ============================================================================
DROP TABLE IF EXISTS products;
CREATE TABLE products (id INT64, price FLOAT64);
INSERT INTO products VALUES (1, 100.0);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

UPDATE products SET price = price * 1.1 WHERE id = 1 RETURNING id, price, price * 0.2 AS tax;
UPDATE users SET email = NULL WHERE id = 1 RETURNING id, email;
DELETE FROM users WHERE id = 1 RETURNING id, name;
SELECT COUNT(*) FROM users;
DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_update_returning_set_to_null
-- Source: returning_clause_comprehensive_tdd.rs:341
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, email STRING);
INSERT INTO users VALUES (1, 'alice@example.com');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

UPDATE users SET email = NULL WHERE id = 1 RETURNING id, email;
DELETE FROM users WHERE id = 1 RETURNING id, name;
SELECT COUNT(*) FROM users;
DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_delete_returning_single_row
-- Source: returning_clause_comprehensive_tdd.rs:365
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

DELETE FROM users WHERE id = 1 RETURNING id, name;
SELECT COUNT(*) FROM users;
DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_delete_returning_multiple_rows
-- Source: returning_clause_comprehensive_tdd.rs:394
-- ============================================================================
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, level STRING, message STRING);
INSERT INTO logs VALUES (1, 'DEBUG', 'msg1'), (2, 'DEBUG', 'msg2'), (3, 'ERROR', 'msg3');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

DELETE FROM logs WHERE level = 'DEBUG' RETURNING id, message;
DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_delete_returning_star
-- Source: returning_clause_comprehensive_tdd.rs:416
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING, age INT64);
INSERT INTO users VALUES (1, 'Alice', 30);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

DELETE FROM users WHERE id = 1 RETURNING *;
DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_delete_returning_no_rows_matched
-- Source: returning_clause_comprehensive_tdd.rs:437
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

DELETE FROM users WHERE id = 999 RETURNING *;
DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_delete_returning_with_expression
-- Source: returning_clause_comprehensive_tdd.rs:456
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'alice');
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

DELETE FROM users WHERE id = 1 RETURNING id, UPPER(name) AS name_upper;
DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_delete_returning_all_rows
-- Source: returning_clause_comprehensive_tdd.rs:476
-- ============================================================================
DROP TABLE IF EXISTS temp;
CREATE TABLE temp (id INT64, value STRING);
INSERT INTO temp VALUES (1, 'a'), (2, 'b'), (3, 'c');
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

DELETE FROM temp RETURNING id;
SELECT COUNT(*) FROM temp;
WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_returning_invalid_column_name
-- Source: returning_clause_comprehensive_tdd.rs:503
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING nonexistent_column;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_returning_ambiguous_column
-- Source: returning_clause_comprehensive_tdd.rs:515
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS updates;
CREATE TABLE updates (id INT64, new_name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_returning_with_aggregate_function_error
-- Source: returning_clause_comprehensive_tdd.rs:535
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 30) RETURNING COUNT(*);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_returning_subquery_error
-- Source: returning_clause_comprehensive_tdd.rs:548
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS counts;
CREATE TABLE counts (total INT64);
INSERT INTO counts VALUES (100);
INSERT INTO users VALUES (1, 'Alice') RETURNING id, (SELECT total FROM counts) AS total;
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_returning_with_cte
-- Source: returning_clause_comprehensive_tdd.rs:579
-- ============================================================================
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
DROP TABLE IF EXISTS audit;
CREATE TABLE audit (id INT64, action STRING, row_id INT64);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, name STRING);
INSERT INTO users VALUES (1, 'Alice') RETURNING id;
INSERT INTO audit VALUES (1, 'created', 1);
DROP TABLE IF EXISTS users;
CREATE TABLE users (id INT64, age INT64);
INSERT INTO users VALUES (1, 25) \ RETURNING id, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_category;
DROP TABLE IF EXISTS seq;
CREATE TABLE seq (id INT64, value STRING);
INSERT INTO seq VALUES (1, 'first'), (2, 'second'), (3, 'third') \ RETURNING id, value;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (id INT64, value INT64);
DROP TABLE IF EXISTS nullable;
CREATE TABLE nullable (id INT64, a STRING, b STRING, c STRING);
INSERT INTO nullable VALUES (1, NULL, NULL, NULL) RETURNING *;

WITH data AS (SELECT 1 AS id, 'Alice' AS name) \ INSERT INTO users SELECT * FROM data RETURNING *;
SELECT * FROM (INSERT INTO users VALUES (1, 'Alice') RETURNING *) AS inserted;
UPDATE users SET name = 'Alice Updated' WHERE id = 1 RETURNING id, name;

-- ============================================================================
-- Test: test_ctas_with_self_join
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:1045
-- ============================================================================
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (id INT64, name STRING, manager_id INT64);
INSERT INTO employees VALUES (1, 'Alice', NULL), (2, 'Bob', 1), (3, 'Charlie', 1);
CREATE TABLE employee_managers AS SELECT e.name AS employee, m.name AS manager FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES ('A', 10.5), ('A', 12.3), ('A', 11.1), ('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES (1, 10.0), (1, 20.0), (1, 30.0), (2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_large_result_set
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:1079
-- ============================================================================
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
CREATE TABLE large_copy AS SELECT * FROM source;
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES ('A', 10.5), ('A', 12.3), ('A', 11.1), ('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES (1, 10.0), (1, 20.0), (1, 30.0), (2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_cross_join
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:1105
-- ============================================================================
DROP TABLE IF EXISTS colors;
CREATE TABLE colors (color STRING);
DROP TABLE IF EXISTS sizes;
CREATE TABLE sizes (size STRING);
INSERT INTO colors VALUES ('Red'), ('Blue');
INSERT INTO sizes VALUES ('S'), ('M'), ('L');
CREATE TABLE products AS SELECT color, size FROM colors CROSS JOIN sizes;
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES ('A', 10.5), ('A', 12.3), ('A', 11.1), ('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES (1, 10.0), (1, 20.0), (1, 30.0), (2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_string_transformations
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:1140
-- ============================================================================
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('alice'), ('bob'), ('charlie');
CREATE TABLE upper_names AS SELECT UPPER(name) AS name_upper, LENGTH(name) AS name_len FROM names;
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES ('A', 10.5), ('A', 12.3), ('A', 11.1), ('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES (1, 10.0), (1, 20.0), (1, 30.0), (2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT name_upper FROM upper_names ORDER BY name_upper;
SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_case_expressions
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:1172
-- ============================================================================
DROP TABLE IF EXISTS scores;
CREATE TABLE scores (student STRING, score INT64);
INSERT INTO scores VALUES ('Alice', 95), ('Bob', 72), ('Charlie', 88);
CREATE TABLE grades AS SELECT student, score, CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' WHEN score >= 70 THEN 'C' ELSE 'F' END AS grade FROM scores;
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES ('A', 10.5), ('A', 12.3), ('A', 11.1), ('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES (1, 10.0), (1, 20.0), (1, 30.0), (2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT grade FROM grades WHERE student = 'Alice';
SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_ctas_with_numeric_precision
-- Source: table_ddl_enhancements_comprehensive_tdd.rs:1211
-- ============================================================================
DROP TABLE IF EXISTS financials;
CREATE TABLE financials (amount NUMERIC(10, 2));
INSERT INTO financials VALUES (12345.67);
CREATE TABLE copy AS SELECT amount FROM financials;
DROP TABLE IF EXISTS events;
CREATE TABLE events (event_date DATE);
INSERT INTO events VALUES (DATE '2024-01-15');
CREATE TABLE processed_events AS SELECT event_date, EXTRACT(YEAR FROM event_date) AS year, EXTRACT(MONTH FROM event_date) AS month FROM events;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x INT64, y INT64);
INSERT INTO source VALUES (10, 20);
CREATE TABLE dest AS SELECT x AS first_col, y AS second_col, x + y AS sum_col FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (sensor STRING, value FLOAT64);
INSERT INTO measurements VALUES ('A', 10.5), ('A', 12.3), ('A', 11.1), ('B', 20.0), ('B', 22.5);
CREATE TABLE sensor_stats AS SELECT sensor, COUNT(*) AS count, AVG(value) AS avg_value, MIN(value) AS min_value, MAX(value) AS max_value FROM measurements GROUP BY sensor;
CREATE TABLE bad AS SELECT * FROM nonexistent_table;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, NULL), (2, NULL), (3, NULL);
CREATE TABLE dest AS SELECT * FROM source;
DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (group_id INT64, value FLOAT64);
INSERT INTO measurements VALUES (1, 10.0), (1, 20.0), (1, 30.0), (2, 5.0), (2, 15.0), (2, 25.0);
CREATE TABLE stats AS SELECT group_id, STDDEV(value) AS std, VARIANCE(value) AS var, MEDIAN(value) AS med FROM measurements GROUP BY group_id;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, arr ARRAY<INT64>);
INSERT INTO data VALUES (1, [1, 2, 3]), (2, [4, 5, 6]);
CREATE TABLE array_lengths AS SELECT id, ARRAY_LENGTH(arr) AS length FROM data;
CREATE TABLE hierarchy AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 10 ) SELECT n FROM cte;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, value INT64);
INSERT INTO source VALUES (1, 100), (2, 200), (3, 300);
DROP VIEW IF EXISTS high_values;
CREATE VIEW high_values AS SELECT * FROM source WHERE value > 150;
CREATE TABLE materialized AS SELECT * FROM high_values;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64, val1 INT64, val2 INT64);
INSERT INTO source VALUES (1, NULL, 10), (2, 20, NULL), (3, 30, 30);
CREATE TABLE cleaned AS SELECT id, COALESCE(val1, val2, 0) AS value, NULLIF(val1, val2) AS diff_value FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (x FLOAT64, y FLOAT64);
INSERT INTO source VALUES (3.0, 4.0), (5.0, 12.0);
CREATE TABLE computed AS SELECT x, y, x * x + y * y AS sum_of_squares, SQRT(x * x + y * y) AS hypotenuse FROM source;
DROP TABLE IF EXISTS sales;
CREATE TABLE sales (product STRING, amount INT64);
INSERT INTO sales VALUES ('A', 100), ('A', 200), ('B', 50), ('B', 75), ('C', 500), ('C', 600);
CREATE TABLE high_volume AS SELECT product, SUM(amount) AS total FROM sales GROUP BY product HAVING SUM(amount) > 200;
DROP TABLE IF EXISTS users;
CREATE TABLE users (user_id INT64, name STRING);
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (order_id INT64, user_id INT64, amount INT64);
DROP TABLE IF EXISTS products;
CREATE TABLE products (order_id INT64, product STRING);
INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
INSERT INTO orders VALUES (101, 1, 50), (102, 2, 75);
INSERT INTO products VALUES (101, 'Book'), (102, 'Pen');
CREATE TABLE complete_orders AS SELECT u.name, o.amount, p.product FROM users u JOIN orders o ON u.user_id = o.user_id JOIN products p ON o.order_id = p.order_id;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2);
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
CREATE TABLE IF NOT EXISTS dest AS SELECT * FROM source;
DROP TABLE IF EXISTS source;
CREATE TABLE source (id INT64);
INSERT INTO source VALUES (1), (2), (3), (4), (5);
CREATE TABLE paginated AS SELECT * FROM source LIMIT 2 OFFSET 2;
DROP TABLE IF EXISTS numbers;
CREATE TABLE numbers (n INT64);
INSERT INTO numbers VALUES (1), (5), (10), (15), (20);
CREATE TABLE filtered AS SELECT n FROM numbers WHERE n BETWEEN 5 AND 15;
DROP TABLE IF EXISTS data;
CREATE TABLE data (category STRING, value INT64);
INSERT INTO data VALUES ('A', 1), ('B', 2), ('C', 3), ('D', 4);
CREATE TABLE selected AS SELECT * FROM data WHERE category IN ('A', 'C');
DROP TABLE IF EXISTS names;
CREATE TABLE names (name STRING);
INSERT INTO names VALUES ('Alice'), ('Bob'), ('Andrew'), ('Charlie');
CREATE TABLE a_names AS SELECT name FROM names WHERE name LIKE 'A%';
DROP TABLE IF EXISTS empty_source;
CREATE TABLE empty_source (id INT64, name STRING);
CREATE TABLE empty_dest AS SELECT * FROM empty_source;
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64);
INSERT INTO data VALUES (1), (2), (3), (4), (5);
CREATE TABLE filtered AS SELECT * FROM data WHERE id NOT IN (2, 4);
DROP TABLE IF EXISTS data;
CREATE TABLE data (id INT64, value INT64);
INSERT INTO data VALUES (1, NULL), (2, 20), (3, NULL), (4, 40);
CREATE TABLE nulls_only AS SELECT * FROM data WHERE value IS NULL;
CREATE TABLE not_nulls AS SELECT * FROM data WHERE value IS NOT NULL;

SELECT amount FROM copy;
SELECT year, month FROM processed_events;
SELECT first_col, second_col, sum_col FROM dest;
SELECT * FROM sensor_stats WHERE sensor = 'A';
SELECT value FROM dest;
SELECT hypotenuse FROM computed ORDER BY x;

-- ============================================================================
-- Test: test_timestamptz_with_offset
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:23
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:00' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15T10:00:00+05:00' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP '2024-01-15 10:00:00' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AT TIME ZONE 'UTC' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AT TIME ZONE 'Asia/Tokyo' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-10 02:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-11-03 01:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-09 12:00:00 America/New_York' + INTERVAL '24' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' + INTERVAL '2' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' - INTERVAL '3' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' = TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS are_equal;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' < TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS is_less;
SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_timestamptz_with_named_timezone
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:40
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15T10:00:00+05:00' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP '2024-01-15 10:00:00' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AT TIME ZONE 'UTC' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AT TIME ZONE 'Asia/Tokyo' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-10 02:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-11-03 01:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-09 12:00:00 America/New_York' + INTERVAL '24' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' + INTERVAL '2' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' - INTERVAL '3' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' = TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS are_equal;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' < TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS is_less;
SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_timestamptz_utc
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:58
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15T10:00:00+05:00' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP '2024-01-15 10:00:00' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AT TIME ZONE 'UTC' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AT TIME ZONE 'Asia/Tokyo' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-10 02:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-11-03 01:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-09 12:00:00 America/New_York' + INTERVAL '24' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' + INTERVAL '2' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' - INTERVAL '3' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' = TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS are_equal;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' < TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS is_less;
SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_timestamptz_iso8601_format
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:73
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP WITH TIME ZONE '2024-01-15T10:00:00+05:00' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP '2024-01-15 10:00:00' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AT TIME ZONE 'UTC' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AT TIME ZONE 'Asia/Tokyo' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-10 02:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-11-03 01:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-09 12:00:00 America/New_York' + INTERVAL '24' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' + INTERVAL '2' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' - INTERVAL '3' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' = TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS are_equal;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' < TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS is_less;
SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_at_time_zone_conversion
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:92
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP '2024-01-15 10:00:00' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AT TIME ZONE 'UTC' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AT TIME ZONE 'Asia/Tokyo' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-10 02:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-11-03 01:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-09 12:00:00 America/New_York' + INTERVAL '24' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' + INTERVAL '2' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' - INTERVAL '3' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' = TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS are_equal;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' < TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS is_less;
SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_at_time_zone_from_timestamp_to_timestamptz
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:112
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP '2024-01-15 10:00:00' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AT TIME ZONE 'UTC' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AT TIME ZONE 'Asia/Tokyo' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-10 02:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-11-03 01:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-09 12:00:00 America/New_York' + INTERVAL '24' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' + INTERVAL '2' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' - INTERVAL '3' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' = TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS are_equal;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' < TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS is_less;
SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_at_time_zone_round_trip
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:129
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AT TIME ZONE 'UTC' AT TIME ZONE 'America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AT TIME ZONE 'Asia/Tokyo' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-10 02:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-11-03 01:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-09 12:00:00 America/New_York' + INTERVAL '24' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' + INTERVAL '2' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' - INTERVAL '3' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' = TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS are_equal;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' < TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS is_less;
SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_at_time_zone_multiple_conversions
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:152
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AT TIME ZONE 'Asia/Tokyo' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-10 02:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-11-03 01:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-09 12:00:00 America/New_York' + INTERVAL '24' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' + INTERVAL '2' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' - INTERVAL '3' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' = TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS are_equal;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' < TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS is_less;
SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_dst_spring_forward
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:178
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP WITH TIME ZONE '2024-03-10 02:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-11-03 01:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-09 12:00:00 America/New_York' + INTERVAL '24' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' + INTERVAL '2' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' - INTERVAL '3' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' = TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS are_equal;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' < TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS is_less;
SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_dst_fall_back
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:199
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP WITH TIME ZONE '2024-11-03 01:30:00 America/New_York' AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-03-09 12:00:00 America/New_York' + INTERVAL '24' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' + INTERVAL '2' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' - INTERVAL '3' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' = TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS are_equal;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' < TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS is_less;
SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_dst_arithmetic_across_boundary
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:219
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP WITH TIME ZONE '2024-03-09 12:00:00 America/New_York' + INTERVAL '24' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' + INTERVAL '2' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' - INTERVAL '3' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' = TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS are_equal;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' < TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS is_less;
SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_timestamptz_plus_interval
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:248
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' + INTERVAL '2' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' - INTERVAL '3' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' = TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS are_equal;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' < TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS is_less;
SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_timestamptz_minus_interval
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:268
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' - INTERVAL '3' HOUR AS ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' = TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS are_equal;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' < TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS is_less;
SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_timestamptz_difference
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:288
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' = TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS are_equal;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' < TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS is_less;
SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_timestamptz_difference_different_timezones
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:310
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' - TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS time_diff;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' = TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS are_equal;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' < TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS is_less;
SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_timestamptz_equality_different_timezone
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:336
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' = TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS are_equal;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' < TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS is_less;
SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_timestamptz_less_than
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:358
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' < TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC' AS is_less;
SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_timestamptz_ordering_in_table
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:378
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 America/New_York'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 Asia/Tokyo');
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT id FROM events ORDER BY event_time;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_timestamptz_comparison_with_plain_timestamp
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:416
-- ============================================================================
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP '2024-01-15 09:00:00' AS is_greater;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_timestamptz_null_comparison
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:442
-- ============================================================================
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) = TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS result;
SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_timestamptz_null_in_table
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:463
-- ============================================================================
DROP TABLE IF EXISTS logs;
CREATE TABLE logs (id INT64, logged_at TIMESTAMP WITH TIME ZONE);
INSERT INTO logs VALUES (1, NULL);
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT logged_at FROM logs WHERE id = 1;
SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;

-- ============================================================================
-- Test: test_timestamptz_null_arithmetic
-- Source: timestamp_with_time_zone_comprehensive_tdd.rs:485
-- ============================================================================
DROP TABLE IF EXISTS events;
CREATE TABLE events (id INT64, event_time TIMESTAMP WITH TIME ZONE);
INSERT INTO events VALUES (1, TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC'), (2, TIMESTAMP WITH TIME ZONE '2024-01-15 15:00:00 UTC'), (3, TIMESTAMP WITH TIME ZONE '2024-01-15 20:00:00 UTC');
DROP TABLE IF EXISTS transactions;
CREATE TABLE transactions (id INT64, amount INT64, tx_time TIMESTAMP WITH TIME ZONE);
INSERT INTO transactions VALUES (1, 100, TIMESTAMP WITH TIME ZONE '2024-01-15 10:30:00 UTC'), (2, 200, TIMESTAMP WITH TIME ZONE '2024-01-15 10:45:00 UTC'), (3, 150, TIMESTAMP WITH TIME ZONE '2024-01-15 11:15:00 UTC');

SELECT CAST(NULL AS TIMESTAMP WITH TIME ZONE) + INTERVAL '1' HOUR AS result;
SELECT TIMESTAMP WITH TIME ZONE '1970-01-01 00:00:00 UTC' AS min_ts;
SELECT TIMESTAMP WITH TIME ZONE '2100-12-31 23:59:59 UTC' AS max_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00.123456 UTC' AS precise_ts;
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 Invalid/Timezone';
SELECT TIMESTAMP WITH TIME ZONE 'not-a-timestamp UTC';
SELECT TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+25:00';
SELECT id FROM events WHERE event_time > TIMESTAMP WITH TIME ZONE '2024-01-15 12:00:00 UTC';
SELECT EXTRACT(YEAR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS year, EXTRACT(MONTH FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS month, EXTRACT(DAY FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS day, EXTRACT(HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC') AS hour;
SELECT DATE_TRUNC('hour', tx_time) AS hour, SUM(amount) AS total FROM transactions GROUP BY DATE_TRUNC('hour', tx_time) ORDER BY hour;
SELECT CASE WHEN TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' > TIMESTAMP WITH TIME ZONE '2024-01-15 08:00:00 UTC' THEN 'Later' ELSE 'Earlier' END AS comparison;
SELECT CAST(TIMESTAMP '2024-01-15 10:00:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York' AS TIMESTAMP) AS ts;
SELECT CAST('2024-01-15 10:00:00+05:00' AS TIMESTAMP WITH TIME ZONE) AS ts;
SELECT CAST(TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 UTC' AS STRING) AS ts_str;
SELECT CURRENT_TIMESTAMP AS now;
SELECT EXTRACT(TIMEZONE_HOUR FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_hour, EXTRACT(TIMEZONE_MINUTE FROM TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00+05:30') AS tz_min;
SELECT FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', TIMESTAMP WITH TIME ZONE '2024-01-15 10:00:00 America/New_York') AS formatted;
