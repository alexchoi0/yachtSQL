//! ClickHouse-specific aggregate functions
//!
//! Implements ClickHouse aggregate functions:
//! - UNIQ family - Approximate cardinality estimation
//! - TOP_K - Top-K most frequent values
//! - QUANTILE family - Percentile approximation
//! - ARG_MIN/ARG_MAX - Value at min/max argument
//! - GROUP_ARRAY - Array aggregation variants
//! - ANY family - Non-deterministic value selection

use super::{Accumulator, AggregateFunction};
use crate::approximate::{HyperLogLogPlusPlus, TDigest};
use core::error::{Error, Result};
use core::types::{DataType, Value};
use rust_decimal::prelude::ToPrimitive;
use std::cmp::Ordering;
use std::collections::HashMap;
use std::hash::{Hash, Hasher};
use std::sync::LazyLock;


// Static type arrays for arg_types() methods
static ARRAY_OF_UNKNOWN: LazyLock<Vec<DataType>> = LazyLock::new(|| vec![DataType::Array(Box::new(DataType::Unknown))]);
static ARRAY_OF_INT64: LazyLock<Vec<DataType>> = LazyLock::new(|| vec![DataType::Array(Box::new(DataType::Int64))]);


// === UNIQ Family (Cardinality Estimation) ===================================== //

/// UNIQ - Approximate cardinality using HyperLogLog
#[derive(Debug, Clone)]
pub struct UniqAccumulator {
    estimator: HyperLogLogPlusPlus,
}

impl Default for UniqAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl UniqAccumulator {
    pub fn new() -> Self {
        Self {
            estimator: HyperLogLogPlusPlus::new(),
        }
    }
}

impl Accumulator for UniqAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if value.is_null() {
            return Ok(());
        }
        self.estimator.add(&HashableValue(value));
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "UNIQ merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Int64(self.estimator.estimate() as i64))
    }

    fn reset(&mut self) {
        self.estimator = HyperLogLogPlusPlus::new();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct UniqFunction;

impl AggregateFunction for UniqFunction {
    fn name(&self) -> &str {
        "UNIQ"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(UniqAccumulator::new())
    }
}

/// UNIQ_EXACT - Exact cardinality (same as COUNT(DISTINCT))
#[derive(Debug, Clone)]
pub struct UniqExactAccumulator {
    values: std::collections::HashSet<String>,
}

impl Default for UniqExactAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl UniqExactAccumulator {
    pub fn new() -> Self {
        Self {
            values: std::collections::HashSet::new(),
        }
    }
}

impl Accumulator for UniqExactAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if value.is_null() {
            return Ok(());
        }
        self.values.insert(value_to_string(value));
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "UNIQ_EXACT merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Int64(self.values.len() as i64))
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct UniqExactFunction;

impl AggregateFunction for UniqExactFunction {
    fn name(&self) -> &str {
        "UNIQ_EXACT"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(UniqExactAccumulator::new())
    }
}

// UNIQ_HLL12 - Alias for UNIQ (both use HyperLogLog)
#[derive(Debug, Default, Clone, Copy)]
pub struct UniqHll12Function;

impl AggregateFunction for UniqHll12Function {
    fn name(&self) -> &str {
        "UNIQ_HLL12"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(UniqAccumulator::new())
    }
}

/// UNIQ_COMBINED - Combined cardinality algorithm (HLL + Linear Counting)
#[derive(Debug, Clone)]
pub struct UniqCombinedAccumulator {
    estimator: HyperLogLogPlusPlus,
}

impl Default for UniqCombinedAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl UniqCombinedAccumulator {
    pub fn new() -> Self {
        Self {
            estimator: HyperLogLogPlusPlus::new(),
        }
    }
}

impl Accumulator for UniqCombinedAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if value.is_null() {
            return Ok(());
        }
        self.estimator.add(&HashableValue(value));
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "UNIQ_COMBINED merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Int64(self.estimator.estimate() as i64))
    }

    fn reset(&mut self) {
        self.estimator = HyperLogLogPlusPlus::new();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct UniqCombinedFunction;

impl AggregateFunction for UniqCombinedFunction {
    fn name(&self) -> &str {
        "UNIQ_COMBINED"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(UniqCombinedAccumulator::new())
    }
}

/// UNIQ_COMBINED_64 - Combined algorithm with 64-bit precision
#[derive(Debug, Default, Clone, Copy)]
pub struct UniqCombined64Function;

impl AggregateFunction for UniqCombined64Function {
    fn name(&self) -> &str {
        "UNIQ_COMBINED_64"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(UniqCombinedAccumulator::new())
    }
}

/// UNIQ_THETA_SKETCH - Approximate cardinality using Theta Sketch
#[derive(Debug, Clone)]
pub struct UniqThetaSketchAccumulator {
    estimator: HyperLogLogPlusPlus,
}

impl Default for UniqThetaSketchAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl UniqThetaSketchAccumulator {
    pub fn new() -> Self {
        Self {
            estimator: HyperLogLogPlusPlus::new(),
        }
    }
}

impl Accumulator for UniqThetaSketchAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if value.is_null() {
            return Ok(());
        }
        self.estimator.add(&HashableValue(value));
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "UNIQ_THETA_SKETCH merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Int64(self.estimator.estimate() as i64))
    }

    fn reset(&mut self) {
        self.estimator = HyperLogLogPlusPlus::new();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct UniqThetaSketchFunction;

impl AggregateFunction for UniqThetaSketchFunction {
    fn name(&self) -> &str {
        "UNIQ_THETA_SKETCH"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(UniqThetaSketchAccumulator::new())
    }
}

// === TOP_K (Top-K Frequent Items) ============================================= //

/// TOP_K - Top-K most frequent values
#[derive(Debug, Clone)]
pub struct TopKAccumulator {
    counts: HashMap<String, i64>,
    k: usize,
}

impl TopKAccumulator {
    pub fn new(k: i64) -> Self {
        Self {
            counts: HashMap::new(),
            k: k.max(1) as usize,
        }
    }
}

impl Accumulator for TopKAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if value.is_null() {
            return Ok(());
        }

        let key = value_to_string(value);
        *self.counts.entry(key).or_insert(0) += 1;
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "TOP_K merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let mut items: Vec<_> = self.counts.iter().collect();
        items.sort_by(|a, b| b.1.cmp(a.1).then_with(|| a.0.cmp(b.0)));

        let result: Vec<Value> = items
            .into_iter()
            .take(self.k)
            .map(|(key, _)| Value::String(key.clone()))
            .collect();

        Ok(Value::Array(result))
    }

    fn reset(&mut self) {
        self.counts.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone, Copy)]
pub struct TopKFunction {
    k: i64,
}

impl TopKFunction {
    pub fn new(k: i64) -> Self {
        Self { k }
    }
}

impl Default for TopKFunction {
    fn default() -> Self {
        Self::new(10)
    }
}

impl AggregateFunction for TopKFunction {
    fn name(&self) -> &str {
        "TOP_K"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::String)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(TopKAccumulator::new(self.k))
    }
}

// === QUANTILE Family (Percentile Approximation) =============================== //

/// QUANTILE - Single quantile approximation using T-Digest
#[derive(Debug, Clone)]
pub struct QuantileAccumulator {
    digest: TDigest,
    quantile: f64,
}

impl QuantileAccumulator {
    pub fn new(quantile: f64) -> Self {
        Self {
            digest: TDigest::new(),
            quantile: quantile.clamp(0.0, 1.0),
        }
    }
}

impl Accumulator for QuantileAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(num) = numeric_value_to_f64(value)? {
            self.digest.add(num);
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "QUANTILE merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let mut digest_clone = self.digest.clone();
        let result = digest_clone.quantile(self.quantile);
        Ok(Value::Float64(result))
    }

    fn reset(&mut self) {
        self.digest = TDigest::new();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone, Copy)]
pub struct QuantileFunction {
    quantile: f64,
}

impl QuantileFunction {
    pub fn new(quantile: f64) -> Self {
        Self { quantile }
    }
}

impl Default for QuantileFunction {
    fn default() -> Self {
        Self::new(0.5) // Median by default
    }
}

impl AggregateFunction for QuantileFunction {
    fn name(&self) -> &str {
        "QUANTILE"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(QuantileAccumulator::new(self.quantile))
    }
}

/// QUANTILE_EXACT - Exact quantile using sorting
#[derive(Debug, Clone)]
pub struct QuantileExactAccumulator {
    values: Vec<f64>,
    quantile: f64,
}

impl QuantileExactAccumulator {
    pub fn new(quantile: f64) -> Self {
        Self {
            values: Vec::new(),
            quantile: quantile.clamp(0.0, 1.0),
        }
    }
}

impl Accumulator for QuantileExactAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(num) = numeric_value_to_f64(value)? {
            self.values.push(num);
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "QUANTILE_EXACT merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.values.is_empty() {
            return Ok(Value::Null);
        }

        let mut sorted = self.values.clone();
        sorted.sort_by(|a, b| a.partial_cmp(b).unwrap_or(Ordering::Equal));

        let idx = ((sorted.len() as f64 - 1.0) * self.quantile) as usize;
        let result = sorted[idx.min(sorted.len() - 1)];

        Ok(Value::Float64(result))
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone, Copy)]
pub struct QuantileExactFunction {
    quantile: f64,
}

impl QuantileExactFunction {
    pub fn new(quantile: f64) -> Self {
        Self { quantile }
    }
}

impl Default for QuantileExactFunction {
    fn default() -> Self {
        Self::new(0.5)
    }
}

impl AggregateFunction for QuantileExactFunction {
    fn name(&self) -> &str {
        "QUANTILE_EXACT"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(QuantileExactAccumulator::new(self.quantile))
    }
}

// === ARG_MIN / ARG_MAX (Value at Min/Max Argument) ============================ //

/// ARG_MIN - Returns value corresponding to minimum argument
#[derive(Debug, Clone)]
pub struct ArgMinAccumulator {
    min_arg: Option<f64>,
    value_at_min: Option<Value>,
}

impl Default for ArgMinAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl ArgMinAccumulator {
    pub fn new() -> Self {
        Self {
            min_arg: None,
            value_at_min: None,
        }
    }
}

impl Accumulator for ArgMinAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        // Expect [arg, value] array
        if value.is_null() {
            return Ok(());
        }

        let (arg, val) = if let Some(arr) = value.as_array() {
            if arr.len() == 2 {
                if arr[0].is_null() {
                    return Ok(());
                }
                (&arr[0], &arr[1])
            } else {
                return Err(Error::TypeMismatch {
                    expected: "ARRAY with 2 values [arg, value]".to_string(),
                    actual: value.data_type().to_string(),
                });
            }
        } else {
            return Err(Error::TypeMismatch {
                expected: "ARRAY with 2 values [arg, value]".to_string(),
                actual: value.data_type().to_string(),
            });
        };

        let arg_f64 = numeric_value_to_f64(arg)?.ok_or_else(|| Error::TypeMismatch {
            expected: "NUMERIC".to_string(),
            actual: "NULL".to_string(),
        })?;

        match self.min_arg {
            None => {
                self.min_arg = Some(arg_f64);
                self.value_at_min = Some(val.clone());
            }
            Some(current_min) if arg_f64 < current_min => {
                self.min_arg = Some(arg_f64);
                self.value_at_min = Some(val.clone());
            }
            _ => {}
        }

        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "ARG_MIN merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(self.value_at_min.clone().unwrap_or(Value::Null))
    }

    fn reset(&mut self) {
        self.min_arg = None;
        self.value_at_min = None;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct ArgMinFunction;

impl AggregateFunction for ArgMinFunction {
    fn name(&self) -> &str {
        "ARG_MIN"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown, DataType::Unknown]
    }

    fn return_type(&self, arg_types: &[DataType]) -> Result<DataType> {
        // Return the type of the second argument (the value column that gets returned)
        // ARG_MIN(arg, value) returns value where arg is minimum
        Ok(arg_types.get(1).cloned().unwrap_or(DataType::String))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(ArgMinAccumulator::new())
    }
}

/// ARG_MAX - Returns value corresponding to maximum argument
#[derive(Debug, Clone)]
pub struct ArgMaxAccumulator {
    max_arg: Option<f64>,
    value_at_max: Option<Value>,
}

impl Default for ArgMaxAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl ArgMaxAccumulator {
    pub fn new() -> Self {
        Self {
            max_arg: None,
            value_at_max: None,
        }
    }
}

impl Accumulator for ArgMaxAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        // Expect [arg, value] array
        if value.is_null() {
            return Ok(());
        }

        let (arg, val) = if let Some(arr) = value.as_array() {
            if arr.len() == 2 {
                if arr[0].is_null() {
                    return Ok(());
                }
                (&arr[0], &arr[1])
            } else {
                return Err(Error::TypeMismatch {
                    expected: "ARRAY with 2 values [arg, value]".to_string(),
                    actual: value.data_type().to_string(),
                });
            }
        } else {
            return Err(Error::TypeMismatch {
                expected: "ARRAY with 2 values [arg, value]".to_string(),
                actual: value.data_type().to_string(),
            });
        };

        let arg_f64 = numeric_value_to_f64(arg)?.ok_or_else(|| Error::TypeMismatch {
            expected: "NUMERIC".to_string(),
            actual: "NULL".to_string(),
        })?;

        match self.max_arg {
            None => {
                self.max_arg = Some(arg_f64);
                self.value_at_max = Some(val.clone());
            }
            Some(current_max) if arg_f64 > current_max => {
                self.max_arg = Some(arg_f64);
                self.value_at_max = Some(val.clone());
            }
            _ => {}
        }

        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "ARG_MAX merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(self.value_at_max.clone().unwrap_or(Value::Null))
    }

    fn reset(&mut self) {
        self.max_arg = None;
        self.value_at_max = None;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct ArgMaxFunction;

impl AggregateFunction for ArgMaxFunction {
    fn name(&self) -> &str {
        "ARG_MAX"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown, DataType::Unknown]
    }

    fn return_type(&self, arg_types: &[DataType]) -> Result<DataType> {
        // Return the type of the second argument (the value column that gets returned)
        // ARG_MAX(arg, value) returns value where arg is maximum
        Ok(arg_types.get(1).cloned().unwrap_or(DataType::String))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(ArgMaxAccumulator::new())
    }
}

// === GROUP_ARRAY (Array Aggregation) =========================================== //

/// GROUP_ARRAY - Collect values into array (ClickHouse variant of ARRAY_AGG)
#[derive(Debug, Clone)]
pub struct GroupArrayAccumulator {
    values: Vec<Value>,
}

impl Default for GroupArrayAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl GroupArrayAccumulator {
    pub fn new() -> Self {
        Self { values: Vec::new() }
    }
}

impl Accumulator for GroupArrayAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        // ClickHouse GROUP_ARRAY includes NULLs (unlike ARRAY_AGG)
        self.values.push(value.clone());
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "GROUP_ARRAY merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.values.is_empty() {
            return Ok(Value::Array(vec![]));
        }
        Ok(Value::Array(self.values.clone()))
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct GroupArrayFunction;

impl AggregateFunction for GroupArrayFunction {
    fn name(&self) -> &str {
        "GROUP_ARRAY"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Unknown)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(GroupArrayAccumulator::new())
    }
}

/// GROUP_UNIQ_ARRAY - Collect distinct values into array
#[derive(Debug, Clone)]
pub struct GroupUniqArrayAccumulator {
    seen: std::collections::HashSet<String>,
    values: Vec<Value>,
}

impl Default for GroupUniqArrayAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl GroupUniqArrayAccumulator {
    pub fn new() -> Self {
        Self {
            seen: std::collections::HashSet::new(),
            values: Vec::new(),
        }
    }
}

impl Accumulator for GroupUniqArrayAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if value.is_null() {
            return Ok(());
        }

        let key = value_to_string(value);
        if self.seen.insert(key) {
            self.values.push(value.clone());
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "GROUP_UNIQ_ARRAY merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Array(self.values.clone()))
    }

    fn reset(&mut self) {
        self.seen.clear();
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct GroupUniqArrayFunction;

impl AggregateFunction for GroupUniqArrayFunction {
    fn name(&self) -> &str {
        "GROUP_UNIQ_ARRAY"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Unknown)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(GroupUniqArrayAccumulator::new())
    }
}

// === ANY Family (Non-deterministic Value Selection) ============================ //

/// ANY - Returns any non-NULL value (non-deterministic)
#[derive(Debug, Clone)]
pub struct AnyAccumulator {
    value: Option<Value>,
}

impl Default for AnyAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl AnyAccumulator {
    pub fn new() -> Self {
        Self { value: None }
    }
}

impl Accumulator for AnyAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if self.value.is_none() && !value.is_null() {
            self.value = Some(value.clone());
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "ANY merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(self.value.clone().unwrap_or(Value::Null))
    }

    fn reset(&mut self) {
        self.value = None;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct AnyFunction;

impl AggregateFunction for AnyFunction {
    fn name(&self) -> &str {
        "ANY"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, arg_types: &[DataType]) -> Result<DataType> {
        // Return the input type, or String as a safe default for any value
        Ok(arg_types.get(0).cloned().unwrap_or(DataType::String))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(AnyAccumulator::new())
    }
}

// === QUANTILES (Multiple Percentiles) ========================================= //

/// QUANTILES - Multiple quantiles using T-Digest
#[derive(Debug, Clone)]
pub struct QuantilesAccumulator {
    digest: TDigest,
    quantiles: Vec<f64>,
}

impl QuantilesAccumulator {
    pub fn new(quantiles: Vec<f64>) -> Self {
        Self {
            digest: TDigest::new(),
            quantiles: quantiles.into_iter().map(|q| q.clamp(0.0, 1.0)).collect(),
        }
    }
}

impl Accumulator for QuantilesAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(num) = numeric_value_to_f64(value)? {
            self.digest.add(num);
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "QUANTILES merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let mut digest_clone = self.digest.clone();
        let results: Vec<Value> = self
            .quantiles
            .iter()
            .map(|&q| Value::Float64(digest_clone.quantile(q)))
            .collect();
        Ok(Value::Array(results))
    }

    fn reset(&mut self) {
        self.digest = TDigest::new();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct QuantilesFunction {
    quantiles: Vec<f64>,
}

impl QuantilesFunction {
    pub fn new(quantiles: Vec<f64>) -> Self {
        Self { quantiles }
    }
}

impl Default for QuantilesFunction {
    fn default() -> Self {
        Self::new(vec![0.25, 0.5, 0.75]) // Quartiles by default
    }
}

impl AggregateFunction for QuantilesFunction {
    fn name(&self) -> &str {
        "QUANTILES"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Float64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(QuantilesAccumulator::new(self.quantiles.clone()))
    }
}

/// QUANTILES_EXACT - Multiple quantiles using exact sorting
#[derive(Debug, Clone)]
pub struct QuantilesExactAccumulator {
    values: Vec<f64>,
    quantiles: Vec<f64>,
}

impl QuantilesExactAccumulator {
    pub fn new(quantiles: Vec<f64>) -> Self {
        Self {
            values: Vec::new(),
            quantiles: quantiles.into_iter().map(|q| q.clamp(0.0, 1.0)).collect(),
        }
    }
}

impl Accumulator for QuantilesExactAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(num) = numeric_value_to_f64(value)? {
            self.values.push(num);
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "QUANTILES_EXACT merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.values.is_empty() {
            return Ok(Value::Array(Box::new(vec![Value::Null; self.quantiles.len()])));
        }

        let mut sorted = self.values.clone();
        sorted.sort_by(|a, b| a.partial_cmp(b).unwrap_or(Ordering::Equal));

        let results: Vec<Value> = self
            .quantiles
            .iter()
            .map(|&q| {
                let idx = ((sorted.len() as f64 - 1.0) * q) as usize;
                Value::Float64(sorted[idx.min(sorted.len() - 1)])
            })
            .collect();

        Ok(Value::Array(results))
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct QuantilesExactFunction {
    quantiles: Vec<f64>,
}

impl QuantilesExactFunction {
    pub fn new(quantiles: Vec<f64>) -> Self {
        Self { quantiles }
    }
}

impl Default for QuantilesExactFunction {
    fn default() -> Self {
        Self::new(vec![0.25, 0.5, 0.75])
    }
}

impl AggregateFunction for QuantilesExactFunction {
    fn name(&self) -> &str {
        "QUANTILES_EXACT"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Float64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(QuantilesExactAccumulator::new(self.quantiles.clone()))
    }
}

// === TOP_K_WEIGHTED (Weighted Top-K) =========================================== //

/// TOP_K_WEIGHTED - Top-K values by weight
#[derive(Debug, Clone)]
pub struct TopKWeightedAccumulator {
    sums: HashMap<String, f64>,
    k: usize,
}

impl TopKWeightedAccumulator {
    pub fn new(k: i64) -> Self {
        Self {
            sums: HashMap::new(),
            k: k.max(1) as usize,
        }
    }
}

impl Accumulator for TopKWeightedAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        // Expect [value, weight] array
        let (val, weight) = match value {
            Value::Array(arr) if arr.len() == 2 => {
                if arr[0].is_null() || arr[1].is_null() {
                    return Ok(());
                }
                (&arr[0], &arr[1])
            }
            _ if value.is_null() => return Ok(()),
            _ => {
                return Err(Error::TypeMismatch {
                    expected: "ARRAY with 2 values [value, weight]".to_string(),
                    actual: value.data_type().to_string(),
                });
            }
        };

        let weight_f64 = numeric_value_to_f64(weight)?.ok_or_else(|| Error::TypeMismatch {
            expected: "NUMERIC".to_string(),
            actual: "NULL".to_string(),
        })?;

        let key = value_to_string(val);
        *self.sums.entry(key).or_insert(0.0) += weight_f64;

        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "TOP_K_WEIGHTED merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let mut items: Vec<_> = self.sums.iter().collect();
        items.sort_by(|a, b| {
            b.1.partial_cmp(a.1)
                .unwrap_or(Ordering::Equal)
                .then_with(|| a.0.cmp(b.0))
        });

        let result: Vec<Value> = items
            .into_iter()
            .take(self.k)
            .map(|(key, _)| Value::String(key.clone()))
            .collect();

        Ok(Value::Array(result))
    }

    fn reset(&mut self) {
        self.sums.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone, Copy)]
pub struct TopKWeightedFunction {
    k: i64,
}

impl TopKWeightedFunction {
    pub fn new(k: i64) -> Self {
        Self { k }
    }
}

impl Default for TopKWeightedFunction {
    fn default() -> Self {
        Self::new(10)
    }
}

impl AggregateFunction for TopKWeightedFunction {
    fn name(&self) -> &str {
        "TOP_K_WEIGHTED"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown, DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::String)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(TopKWeightedAccumulator::new(self.k))
    }
}

// === GROUP_BIT Operations (Bitwise Group Aggregates) =========================== //

/// GROUP_BIT_AND - Bitwise AND across group
#[derive(Debug, Clone)]
pub struct GroupBitAndAccumulator {
    result: Option<i64>,
}

impl Default for GroupBitAndAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl GroupBitAndAccumulator {
    pub fn new() -> Self {
        Self { result: None }
    }
}

impl Accumulator for GroupBitAndAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if value.is_null() {
            return Ok(());
        }

        if let Some(n) = value.as_i64() {
            self.result = Some(match self.result {
                None => n,
                Some(prev) => prev & n,
            });
            Ok(())
        } else {
            Err(Error::TypeMismatch {
                expected: "INT64".to_string(),
                actual: value.data_type().to_string(),
            })
        }
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "GROUP_BIT_AND merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(self.result.map(Value::Int64).unwrap_or(Value::Null))
    }

    fn reset(&mut self) {
        self.result = None;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct GroupBitAndFunction;

impl AggregateFunction for GroupBitAndFunction {
    fn name(&self) -> &str {
        "GROUP_BIT_AND"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Int64]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(GroupBitAndAccumulator::new())
    }
}

/// GROUP_BIT_OR - Bitwise OR across group
#[derive(Debug, Clone)]
pub struct GroupBitOrAccumulator {
    result: Option<i64>,
}

impl Default for GroupBitOrAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl GroupBitOrAccumulator {
    pub fn new() -> Self {
        Self { result: None }
    }
}

impl Accumulator for GroupBitOrAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if value.is_null() {
            return Ok(());
        }

        if let Some(n) = value.as_i64() {
            self.result = Some(match self.result {
                None => n,
                Some(prev) => prev | n,
            });
            Ok(())
        } else {
            Err(Error::TypeMismatch {
                expected: "INT64".to_string(),
                actual: value.data_type().to_string(),
            })
        }
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "GROUP_BIT_OR merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(self.result.map(Value::Int64).unwrap_or(Value::Null))
    }

    fn reset(&mut self) {
        self.result = None;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct GroupBitOrFunction;

impl AggregateFunction for GroupBitOrFunction {
    fn name(&self) -> &str {
        "GROUP_BIT_OR"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Int64]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(GroupBitOrAccumulator::new())
    }
}

/// GROUP_BIT_XOR - Bitwise XOR across group
#[derive(Debug, Clone)]
pub struct GroupBitXorAccumulator {
    result: Option<i64>,
}

impl Default for GroupBitXorAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl GroupBitXorAccumulator {
    pub fn new() -> Self {
        Self { result: None }
    }
}

impl Accumulator for GroupBitXorAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if value.is_null() {
            return Ok(());
        }

        if let Some(n) = value.as_i64() {
            self.result = Some(match self.result {
                None => n,
                Some(prev) => prev ^ n,
            });
            Ok(())
        } else {
            Err(Error::TypeMismatch {
                expected: "INT64".to_string(),
                actual: value.data_type().to_string(),
            })
        }
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "GROUP_BIT_XOR merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(self.result.map(Value::Int64).unwrap_or(Value::Null))
    }

    fn reset(&mut self) {
        self.result = None;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct GroupBitXorFunction;

impl AggregateFunction for GroupBitXorFunction {
    fn name(&self) -> &str {
        "GROUP_BIT_XOR"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Int64]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(GroupBitXorAccumulator::new())
    }
}

// === ANY Variants ============================================================== //

/// ANY_LAST - Returns last non-NULL value
#[derive(Debug, Clone)]
pub struct AnyLastAccumulator {
    value: Option<Value>,
}

impl Default for AnyLastAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl AnyLastAccumulator {
    pub fn new() -> Self {
        Self { value: None }
    }
}

impl Accumulator for AnyLastAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if !value.is_null() {
            self.value = Some(value.clone());
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "ANY_LAST merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(self.value.clone().unwrap_or(Value::Null))
    }

    fn reset(&mut self) {
        self.value = None;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct AnyLastFunction;

impl AggregateFunction for AnyLastFunction {
    fn name(&self) -> &str {
        "ANY_LAST"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, arg_types: &[DataType]) -> Result<DataType> {
        // Return the input type, or String as a safe default for any value
        Ok(arg_types.get(0).cloned().unwrap_or(DataType::String))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(AnyLastAccumulator::new())
    }
}

/// ANY_HEAVY - Returns a frequently occurring value using Space-Saving algorithm
#[derive(Debug, Clone)]
pub struct AnyHeavyAccumulator {
    counts: HashMap<String, i64>,
    threshold: i64,
}

impl Default for AnyHeavyAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl AnyHeavyAccumulator {
    pub fn new() -> Self {
        Self {
            counts: HashMap::new(),
            threshold: 10,
        }
    }
}

impl Accumulator for AnyHeavyAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if value.is_null() {
            return Ok(());
        }

        let key = value_to_string(value);
        *self.counts.entry(key).or_insert(0) += 1;
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "ANY_HEAVY merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.counts.is_empty() {
            return Ok(Value::Null);
        }

        let max_count = self.counts.values().max().copied().unwrap_or(0);
        if max_count < self.threshold {
            return Ok(Value::Null);
        }

        for (key, count) in &self.counts {
            if *count == max_count {
                return Ok(Value::String(key.clone()));
            }
        }

        Ok(Value::Null)
    }

    fn reset(&mut self) {
        self.counts.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct AnyHeavyFunction;

impl AggregateFunction for AnyHeavyFunction {
    fn name(&self) -> &str {
        "ANY_HEAVY"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, arg_types: &[DataType]) -> Result<DataType> {
        // Return the input type, or String as a safe default for any value
        Ok(arg_types.get(0).cloned().unwrap_or(DataType::String))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(AnyHeavyAccumulator::new())
    }
}

// === SUM_WITH_OVERFLOW ======================================================== //

/// SUM_WITH_OVERFLOW - Sum that can overflow (wraps around)
#[derive(Debug, Clone)]
pub struct SumWithOverflowAccumulator {
    sum: i64,
}

impl Default for SumWithOverflowAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl SumWithOverflowAccumulator {
    pub fn new() -> Self {
        Self { sum: 0 }
    }
}

impl Accumulator for SumWithOverflowAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(val) = numeric_value_to_f64(value)? {
            self.sum = self.sum.wrapping_add(val as i64);
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "SUM_WITH_OVERFLOW merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Int64(self.sum))
    }

    fn reset(&mut self) {
        self.sum = 0;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct SumWithOverflowFunction;

impl AggregateFunction for SumWithOverflowFunction {
    fn name(&self) -> &str {
        "SUM_WITH_OVERFLOW"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(SumWithOverflowAccumulator::new())
    }
}

// === QUANTILE Weighted/Timing/TDigest Variants ================================ //

/// QUANTILE_EXACT_WEIGHTED - Exact weighted quantile
#[derive(Debug, Clone)]
pub struct QuantileExactWeightedAccumulator {
    values: Vec<(f64, f64)>,
    quantile: f64,
}

impl Default for QuantileExactWeightedAccumulator {
    fn default() -> Self {
        Self::new(0.5)
    }
}

impl QuantileExactWeightedAccumulator {
    pub fn new(quantile: f64) -> Self {
        Self {
            values: Vec::new(),
            quantile,
        }
    }
}

impl Accumulator for QuantileExactWeightedAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        let (val, weight) = match value {
            Value::Array(arr) if arr.len() == 2 => {
                if arr[0].is_null() || arr[1].is_null() {
                    return Ok(());
                }
                (&arr[0], &arr[1])
            }
            _ if value.is_null() => return Ok(()),
            _ => {
                return Err(Error::TypeMismatch {
                    expected: "ARRAY[value, weight]".to_string(),
                    actual: value.data_type().to_string(),
                });
            }
        };

        let val_f64 = numeric_value_to_f64(val)?.ok_or_else(|| Error::TypeMismatch {
            expected: "NUMERIC".to_string(),
            actual: val.data_type().to_string(),
        })?;

        let weight_f64 = numeric_value_to_f64(weight)?.ok_or_else(|| Error::TypeMismatch {
            expected: "NUMERIC".to_string(),
            actual: weight.data_type().to_string(),
        })?;

        self.values.push((val_f64, weight_f64));
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "QUANTILE_EXACT_WEIGHTED merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.values.is_empty() {
            return Ok(Value::Null);
        }

        let mut weighted_values = self.values.clone();
        weighted_values.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap_or(Ordering::Equal));

        let total_weight: f64 = weighted_values.iter().map(|(_, w)| w).sum();
        let target_weight = total_weight * self.quantile;

        let mut cumulative_weight = 0.0;
        for (val, weight) in &weighted_values {
            cumulative_weight += weight;
            if cumulative_weight >= target_weight {
                return Ok(Value::Float64(*val));
            }
        }

        Ok(Value::Float64(weighted_values.last().unwrap().0))
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct QuantileExactWeightedFunction {
    quantile: f64,
}

impl Default for QuantileExactWeightedFunction {
    fn default() -> Self {
        Self { quantile: 0.5 }
    }
}

impl AggregateFunction for QuantileExactWeightedFunction {
    fn name(&self) -> &str {
        "QUANTILE_EXACT_WEIGHTED"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(QuantileExactWeightedAccumulator::new(self.quantile))
    }
}

/// QUANTILE_TIMING - Quantile for timing data (optimized for 0-30000ms range)
#[derive(Debug, Clone)]
pub struct QuantileTimingAccumulator {
    values: Vec<f64>,
    quantile: f64,
}

impl Default for QuantileTimingAccumulator {
    fn default() -> Self {
        Self::new(0.5)
    }
}

impl QuantileTimingAccumulator {
    pub fn new(quantile: f64) -> Self {
        Self {
            values: Vec::new(),
            quantile,
        }
    }
}

impl Accumulator for QuantileTimingAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(val) = numeric_value_to_f64(value)? {
            self.values.push(val.clamp(0.0, 30000.0));
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "QUANTILE_TIMING merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.values.is_empty() {
            return Ok(Value::Null);
        }

        let mut sorted = self.values.clone();
        sorted.sort_by(|a, b| a.partial_cmp(b).unwrap_or(Ordering::Equal));

        let index = (sorted.len() as f64 * self.quantile).floor() as usize;
        let index = index.min(sorted.len() - 1);

        Ok(Value::Float64(sorted[index]))
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct QuantileTimingFunction {
    quantile: f64,
}

impl Default for QuantileTimingFunction {
    fn default() -> Self {
        Self { quantile: 0.5 }
    }
}

impl AggregateFunction for QuantileTimingFunction {
    fn name(&self) -> &str {
        "QUANTILE_TIMING"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(QuantileTimingAccumulator::new(self.quantile))
    }
}

/// QUANTILE_TIMING_WEIGHTED - Weighted quantile for timing data
#[derive(Debug, Clone)]
pub struct QuantileTimingWeightedAccumulator {
    values: Vec<(f64, f64)>,
    quantile: f64,
}

impl Default for QuantileTimingWeightedAccumulator {
    fn default() -> Self {
        Self::new(0.5)
    }
}

impl QuantileTimingWeightedAccumulator {
    pub fn new(quantile: f64) -> Self {
        Self {
            values: Vec::new(),
            quantile,
        }
    }
}

impl Accumulator for QuantileTimingWeightedAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        let (val, weight) = match value {
            Value::Array(arr) if arr.len() == 2 => {
                if arr[0].is_null() || arr[1].is_null() {
                    return Ok(());
                }
                (&arr[0], &arr[1])
            }
            _ if value.is_null() => return Ok(()),
            _ => {
                return Err(Error::TypeMismatch {
                    expected: "ARRAY[value, weight]".to_string(),
                    actual: value.data_type().to_string(),
                });
            }
        };

        let val_f64 = numeric_value_to_f64(val)?
            .unwrap_or(0.0)
            .clamp(0.0, 30000.0);
        let weight_f64 = numeric_value_to_f64(weight)?.unwrap_or(0.0);

        self.values.push((val_f64, weight_f64));
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "QUANTILE_TIMING_WEIGHTED merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.values.is_empty() {
            return Ok(Value::Null);
        }

        let mut weighted_values = self.values.clone();
        weighted_values.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap_or(Ordering::Equal));

        let total_weight: f64 = weighted_values.iter().map(|(_, w)| w).sum();
        let target_weight = total_weight * self.quantile;

        let mut cumulative_weight = 0.0;
        for (val, weight) in &weighted_values {
            cumulative_weight += weight;
            if cumulative_weight >= target_weight {
                return Ok(Value::Float64(*val));
            }
        }

        Ok(Value::Float64(weighted_values.last().unwrap().0))
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct QuantileTimingWeightedFunction {
    quantile: f64,
}

impl Default for QuantileTimingWeightedFunction {
    fn default() -> Self {
        Self { quantile: 0.5 }
    }
}

impl AggregateFunction for QuantileTimingWeightedFunction {
    fn name(&self) -> &str {
        "QUANTILE_TIMING_WEIGHTED"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(QuantileTimingWeightedAccumulator::new(self.quantile))
    }
}

/// QUANTILE_TDIGEST - Quantile using TDigest algorithm
#[derive(Debug, Clone)]
pub struct QuantileTDigestAccumulator {
    digest: TDigest,
    quantile: f64,
}

impl Default for QuantileTDigestAccumulator {
    fn default() -> Self {
        Self::new(0.5)
    }
}

impl QuantileTDigestAccumulator {
    pub fn new(quantile: f64) -> Self {
        Self {
            digest: TDigest::new(),
            quantile,
        }
    }
}

impl Accumulator for QuantileTDigestAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(val) = numeric_value_to_f64(value)? {
            self.digest.add(val);
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "QUANTILE_TDIGEST merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let mut digest_clone = self.digest.clone();
        Ok(Value::Float64(digest_clone.quantile(self.quantile)))
    }

    fn reset(&mut self) {
        self.digest = TDigest::new();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct QuantileTDigestFunction {
    quantile: f64,
}

impl Default for QuantileTDigestFunction {
    fn default() -> Self {
        Self { quantile: 0.5 }
    }
}

impl AggregateFunction for QuantileTDigestFunction {
    fn name(&self) -> &str {
        "QUANTILE_TDIGEST"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(QuantileTDigestAccumulator::new(self.quantile))
    }
}

/// QUANTILE_TDIGEST_WEIGHTED - Weighted quantile using TDigest
#[derive(Debug, Clone)]
pub struct QuantileTDigestWeightedAccumulator {
    digest: TDigest,
    quantile: f64,
}

impl Default for QuantileTDigestWeightedAccumulator {
    fn default() -> Self {
        Self::new(0.5)
    }
}

impl QuantileTDigestWeightedAccumulator {
    pub fn new(quantile: f64) -> Self {
        Self {
            digest: TDigest::new(),
            quantile,
        }
    }
}

impl Accumulator for QuantileTDigestWeightedAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        let (val, weight) = match value {
            Value::Array(arr) if arr.len() == 2 => {
                if arr[0].is_null() || arr[1].is_null() {
                    return Ok(());
                }
                (&arr[0], &arr[1])
            }
            _ if value.is_null() => return Ok(()),
            _ => {
                return Err(Error::TypeMismatch {
                    expected: "ARRAY[value, weight]".to_string(),
                    actual: value.data_type().to_string(),
                });
            }
        };

        let val_f64 = numeric_value_to_f64(val)?.unwrap_or(0.0);
        let weight_f64 = numeric_value_to_f64(weight)?.unwrap_or(1.0);

        for _ in 0..(weight_f64 as i64).max(1) {
            self.digest.add(val_f64);
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "QUANTILE_TDIGEST_WEIGHTED merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let mut digest_clone = self.digest.clone();
        Ok(Value::Float64(digest_clone.quantile(self.quantile)))
    }

    fn reset(&mut self) {
        self.digest = TDigest::new();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct QuantileTDigestWeightedFunction {
    quantile: f64,
}

impl Default for QuantileTDigestWeightedFunction {
    fn default() -> Self {
        Self { quantile: 0.5 }
    }
}

impl AggregateFunction for QuantileTDigestWeightedFunction {
    fn name(&self) -> &str {
        "QUANTILE_TDIGEST_WEIGHTED"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(QuantileTDigestWeightedAccumulator::new(self.quantile))
    }
}

/// QUANTILES_TIMING - Multiple quantiles for timing data
#[derive(Debug, Clone)]
pub struct QuantilesTimingAccumulator {
    values: Vec<f64>,
    quantiles: Vec<f64>,
}

impl Default for QuantilesTimingAccumulator {
    fn default() -> Self {
        Self::new(vec![0.5])
    }
}

impl QuantilesTimingAccumulator {
    pub fn new(quantiles: Vec<f64>) -> Self {
        Self {
            values: Vec::new(),
            quantiles,
        }
    }
}

impl Accumulator for QuantilesTimingAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(val) = numeric_value_to_f64(value)? {
            self.values.push(val.clamp(0.0, 30000.0));
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "QUANTILES_TIMING merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.values.is_empty() {
            let nulls = vec![Value::Null; self.quantiles.len()];
            return Ok(Value::Array(nulls));
        }

        let mut sorted = self.values.clone();
        sorted.sort_by(|a, b| a.partial_cmp(b).unwrap_or(Ordering::Equal));

        let results: Vec<Value> = self
            .quantiles
            .iter()
            .map(|&q| {
                let index = (sorted.len() as f64 * q).floor() as usize;
                let index = index.min(sorted.len() - 1);
                Value::Float64(sorted[index])
            })
            .collect();

        Ok(Value::Array(results))
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct QuantilesTimingFunction {
    quantiles: Vec<f64>,
}

impl Default for QuantilesTimingFunction {
    fn default() -> Self {
        Self {
            quantiles: vec![0.5],
        }
    }
}

impl AggregateFunction for QuantilesTimingFunction {
    fn name(&self) -> &str {
        "QUANTILES_TIMING"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Float64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(QuantilesTimingAccumulator::new(self.quantiles.clone()))
    }
}

/// QUANTILES_TDIGEST - Multiple quantiles using TDigest
#[derive(Debug, Clone)]
pub struct QuantilesTDigestAccumulator {
    digest: TDigest,
    quantiles: Vec<f64>,
}

impl Default for QuantilesTDigestAccumulator {
    fn default() -> Self {
        Self::new(vec![0.5])
    }
}

impl QuantilesTDigestAccumulator {
    pub fn new(quantiles: Vec<f64>) -> Self {
        Self {
            digest: TDigest::new(),
            quantiles,
        }
    }
}

impl Accumulator for QuantilesTDigestAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(val) = numeric_value_to_f64(value)? {
            self.digest.add(val);
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "QUANTILES_TDIGEST merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let mut digest_clone = self.digest.clone();
        let results: Vec<Value> = self
            .quantiles
            .iter()
            .map(|&q| Value::Float64(digest_clone.quantile(q)))
            .collect();
        Ok(Value::Array(results))
    }

    fn reset(&mut self) {
        self.digest = TDigest::new();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct QuantilesTDigestFunction {
    quantiles: Vec<f64>,
}

impl Default for QuantilesTDigestFunction {
    fn default() -> Self {
        Self {
            quantiles: vec![0.5],
        }
    }
}

impl AggregateFunction for QuantilesTDigestFunction {
    fn name(&self) -> &str {
        "QUANTILES_TDIGEST"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Float64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(QuantilesTDigestAccumulator::new(self.quantiles.clone()))
    }
}

// === GROUP_ARRAY Variants ===================================================== //

/// GROUP_ARRAY_INSERTAT - Insert elements at specific positions
#[derive(Debug, Clone)]
pub struct GroupArrayInsertAtAccumulator {
    elements: HashMap<i64, Value>,
}

impl Default for GroupArrayInsertAtAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl GroupArrayInsertAtAccumulator {
    pub fn new() -> Self {
        Self {
            elements: HashMap::new(),
        }
    }
}

impl Accumulator for GroupArrayInsertAtAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        let (position, val) = match value {
            Value::Array(arr) if arr.len() == 2 => (&arr[0], &arr[1]),
            _ if value.is_null() => return Ok(()),
            _ => {
                return Err(Error::TypeMismatch {
                    expected: "ARRAY[position, value]".to_string(),
                    actual: value.data_type().to_string(),
                });
            }
        };

        if let Some(pos) = position.as_i64() {
            self.elements.insert(pos, val.clone());
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "GROUP_ARRAY_INSERTAT merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.elements.is_empty() {
            return Ok(Value::Array(Box::new(Vec::new())));
        }

        let max_idx = *self.elements.keys().max().unwrap_or(&0);
        let mut result = vec![Value::Null; (max_idx + 1) as usize];

        for (idx, val) in &self.elements {
            if *idx >= 0 && (*idx as usize) < result.len() {
                result[*idx as usize] = val.clone();
            }
        }

        Ok(Value::Array(result))
    }

    fn reset(&mut self) {
        self.elements.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct GroupArrayInsertAtFunction;

impl AggregateFunction for GroupArrayInsertAtFunction {
    fn name(&self) -> &str {
        "GROUP_ARRAY_INSERTAT"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Unknown)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(GroupArrayInsertAtAccumulator::new())
    }
}

/// GROUP_ARRAY_MOVING_AVG - Moving average of array elements
#[derive(Debug, Clone)]
pub struct GroupArrayMovingAvgAccumulator {
    values: Vec<f64>,
    window_size: usize,
}

impl Default for GroupArrayMovingAvgAccumulator {
    fn default() -> Self {
        Self::new(3)
    }
}

impl GroupArrayMovingAvgAccumulator {
    pub fn new(window_size: usize) -> Self {
        Self {
            values: Vec::new(),
            window_size,
        }
    }
}

impl Accumulator for GroupArrayMovingAvgAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(val) = numeric_value_to_f64(value)? {
            self.values.push(val);
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "GROUP_ARRAY_MOVING_AVG merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.values.is_empty() {
            return Ok(Value::Array(Box::new(Vec::new())));
        }

        let mut result = Vec::new();
        for i in 0..self.values.len() {
            let start = i.saturating_sub(self.window_size - 1);
            let window = &self.values[start..=i];
            let avg = window.iter().sum::<f64>() / window.len() as f64;
            result.push(Value::Float64(avg));
        }

        Ok(Value::Array(result))
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct GroupArrayMovingAvgFunction {
    window_size: usize,
}

impl Default for GroupArrayMovingAvgFunction {
    fn default() -> Self {
        Self { window_size: 3 }
    }
}

impl AggregateFunction for GroupArrayMovingAvgFunction {
    fn name(&self) -> &str {
        "GROUP_ARRAY_MOVING_AVG"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Float64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(GroupArrayMovingAvgAccumulator::new(self.window_size))
    }
}

/// GROUP_ARRAY_MOVING_SUM - Moving sum of array elements
#[derive(Debug, Clone)]
pub struct GroupArrayMovingSumAccumulator {
    values: Vec<f64>,
    window_size: usize,
}

impl Default for GroupArrayMovingSumAccumulator {
    fn default() -> Self {
        Self::new(3)
    }
}

impl GroupArrayMovingSumAccumulator {
    pub fn new(window_size: usize) -> Self {
        Self {
            values: Vec::new(),
            window_size,
        }
    }
}

impl Accumulator for GroupArrayMovingSumAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(val) = numeric_value_to_f64(value)? {
            self.values.push(val);
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "GROUP_ARRAY_MOVING_SUM merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.values.is_empty() {
            return Ok(Value::Array(Box::new(Vec::new())));
        }

        let mut result = Vec::new();
        for i in 0..self.values.len() {
            let start = i.saturating_sub(self.window_size - 1);
            let window = &self.values[start..=i];
            let sum = window.iter().sum::<f64>();
            result.push(Value::Float64(sum));
        }

        Ok(Value::Array(result))
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct GroupArrayMovingSumFunction {
    window_size: usize,
}

impl Default for GroupArrayMovingSumFunction {
    fn default() -> Self {
        Self { window_size: 3 }
    }
}

impl AggregateFunction for GroupArrayMovingSumFunction {
    fn name(&self) -> &str {
        "GROUP_ARRAY_MOVING_SUM"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Float64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(GroupArrayMovingSumAccumulator::new(self.window_size))
    }
}

// === MAP Combinators ========================================================== //

/// SUM_MAP - Sum values for each key
#[derive(Debug, Clone)]
pub struct SumMapAccumulator {
    sums: HashMap<String, f64>,
}

impl Default for SumMapAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl SumMapAccumulator {
    pub fn new() -> Self {
        Self {
            sums: HashMap::new(),
        }
    }
}

impl Accumulator for SumMapAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        let (keys, values) = match value {
            Value::Array(arr) if arr.len() == 2 => {
                if let (Value::Array(k), Value::Array(v)) = (&arr[0], &arr[1]) {
                    (k, v)
                } else {
                    return Err(Error::TypeMismatch {
                        expected: "ARRAY[ARRAY, ARRAY]".to_string(),
                        actual: value.data_type().to_string(),
                    });
                }
            }
            _ if value.is_null() => return Ok(()),
            _ => {
                return Err(Error::TypeMismatch {
                    expected: "ARRAY[keys, values]".to_string(),
                    actual: value.data_type().to_string(),
                });
            }
        };

        for (key, val) in keys.iter().zip(values.iter()) {
            let key_str = value_to_string(key);
            if let Some(val_f64) = numeric_value_to_f64(val)? {
                *self.sums.entry(key_str).or_insert(0.0) += val_f64;
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "SUM_MAP merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let mut keys: Vec<_> = self.sums.keys().collect();
        keys.sort();

        let key_values: Vec<Value> = keys.iter().map(|k| Value::String((*k).clone())).collect();
        let sum_values: Vec<Value> = keys
            .iter()
            .map(|k| Value::Float64(*self.sums.get(*k).unwrap()))
            .collect();

        Ok(Value::Array(Box::new(vec![
            Value::Array(Box::new(key_values)),
            Value::Array(Box::new(sum_values)),
        ])))
    }

    fn reset(&mut self) {
        self.sums.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct SumMapFunction;

impl AggregateFunction for SumMapFunction {
    fn name(&self) -> &str {
        "SUM_MAP"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Array(Box::new(
            DataType::Unknown,
        )))))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(SumMapAccumulator::new())
    }
}

/// MIN_MAP - Minimum values for each key
#[derive(Debug, Clone)]
pub struct MinMapAccumulator {
    mins: HashMap<String, f64>,
}

impl Default for MinMapAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl MinMapAccumulator {
    pub fn new() -> Self {
        Self {
            mins: HashMap::new(),
        }
    }
}

impl Accumulator for MinMapAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        let (keys, values) = match value {
            Value::Array(arr) if arr.len() == 2 => {
                if let (Value::Array(k), Value::Array(v)) = (&arr[0], &arr[1]) {
                    (k, v)
                } else {
                    return Err(Error::TypeMismatch {
                        expected: "ARRAY[ARRAY, ARRAY]".to_string(),
                        actual: value.data_type().to_string(),
                    });
                }
            }
            _ if value.is_null() => return Ok(()),
            _ => {
                return Err(Error::TypeMismatch {
                    expected: "ARRAY[keys, values]".to_string(),
                    actual: value.data_type().to_string(),
                });
            }
        };

        for (key, val) in keys.iter().zip(values.iter()) {
            let key_str = value_to_string(key);
            if let Some(val_f64) = numeric_value_to_f64(val)? {
                self.mins
                    .entry(key_str)
                    .and_modify(|v| *v = v.min(val_f64))
                    .or_insert(val_f64);
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "MIN_MAP merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let mut keys: Vec<_> = self.mins.keys().collect();
        keys.sort();

        let key_values: Vec<Value> = keys.iter().map(|k| Value::String((*k).clone())).collect();
        let min_values: Vec<Value> = keys
            .iter()
            .map(|k| Value::Float64(*self.mins.get(*k).unwrap()))
            .collect();

        Ok(Value::Array(Box::new(vec![
            Value::Array(Box::new(key_values)),
            Value::Array(Box::new(min_values)),
        ])))
    }

    fn reset(&mut self) {
        self.mins.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct MinMapFunction;

impl AggregateFunction for MinMapFunction {
    fn name(&self) -> &str {
        "MIN_MAP"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Array(Box::new(
            DataType::Unknown,
        )))))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(MinMapAccumulator::new())
    }
}

/// MAX_MAP - Maximum values for each key
#[derive(Debug, Clone)]
pub struct MaxMapAccumulator {
    maxs: HashMap<String, f64>,
}

impl Default for MaxMapAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl MaxMapAccumulator {
    pub fn new() -> Self {
        Self {
            maxs: HashMap::new(),
        }
    }
}

impl Accumulator for MaxMapAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        let (keys, values) = match value {
            Value::Array(arr) if arr.len() == 2 => {
                if let (Value::Array(k), Value::Array(v)) = (&arr[0], &arr[1]) {
                    (k, v)
                } else {
                    return Err(Error::TypeMismatch {
                        expected: "ARRAY[ARRAY, ARRAY]".to_string(),
                        actual: value.data_type().to_string(),
                    });
                }
            }
            _ if value.is_null() => return Ok(()),
            _ => {
                return Err(Error::TypeMismatch {
                    expected: "ARRAY[keys, values]".to_string(),
                    actual: value.data_type().to_string(),
                });
            }
        };

        for (key, val) in keys.iter().zip(values.iter()) {
            let key_str = value_to_string(key);
            if let Some(val_f64) = numeric_value_to_f64(val)? {
                self.maxs
                    .entry(key_str)
                    .and_modify(|v| *v = v.max(val_f64))
                    .or_insert(val_f64);
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "MAX_MAP merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let mut keys: Vec<_> = self.maxs.keys().collect();
        keys.sort();

        let key_values: Vec<Value> = keys.iter().map(|k| Value::String((*k).clone())).collect();
        let max_values: Vec<Value> = keys
            .iter()
            .map(|k| Value::Float64(*self.maxs.get(*k).unwrap()))
            .collect();

        Ok(Value::Array(Box::new(vec![
            Value::Array(Box::new(key_values)),
            Value::Array(Box::new(max_values)),
        ])))
    }

    fn reset(&mut self) {
        self.maxs.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct MaxMapFunction;

impl AggregateFunction for MaxMapFunction {
    fn name(&self) -> &str {
        "MAX_MAP"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Array(Box::new(
            DataType::Unknown,
        )))))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(MaxMapAccumulator::new())
    }
}

// === GROUP_BITMAP Family ====================================================== //

/// GROUP_BITMAP - Aggregate values into a bitmap
#[derive(Debug, Clone)]
pub struct GroupBitmapAccumulator {
    bitmap: std::collections::HashSet<i64>,
}

impl Default for GroupBitmapAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl GroupBitmapAccumulator {
    pub fn new() -> Self {
        Self {
            bitmap: std::collections::HashSet::new(),
        }
    }
}

impl Accumulator for GroupBitmapAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(i) = value.as_i64() {
            self.bitmap.insert(i);
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "GROUP_BITMAP merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let mut values: Vec<i64> = self.bitmap.iter().copied().collect();
        values.sort_unstable();
        let value_array: Vec<Value> = values.into_iter().map(Value::Int64).collect();
        Ok(Value::Array(Box::new(value_array)))
    }

    fn reset(&mut self) {
        self.bitmap.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct GroupBitmapFunction;

impl AggregateFunction for GroupBitmapFunction {
    fn name(&self) -> &str {
        "GROUP_BITMAP"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Int64]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Int64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(GroupBitmapAccumulator::new())
    }
}

/// GROUP_BITMAP_AND - Bitmap AND across groups
#[derive(Debug, Clone)]
pub struct GroupBitmapAndAccumulator {
    bitmap: Option<std::collections::HashSet<i64>>,
}

impl Default for GroupBitmapAndAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl GroupBitmapAndAccumulator {
    pub fn new() -> Self {
        Self { bitmap: None }
    }
}

impl Accumulator for GroupBitmapAndAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            let current_set: std::collections::HashSet<i64> = arr
                .iter()
                .filter_map(|v| v.as_i64())
                .collect();

            if let Some(ref mut bitmap) = self.bitmap {
                *bitmap = bitmap.intersection(&current_set).copied().collect();
            } else {
                self.bitmap = Some(current_set);
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "GROUP_BITMAP_AND merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if let Some(ref bitmap) = self.bitmap {
            let mut values: Vec<i64> = bitmap.iter().copied().collect();
            values.sort_unstable();
            let value_array: Vec<Value> = values.into_iter().map(Value::Int64).collect();
            Ok(Value::Array(Box::new(value_array)))
        } else {
            Ok(Value::Array(Box::new(Vec::new())))
        }
    }

    fn reset(&mut self) {
        self.bitmap = None;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct GroupBitmapAndFunction;

impl AggregateFunction for GroupBitmapAndFunction {
    fn name(&self) -> &str {
        "GROUP_BITMAP_AND"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Int64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(GroupBitmapAndAccumulator::new())
    }
}

/// GROUP_BITMAP_OR - Bitmap OR across groups
#[derive(Debug, Clone)]
pub struct GroupBitmapOrAccumulator {
    bitmap: std::collections::HashSet<i64>,
}

impl Default for GroupBitmapOrAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl GroupBitmapOrAccumulator {
    pub fn new() -> Self {
        Self {
            bitmap: std::collections::HashSet::new(),
        }
    }
}

impl Accumulator for GroupBitmapOrAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            for v in arr.iter() {
                if let Some(i) = v.as_i64() {
                    self.bitmap.insert(i);
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "GROUP_BITMAP_OR merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let mut values: Vec<i64> = self.bitmap.iter().copied().collect();
        values.sort_unstable();
        let value_array: Vec<Value> = values.into_iter().map(Value::Int64).collect();
        Ok(Value::Array(Box::new(value_array)))
    }

    fn reset(&mut self) {
        self.bitmap.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct GroupBitmapOrFunction;

impl AggregateFunction for GroupBitmapOrFunction {
    fn name(&self) -> &str {
        "GROUP_BITMAP_OR"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Int64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(GroupBitmapOrAccumulator::new())
    }
}

/// GROUP_BITMAP_XOR - Bitmap XOR across groups
#[derive(Debug, Clone)]
pub struct GroupBitmapXorAccumulator {
    bitmap: std::collections::HashMap<i64, bool>,
}

impl Default for GroupBitmapXorAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl GroupBitmapXorAccumulator {
    pub fn new() -> Self {
        Self {
            bitmap: std::collections::HashMap::new(),
        }
    }
}

impl Accumulator for GroupBitmapXorAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            for v in arr.iter() {
                if let Some(i) = v.as_i64() {
                    self.bitmap
                        .entry(i)
                        .and_modify(|present| *present = !*present)
                        .or_insert(true);
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "GROUP_BITMAP_XOR merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let mut values: Vec<i64> = self
            .bitmap
            .iter()
            .filter_map(|(k, v)| if *v { Some(*k) } else { None })
            .collect();
        values.sort_unstable();
        let value_array: Vec<Value> = values.into_iter().map(Value::Int64).collect();
        Ok(Value::Array(Box::new(value_array)))
    }

    fn reset(&mut self) {
        self.bitmap.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct GroupBitmapXorFunction;

impl AggregateFunction for GroupBitmapXorFunction {
    fn name(&self) -> &str {
        "GROUP_BITMAP_XOR"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Int64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(GroupBitmapXorAccumulator::new())
    }
}

// === RANK_CORR ================================================================ //

/// RANK_CORR - Spearman rank correlation coefficient
#[derive(Debug, Clone)]
pub struct RankCorrAccumulator {
    x_values: Vec<f64>,
    y_values: Vec<f64>,
}

impl Default for RankCorrAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl RankCorrAccumulator {
    pub fn new() -> Self {
        Self {
            x_values: Vec::new(),
            y_values: Vec::new(),
        }
    }

    fn rank_values(values: &[f64]) -> Vec<f64> {
        let mut indexed: Vec<(usize, f64)> = values.iter().copied().enumerate().collect();
        indexed.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap_or(Ordering::Equal));

        let mut ranks = vec![0.0; values.len()];
        let mut i = 0;
        while i < indexed.len() {
            let mut j = i;
            while j < indexed.len() && indexed[j].1 == indexed[i].1 {
                j += 1;
            }
            let rank = (i + j - 1) as f64 / 2.0 + 1.0;
            for k in i..j {
                ranks[indexed[k].0] = rank;
            }
            i = j;
        }
        ranks
    }
}

impl Accumulator for RankCorrAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        let (x, y) = match value {
            Value::Array(arr) if arr.len() == 2 => {
                if arr[0].is_null() || arr[1].is_null() {
                    return Ok(());
                }
                (&arr[0], &arr[1])
            }
            _ if value.is_null() => return Ok(()),
            _ => {
                return Err(Error::TypeMismatch {
                    expected: "ARRAY[x, y]".to_string(),
                    actual: value.data_type().to_string(),
                });
            }
        };

        let x_f64 = numeric_value_to_f64(x)?.unwrap_or(0.0);
        let y_f64 = numeric_value_to_f64(y)?.unwrap_or(0.0);

        self.x_values.push(x_f64);
        self.y_values.push(y_f64);
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "RANK_CORR merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.x_values.len() < 2 {
            return Ok(Value::Null);
        }

        let x_ranks = Self::rank_values(&self.x_values);
        let y_ranks = Self::rank_values(&self.y_values);

        let n = x_ranks.len() as f64;
        let mean_x: f64 = x_ranks.iter().sum::<f64>() / n;
        let mean_y: f64 = y_ranks.iter().sum::<f64>() / n;

        let mut sum_xy = 0.0;
        let mut sum_x2 = 0.0;
        let mut sum_y2 = 0.0;

        for i in 0..x_ranks.len() {
            let dx = x_ranks[i] - mean_x;
            let dy = y_ranks[i] - mean_y;
            sum_xy += dx * dy;
            sum_x2 += dx * dx;
            sum_y2 += dy * dy;
        }

        if sum_x2 == 0.0 || sum_y2 == 0.0 {
            return Ok(Value::Null);
        }

        let corr = sum_xy / (sum_x2 * sum_y2).sqrt();
        Ok(Value::Float64(corr))
    }

    fn reset(&mut self) {
        self.x_values.clear();
        self.y_values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct RankCorrFunction;

impl AggregateFunction for RankCorrFunction {
    fn name(&self) -> &str {
        "RANK_CORR"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(RankCorrAccumulator::new())
    }
}

// === EXPONENTIAL_MOVING_AVERAGE =============================================== //

/// EXPONENTIAL_MOVING_AVERAGE - Exponential moving average
#[derive(Debug, Clone)]
pub struct ExponentialMovingAverageAccumulator {
    ema: Option<f64>,
    alpha: f64,
}

impl Default for ExponentialMovingAverageAccumulator {
    fn default() -> Self {
        Self::new(0.5)
    }
}

impl ExponentialMovingAverageAccumulator {
    pub fn new(alpha: f64) -> Self {
        Self { ema: None, alpha }
    }
}

impl Accumulator for ExponentialMovingAverageAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(val) = numeric_value_to_f64(value)? {
            if let Some(current_ema) = self.ema {
                self.ema = Some(self.alpha * val + (1.0 - self.alpha) * current_ema);
            } else {
                self.ema = Some(val);
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "EXPONENTIAL_MOVING_AVERAGE merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(self.ema.map(Value::Float64).unwrap_or(Value::Null))
    }

    fn reset(&mut self) {
        self.ema = None;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct ExponentialMovingAverageFunction {
    alpha: f64,
}

impl Default for ExponentialMovingAverageFunction {
    fn default() -> Self {
        Self { alpha: 0.5 }
    }
}

impl AggregateFunction for ExponentialMovingAverageFunction {
    fn name(&self) -> &str {
        "EXPONENTIAL_MOVING_AVERAGE"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(ExponentialMovingAverageAccumulator::new(self.alpha))
    }
}

// === INTERVAL_LENGTH_SUM ====================================================== //

/// INTERVAL_LENGTH_SUM - Sum of interval lengths
#[derive(Debug, Clone)]
pub struct IntervalLengthSumAccumulator {
    total_length: i64,
}

impl Default for IntervalLengthSumAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl IntervalLengthSumAccumulator {
    pub fn new() -> Self {
        Self { total_length: 0 }
    }
}

impl Accumulator for IntervalLengthSumAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        let (start, end) = match value {
            Value::Array(arr) if arr.len() == 2 => {
                if arr[0].is_null() || arr[1].is_null() {
                    return Ok(());
                }
                (&arr[0], &arr[1])
            }
            _ if value.is_null() => return Ok(()),
            _ => {
                return Err(Error::TypeMismatch {
                    expected: "ARRAY[start, end]".to_string(),
                    actual: value.data_type().to_string(),
                });
            }
        };

        let start_val = numeric_value_to_f64(start)?.unwrap_or(0.0) as i64;
        let end_val = numeric_value_to_f64(end)?.unwrap_or(0.0) as i64;

        if end_val > start_val {
            self.total_length += end_val - start_val;
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "INTERVAL_LENGTH_SUM merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Int64(self.total_length))
    }

    fn reset(&mut self) {
        self.total_length = 0;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct IntervalLengthSumFunction;

impl AggregateFunction for IntervalLengthSumFunction {
    fn name(&self) -> &str {
        "INTERVAL_LENGTH_SUM"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(IntervalLengthSumAccumulator::new())
    }
}

// === RETENTION ================================================================ //

/// RETENTION - Retention analysis (tracks event occurrences across time periods)
#[derive(Debug, Clone)]
pub struct RetentionAccumulator {
    event_flags: Vec<bool>,
}

impl Default for RetentionAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl RetentionAccumulator {
    pub fn new() -> Self {
        Self {
            event_flags: Vec::new(),
        }
    }
}

impl Accumulator for RetentionAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if self.event_flags.is_empty() {
                self.event_flags = vec![false; arr.len()];
            }

            for (i, v) in arr.iter().enumerate() {
                if i < self.event_flags.len() {
                    if let Some(b) = v.as_bool() {
                        self.event_flags[i] = self.event_flags[i] || b;
                    } else if let Some(n) = v.as_i64() {
                        self.event_flags[i] = self.event_flags[i] || (n != 0);
                    }
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "RETENTION merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let result: Vec<Value> = self.event_flags.iter().map(|&b| Value::Bool(b)).collect();
        Ok(Value::Array(result))
    }

    fn reset(&mut self) {
        self.event_flags.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct RetentionFunction;

impl AggregateFunction for RetentionFunction {
    fn name(&self) -> &str {
        "RETENTION"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Bool)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(RetentionAccumulator::new())
    }
}

// === WINDOW_FUNNEL ============================================================ //

/// WINDOW_FUNNEL - Funnel conversion analysis
#[derive(Debug, Clone)]
pub struct WindowFunnelAccumulator {
    events: Vec<(i64, usize)>,
    window: i64,
    num_steps: usize,
}

impl Default for WindowFunnelAccumulator {
    fn default() -> Self {
        Self::new(3600, 5)
    }
}

impl WindowFunnelAccumulator {
    pub fn new(window: i64, num_steps: usize) -> Self {
        Self {
            events: Vec::new(),
            window,
            num_steps,
        }
    }
}

impl Accumulator for WindowFunnelAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        let (timestamp, step) = match value {
            Value::Array(arr) if arr.len() == 2 => {
                if arr[0].is_null() || arr[1].is_null() {
                    return Ok(());
                }
                (&arr[0], &arr[1])
            }
            _ if value.is_null() => return Ok(()),
            _ => {
                return Err(Error::TypeMismatch {
                    expected: "ARRAY[timestamp, step]".to_string(),
                    actual: value.data_type().to_string(),
                });
            }
        };

        let ts = numeric_value_to_f64(timestamp)?.unwrap_or(0.0) as i64;
        let step_num = numeric_value_to_f64(step)?.unwrap_or(0.0) as usize;

        if step_num > 0 && step_num <= self.num_steps {
            self.events.push((ts, step_num));
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "WINDOW_FUNNEL merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.events.is_empty() {
            return Ok(Value::Int64(0));
        }

        let mut sorted_events = self.events.clone();
        sorted_events.sort_by_key(|e| e.0);

        let mut max_level = 0;

        for start_idx in 0..sorted_events.len() {
            if sorted_events[start_idx].1 != 1 {
                continue;
            }

            let start_time = sorted_events[start_idx].0;
            let mut current_level = 1;
            let mut last_step_time = start_time;

            for event_idx in (start_idx + 1)..sorted_events.len() {
                let (event_time, event_step) = sorted_events[event_idx];

                if event_time - start_time > self.window {
                    break;
                }

                if event_step == current_level + 1 && event_time >= last_step_time {
                    current_level += 1;
                    last_step_time = event_time;

                    if current_level == self.num_steps {
                        return Ok(Value::Int64(self.num_steps as i64));
                    }
                }
            }

            max_level = max_level.max(current_level);
        }

        Ok(Value::Int64(max_level as i64))
    }

    fn reset(&mut self) {
        self.events.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct WindowFunnelFunction {
    window: i64,
    num_steps: usize,
}

impl Default for WindowFunnelFunction {
    fn default() -> Self {
        Self {
            window: 3600,
            num_steps: 5,
        }
    }
}

impl AggregateFunction for WindowFunnelFunction {
    fn name(&self) -> &str {
        "WINDOW_FUNNEL"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(WindowFunnelAccumulator::new(self.window, self.num_steps))
    }
}

// === GROUP_ARRAY_SAMPLE ======================================================= //

/// GROUP_ARRAY_SAMPLE - Sample N random elements from the group using reservoir sampling
#[derive(Debug, Clone)]
pub struct GroupArraySampleAccumulator {
    values: Vec<Value>,
    max_size: usize,
    count: usize,
}

impl Default for GroupArraySampleAccumulator {
    fn default() -> Self {
        Self::new(10)
    }
}

impl GroupArraySampleAccumulator {
    pub fn new(max_size: usize) -> Self {
        Self {
            values: Vec::new(),
            max_size,
            count: 0,
        }
    }
}

impl Accumulator for GroupArraySampleAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        self.count += 1;
        if self.values.len() < self.max_size {
            self.values.push(value.clone());
        } else {
            let idx = rand::random::<usize>() % self.count;
            if idx < self.max_size {
                self.values[idx] = value.clone();
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "GROUP_ARRAY_SAMPLE merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Array(self.values.clone()))
    }

    fn reset(&mut self) {
        self.values.clear();
        self.count = 0;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct GroupArraySampleFunction {
    max_size: usize,
}

impl Default for GroupArraySampleFunction {
    fn default() -> Self {
        Self { max_size: 10 }
    }
}

impl GroupArraySampleFunction {
    pub fn new(max_size: usize) -> Self {
        Self { max_size }
    }
}

impl AggregateFunction for GroupArraySampleFunction {
    fn name(&self) -> &str {
        "GROUP_ARRAY_SAMPLE"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Unknown)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(GroupArraySampleAccumulator::new(self.max_size))
    }
}

// === SEQUENCE Functions ======================================================= //

/// SEQUENCE_MATCH - Pattern matching on event sequences
#[derive(Debug, Clone)]
pub struct SequenceMatchAccumulator {
    events: Vec<(i64, String)>,
    pattern: String,
}

impl Default for SequenceMatchAccumulator {
    fn default() -> Self {
        Self::new(String::new())
    }
}

impl SequenceMatchAccumulator {
    pub fn new(pattern: String) -> Self {
        Self {
            events: Vec::new(),
            pattern,
        }
    }

    fn matches_pattern(&self) -> bool {
        if self.events.is_empty() || self.pattern.is_empty() {
            return false;
        }

        let pattern_parts: Vec<&str> = self.pattern.split("->").map(|s| s.trim()).collect();
        if pattern_parts.is_empty() {
            return false;
        }

        let mut events_sorted = self.events.clone();
        events_sorted.sort_by_key(|(timestamp, _)| *timestamp);

        let mut pattern_idx = 0;
        for (_timestamp, event_name) in &events_sorted {
            if pattern_idx < pattern_parts.len() && event_name == pattern_parts[pattern_idx] {
                pattern_idx += 1;
                if pattern_idx == pattern_parts.len() {
                    return true;
                }
            }
        }

        false
    }
}

impl Accumulator for SequenceMatchAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() >= 2 {
                if let (Some(timestamp), Some(event_name)) =
                    (arr[0].as_i64(), arr[1].as_str())
                {
                    self.events.push((timestamp, event_name.to_string()));
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "SEQUENCE_MATCH merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Bool(self.matches_pattern()))
    }

    fn reset(&mut self) {
        self.events.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct SequenceMatchFunction {
    pattern: String,
}

impl Default for SequenceMatchFunction {
    fn default() -> Self {
        Self {
            pattern: String::new(),
        }
    }
}

impl SequenceMatchFunction {
    pub fn new(pattern: String) -> Self {
        Self { pattern }
    }
}

impl AggregateFunction for SequenceMatchFunction {
    fn name(&self) -> &str {
        "SEQUENCE_MATCH"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Bool)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(SequenceMatchAccumulator::new(self.pattern.clone()))
    }
}

/// SEQUENCE_COUNT - Count occurrences of a pattern in event sequences
#[derive(Debug, Clone)]
pub struct SequenceCountAccumulator {
    events: Vec<(i64, String)>,
    pattern: String,
}

impl Default for SequenceCountAccumulator {
    fn default() -> Self {
        Self::new(String::new())
    }
}

impl SequenceCountAccumulator {
    pub fn new(pattern: String) -> Self {
        Self {
            events: Vec::new(),
            pattern,
        }
    }

    fn count_pattern(&self) -> i64 {
        if self.events.is_empty() || self.pattern.is_empty() {
            return 0;
        }

        let pattern_parts: Vec<&str> = self.pattern.split("->").map(|s| s.trim()).collect();
        if pattern_parts.is_empty() {
            return 0;
        }

        let mut events_sorted = self.events.clone();
        events_sorted.sort_by_key(|(timestamp, _)| *timestamp);

        let mut count = 0i64;
        for start_idx in 0..events_sorted.len() {
            let mut pattern_idx = 0;
            for i in start_idx..events_sorted.len() {
                let (_timestamp, event_name) = &events_sorted[i];
                if pattern_idx < pattern_parts.len() && event_name == pattern_parts[pattern_idx]
                {
                    pattern_idx += 1;
                    if pattern_idx == pattern_parts.len() {
                        count += 1;
                        break;
                    }
                }
            }
        }

        count
    }
}

impl Accumulator for SequenceCountAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() >= 2 {
                if let (Some(timestamp), Some(event_name)) =
                    (arr[0].as_i64(), arr[1].as_str())
                {
                    self.events.push((timestamp, event_name.to_string()));
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "SEQUENCE_COUNT merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Int64(self.count_pattern()))
    }

    fn reset(&mut self) {
        self.events.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct SequenceCountFunction {
    pattern: String,
}

impl Default for SequenceCountFunction {
    fn default() -> Self {
        Self {
            pattern: String::new(),
        }
    }
}

impl SequenceCountFunction {
    pub fn new(pattern: String) -> Self {
        Self { pattern }
    }
}

impl AggregateFunction for SequenceCountFunction {
    fn name(&self) -> &str {
        "SEQUENCE_COUNT"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(SequenceCountAccumulator::new(self.pattern.clone()))
    }
}

// === UNIQ_UP_TO =============================================================== //

/// UNIQ_UP_TO - Exact unique count up to a threshold
#[derive(Debug, Clone)]
pub struct UniqUpToAccumulator {
    values: std::collections::HashSet<String>,
    threshold: usize,
}

impl Default for UniqUpToAccumulator {
    fn default() -> Self {
        Self::new(100)
    }
}

impl UniqUpToAccumulator {
    pub fn new(threshold: usize) -> Self {
        Self {
            values: std::collections::HashSet::new(),
            threshold,
        }
    }
}

impl Accumulator for UniqUpToAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if value.is_null() {
            return Ok(());
        }

        if self.values.len() < self.threshold {
            let key = value_to_string(value);
            self.values.insert(key);
        }

        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "UNIQ_UP_TO merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let count = self.values.len();
        if count >= self.threshold {
            Ok(Value::Int64(self.threshold as i64 + 1))
        } else {
            Ok(Value::Int64(count as i64))
        }
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct UniqUpToFunction {
    threshold: usize,
}

impl Default for UniqUpToFunction {
    fn default() -> Self {
        Self { threshold: 100 }
    }
}

impl UniqUpToFunction {
    pub fn new(threshold: usize) -> Self {
        Self { threshold }
    }
}

impl AggregateFunction for UniqUpToFunction {
    fn name(&self) -> &str {
        "UNIQ_UP_TO"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(UniqUpToAccumulator::new(self.threshold))
    }
}

// === Conditional Aggregate Combinators ======================================== //

/// SUM_IF - Sum values where condition is true
#[derive(Debug, Clone)]
pub struct SumIfAccumulator {
    sum: f64,
}

impl Default for SumIfAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl SumIfAccumulator {
    pub fn new() -> Self {
        Self { sum: 0.0 }
    }
}

impl Accumulator for SumIfAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                if let Some(condition) = arr[1].as_bool() {
                    if condition {
                        if let Some(num) = numeric_value_to_f64(&arr[0])? {
                            self.sum += num;
                        }
                    }
                } else if let Some(cond) = arr[1].as_i64() {
                    if cond != 0 {
                        if let Some(num) = numeric_value_to_f64(&arr[0])? {
                            self.sum += num;
                        }
                    }
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "SUM_IF merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Float64(self.sum))
    }

    fn reset(&mut self) {
        self.sum = 0.0;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct SumIfFunction;

impl AggregateFunction for SumIfFunction {
    fn name(&self) -> &str {
        "SUM_IF"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(SumIfAccumulator::new())
    }
}

/// AVG_IF - Average values where condition is true
#[derive(Debug, Clone)]
pub struct AvgIfAccumulator {
    sum: f64,
    count: usize,
}

impl Default for AvgIfAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl AvgIfAccumulator {
    pub fn new() -> Self {
        Self { sum: 0.0, count: 0 }
    }
}

impl Accumulator for AvgIfAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                let condition = if let Some(b) = arr[1].as_bool() {
                    b
                } else if let Some(i) = arr[1].as_i64() {
                    i != 0
                } else {
                    false
                };

                if condition {
                    if let Some(num) = numeric_value_to_f64(&arr[0])? {
                        self.sum += num;
                        self.count += 1;
                    }
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "AVG_IF merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.count == 0 {
            Ok(Value::Null)
        } else {
            Ok(Value::Float64(self.sum / self.count as f64))
        }
    }

    fn reset(&mut self) {
        self.sum = 0.0;
        self.count = 0;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct AvgIfFunction;

impl AggregateFunction for AvgIfFunction {
    fn name(&self) -> &str {
        "AVG_IF"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(AvgIfAccumulator::new())
    }
}

/// MIN_IF - Minimum value where condition is true
#[derive(Debug, Clone)]
pub struct MinIfAccumulator {
    min: Option<f64>,
}

impl Default for MinIfAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl MinIfAccumulator {
    pub fn new() -> Self {
        Self { min: None }
    }
}

impl Accumulator for MinIfAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                let condition = if let Some(b) = arr[1].as_bool() {
                    b
                } else if let Some(i) = arr[1].as_i64() {
                    i != 0
                } else {
                    false
                };

                if condition {
                    if let Some(num) = numeric_value_to_f64(&arr[0])? {
                        self.min = Some(match self.min {
                            Some(current) => current.min(num),
                            None => num,
                        });
                    }
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "MIN_IF merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        match self.min {
            Some(min) => Ok(Value::Float64(min)),
            None => Ok(Value::Null),
        }
    }

    fn reset(&mut self) {
        self.min = None;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct MinIfFunction;

impl AggregateFunction for MinIfFunction {
    fn name(&self) -> &str {
        "MIN_IF"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(MinIfAccumulator::new())
    }
}

/// MAX_IF - Maximum value where condition is true
#[derive(Debug, Clone)]
pub struct MaxIfAccumulator {
    max: Option<f64>,
}

impl Default for MaxIfAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl MaxIfAccumulator {
    pub fn new() -> Self {
        Self { max: None }
    }
}

impl Accumulator for MaxIfAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                let condition = if let Some(b) = arr[1].as_bool() {
                    b
                } else if let Some(i) = arr[1].as_i64() {
                    i != 0
                } else {
                    false
                };

                if condition {
                    if let Some(num) = numeric_value_to_f64(&arr[0])? {
                        self.max = Some(match self.max {
                            Some(current) => current.max(num),
                            None => num,
                        });
                    }
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "MAX_IF merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        match self.max {
            Some(max) => Ok(Value::Float64(max)),
            None => Ok(Value::Null),
        }
    }

    fn reset(&mut self) {
        self.max = None;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct MaxIfFunction;

impl AggregateFunction for MaxIfFunction {
    fn name(&self) -> &str {
        "MAX_IF"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(MaxIfAccumulator::new())
    }
}

/// COUNT_EQUAL - Count values equal to a specific target
#[derive(Debug, Clone)]
pub struct CountEqualAccumulator {
    target: Value,
    count: i64,
}

impl Default for CountEqualAccumulator {
    fn default() -> Self {
        Self::new(Value::Null)
    }
}

impl CountEqualAccumulator {
    pub fn new(target: Value) -> Self {
        Self { target, count: 0 }
    }

    fn values_equal(a: &Value, b: &Value) -> bool {
        if a.is_null() && b.is_null() {
            return true;
        }

        if let (Some(x), Some(y)) = (a.as_i64(), b.as_i64()) {
            return x == y;
        }

        if let (Some(x), Some(y)) = (a.as_f64(), b.as_f64()) {
            return (x - y).abs() < f64::EPSILON;
        }

        if let (Some(x), Some(y)) = (a.as_str(), b.as_str()) {
            return x == y;
        }

        if let (Some(x), Some(y)) = (a.as_bool(), b.as_bool()) {
            return x == y;
        }

        false
    }
}

impl Accumulator for CountEqualAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                if Self::values_equal(&arr[0], &self.target) {
                    self.count += 1;
                }
            }
        } else if Self::values_equal(value, &self.target) {
            self.count += 1;
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "COUNT_EQUAL merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Int64(self.count))
    }

    fn reset(&mut self) {
        self.count = 0;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct CountEqualFunction {
    target: Value,
}

impl Default for CountEqualFunction {
    fn default() -> Self {
        Self {
            target: Value::Null,
        }
    }
}

impl CountEqualFunction {
    pub fn new(target: Value) -> Self {
        Self { target }
    }
}

impl AggregateFunction for CountEqualFunction {
    fn name(&self) -> &str {
        "COUNT_EQUAL"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(CountEqualAccumulator::new(self.target.clone()))
    }
}

// === Additional Statistical Functions ========================================= //

/// BOUNDING_RATIO - Ratio of maximum to minimum value
#[derive(Debug, Clone)]
pub struct BoundingRatioAccumulator {
    min: Option<f64>,
    max: Option<f64>,
}

impl Default for BoundingRatioAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl BoundingRatioAccumulator {
    pub fn new() -> Self {
        Self {
            min: None,
            max: None,
        }
    }
}

impl Accumulator for BoundingRatioAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(num) = numeric_value_to_f64(value)? {
            self.min = Some(match self.min {
                Some(current) => current.min(num),
                None => num,
            });
            self.max = Some(match self.max {
                Some(current) => current.max(num),
                None => num,
            });
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "BOUNDING_RATIO merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        match (self.min, self.max) {
            (Some(min), Some(max)) => {
                if min.abs() < f64::EPSILON {
                    Ok(Value::Null)
                } else {
                    Ok(Value::Float64(max / min))
                }
            }
            _ => Ok(Value::Null),
        }
    }

    fn reset(&mut self) {
        self.min = None;
        self.max = None;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct BoundingRatioFunction;

impl AggregateFunction for BoundingRatioFunction {
    fn name(&self) -> &str {
        "BOUNDING_RATIO"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(BoundingRatioAccumulator::new())
    }
}

/// SIMPLE_LINEAR_REGRESSION - Simple linear regression (slope, intercept)
#[derive(Debug, Clone)]
pub struct SimpleLinearRegressionAccumulator {
    sum_x: f64,
    sum_y: f64,
    sum_xx: f64,
    sum_xy: f64,
    count: usize,
}

impl Default for SimpleLinearRegressionAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl SimpleLinearRegressionAccumulator {
    pub fn new() -> Self {
        Self {
            sum_x: 0.0,
            sum_y: 0.0,
            sum_xx: 0.0,
            sum_xy: 0.0,
            count: 0,
        }
    }
}

impl Accumulator for SimpleLinearRegressionAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                if let (Some(x), Some(y)) =
                    (numeric_value_to_f64(&arr[0])?, numeric_value_to_f64(&arr[1])?)
                {
                    self.sum_x += x;
                    self.sum_y += y;
                    self.sum_xx += x * x;
                    self.sum_xy += x * y;
                    self.count += 1;
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "SIMPLE_LINEAR_REGRESSION merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.count < 2 {
            return Ok(Value::Null);
        }

        let n = self.count as f64;
        let denominator = n * self.sum_xx - self.sum_x * self.sum_x;

        if denominator.abs() < f64::EPSILON {
            return Ok(Value::Null);
        }

        let slope = (n * self.sum_xy - self.sum_x * self.sum_y) / denominator;
        let intercept = (self.sum_y - slope * self.sum_x) / n;

        Ok(Value::Array(Box::new(vec![
            Value::Float64(slope),
            Value::Float64(intercept),
        ])))
    }

    fn reset(&mut self) {
        self.sum_x = 0.0;
        self.sum_y = 0.0;
        self.sum_xx = 0.0;
        self.sum_xy = 0.0;
        self.count = 0;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct SimpleLinearRegressionFunction;

impl AggregateFunction for SimpleLinearRegressionFunction {
    fn name(&self) -> &str {
        "SIMPLE_LINEAR_REGRESSION"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Float64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(SimpleLinearRegressionAccumulator::new())
    }
}

/// CONTINGENCY - Contingency coefficient (measure of association)
#[derive(Debug, Clone)]
pub struct ContingencyAccumulator {
    counts: HashMap<(String, String), usize>,
    row_totals: HashMap<String, usize>,
    col_totals: HashMap<String, usize>,
    total: usize,
}

impl Default for ContingencyAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl ContingencyAccumulator {
    pub fn new() -> Self {
        Self {
            counts: HashMap::new(),
            row_totals: HashMap::new(),
            col_totals: HashMap::new(),
            total: 0,
        }
    }
}

impl Accumulator for ContingencyAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                let x = value_to_string(&arr[0]);
                let y = value_to_string(&arr[1]);

                *self.counts.entry((x.clone(), y.clone())).or_insert(0) += 1;
                *self.row_totals.entry(x).or_insert(0) += 1;
                *self.col_totals.entry(y).or_insert(0) += 1;
                self.total += 1;
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "CONTINGENCY merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.total == 0 {
            return Ok(Value::Null);
        }

        let mut chi_square = 0.0;
        for ((row, col), &observed) in &self.counts {
            let row_total = *self.row_totals.get(row).unwrap_or(&0) as f64;
            let col_total = *self.col_totals.get(col).unwrap_or(&0) as f64;
            let expected = (row_total * col_total) / self.total as f64;

            if expected > 0.0 {
                let diff = observed as f64 - expected;
                chi_square += (diff * diff) / expected;
            }
        }

        let contingency = (chi_square / (chi_square + self.total as f64)).sqrt();
        Ok(Value::Float64(contingency))
    }

    fn reset(&mut self) {
        self.counts.clear();
        self.row_totals.clear();
        self.col_totals.clear();
        self.total = 0;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct ContingencyFunction;

impl AggregateFunction for ContingencyFunction {
    fn name(&self) -> &str {
        "CONTINGENCY"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(ContingencyAccumulator::new())
    }
}

/// CRAMERS_V - Cramr's V statistic (measure of association between categorical variables)
#[derive(Debug, Clone)]
pub struct CramersVAccumulator {
    counts: HashMap<(String, String), usize>,
    row_totals: HashMap<String, usize>,
    col_totals: HashMap<String, usize>,
    total: usize,
}

impl Default for CramersVAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl CramersVAccumulator {
    pub fn new() -> Self {
        Self {
            counts: HashMap::new(),
            row_totals: HashMap::new(),
            col_totals: HashMap::new(),
            total: 0,
        }
    }
}

impl Accumulator for CramersVAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                let x = value_to_string(&arr[0]);
                let y = value_to_string(&arr[1]);

                *self.counts.entry((x.clone(), y.clone())).or_insert(0) += 1;
                *self.row_totals.entry(x).or_insert(0) += 1;
                *self.col_totals.entry(y).or_insert(0) += 1;
                self.total += 1;
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "CRAMERS_V merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.total == 0 {
            return Ok(Value::Null);
        }

        let mut chi_square = 0.0;
        for ((row, col), &observed) in &self.counts {
            let row_total = *self.row_totals.get(row).unwrap_or(&0) as f64;
            let col_total = *self.col_totals.get(col).unwrap_or(&0) as f64;
            let expected = (row_total * col_total) / self.total as f64;

            if expected > 0.0 {
                let diff = observed as f64 - expected;
                chi_square += (diff * diff) / expected;
            }
        }

        let rows = self.row_totals.len();
        let cols = self.col_totals.len();
        let min_dim = rows.min(cols) as f64;

        if min_dim <= 1.0 {
            return Ok(Value::Null);
        }

        let cramers_v = (chi_square / (self.total as f64 * (min_dim - 1.0))).sqrt();
        Ok(Value::Float64(cramers_v))
    }

    fn reset(&mut self) {
        self.counts.clear();
        self.row_totals.clear();
        self.col_totals.clear();
        self.total = 0;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct CramersVFunction;

impl AggregateFunction for CramersVFunction {
    fn name(&self) -> &str {
        "CRAMERS_V"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(CramersVAccumulator::new())
    }
}

// === String Aggregate Functions =============================================== //

/// GROUP_CONCAT - Concatenate strings with separator (ClickHouse variant)
#[derive(Debug, Clone)]
pub struct GroupConcatAccumulator {
    values: Vec<String>,
    separator: String,
}

impl Default for GroupConcatAccumulator {
    fn default() -> Self {
        Self::new(",".to_string())
    }
}

impl GroupConcatAccumulator {
    pub fn new(separator: String) -> Self {
        Self {
            values: Vec::new(),
            separator,
        }
    }
}

impl Accumulator for GroupConcatAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if !value.is_null() {
            self.values.push(value_to_string(value));
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "GROUP_CONCAT merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::String(self.values.join(&self.separator)))
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct GroupConcatFunction {
    separator: String,
}

impl Default for GroupConcatFunction {
    fn default() -> Self {
        Self {
            separator: ",".to_string(),
        }
    }
}

impl GroupConcatFunction {
    pub fn new(separator: String) -> Self {
        Self { separator }
    }
}

impl AggregateFunction for GroupConcatFunction {
    fn name(&self) -> &str {
        "GROUP_CONCAT"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::String)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(GroupConcatAccumulator::new(self.separator.clone()))
    }
}

// === Information Theory Functions ============================================= //

/// ENTROPY - Shannon entropy of the distribution
#[derive(Debug, Clone)]
pub struct EntropyAccumulator {
    counts: HashMap<String, usize>,
    total: usize,
}

impl Default for EntropyAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl EntropyAccumulator {
    pub fn new() -> Self {
        Self {
            counts: HashMap::new(),
            total: 0,
        }
    }
}

impl Accumulator for EntropyAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if !value.is_null() {
            let key = value_to_string(value);
            *self.counts.entry(key).or_insert(0) += 1;
            self.total += 1;
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "ENTROPY merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.total == 0 {
            return Ok(Value::Null);
        }

        let mut entropy = 0.0;
        for &count in self.counts.values() {
            if count > 0 {
                let p = count as f64 / self.total as f64;
                entropy -= p * p.log2();
            }
        }

        Ok(Value::Float64(entropy))
    }

    fn reset(&mut self) {
        self.counts.clear();
        self.total = 0;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct EntropyFunction;

impl AggregateFunction for EntropyFunction {
    fn name(&self) -> &str {
        "ENTROPY"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(EntropyAccumulator::new())
    }
}

/// THEIL_U - Theil's U uncertainty coefficient
#[derive(Debug, Clone)]
pub struct TheilUAccumulator {
    counts: HashMap<(String, String), usize>,
    x_counts: HashMap<String, usize>,
    y_counts: HashMap<String, usize>,
    total: usize,
}

impl Default for TheilUAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl TheilUAccumulator {
    pub fn new() -> Self {
        Self {
            counts: HashMap::new(),
            x_counts: HashMap::new(),
            y_counts: HashMap::new(),
            total: 0,
        }
    }
}

impl Accumulator for TheilUAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                let x = value_to_string(&arr[0]);
                let y = value_to_string(&arr[1]);

                *self.counts.entry((x.clone(), y.clone())).or_insert(0) += 1;
                *self.x_counts.entry(x).or_insert(0) += 1;
                *self.y_counts.entry(y).or_insert(0) += 1;
                self.total += 1;
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "THEIL_U merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.total == 0 {
            return Ok(Value::Null);
        }

        let n = self.total as f64;
        let mut h_y = 0.0;
        for &count in self.y_counts.values() {
            if count > 0 {
                let p = count as f64 / n;
                h_y -= p * p.log2();
            }
        }

        let mut h_y_given_x = 0.0;
        for ((x, _y), &count) in &self.counts {
            if count > 0 {
                let p_xy = count as f64 / n;
                let p_x = *self.x_counts.get(x).unwrap_or(&0) as f64 / n;
                if p_x > 0.0 {
                    h_y_given_x -= p_xy * (p_xy / p_x).log2();
                }
            }
        }

        if h_y.abs() < f64::EPSILON {
            return Ok(Value::Null);
        }

        let theil_u = (h_y - h_y_given_x) / h_y;
        Ok(Value::Float64(theil_u))
    }

    fn reset(&mut self) {
        self.counts.clear();
        self.x_counts.clear();
        self.y_counts.clear();
        self.total = 0;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct TheilUFunction;

impl AggregateFunction for TheilUFunction {
    fn name(&self) -> &str {
        "THEIL_U"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(TheilUAccumulator::new())
    }
}

// === Categorical Analysis Functions =========================================== //

/// CATEGORICAL_INFORMATION_VALUE - Information value for categorical analysis
#[derive(Debug, Clone)]
pub struct CategoricalInformationValueAccumulator {
    good_counts: HashMap<String, usize>,
    bad_counts: HashMap<String, usize>,
    total_good: usize,
    total_bad: usize,
}

impl Default for CategoricalInformationValueAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl CategoricalInformationValueAccumulator {
    pub fn new() -> Self {
        Self {
            good_counts: HashMap::new(),
            bad_counts: HashMap::new(),
            total_good: 0,
            total_bad: 0,
        }
    }
}

impl Accumulator for CategoricalInformationValueAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                let category = value_to_string(&arr[0]);
                let is_good = if let Some(b) = arr[1].as_bool() {
                    b
                } else if let Some(i) = arr[1].as_i64() {
                    i != 0
                } else {
                    false
                };

                if is_good {
                    *self.good_counts.entry(category).or_insert(0) += 1;
                    self.total_good += 1;
                } else {
                    *self.bad_counts.entry(category).or_insert(0) += 1;
                    self.total_bad += 1;
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "CATEGORICAL_INFORMATION_VALUE merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.total_good == 0 || self.total_bad == 0 {
            return Ok(Value::Null);
        }

        let mut iv = 0.0;
        let mut all_categories = std::collections::HashSet::new();
        for key in self.good_counts.keys() {
            all_categories.insert(key.clone());
        }
        for key in self.bad_counts.keys() {
            all_categories.insert(key.clone());
        }

        for category in all_categories {
            let good = *self.good_counts.get(&category).unwrap_or(&0) as f64;
            let bad = *self.bad_counts.get(&category).unwrap_or(&0) as f64;

            let dist_good = good / self.total_good as f64;
            let dist_bad = bad / self.total_bad as f64;

            if dist_good > 0.0 && dist_bad > 0.0 {
                let woe = (dist_good / dist_bad).ln();
                iv += (dist_good - dist_bad) * woe;
            }
        }

        Ok(Value::Float64(iv))
    }

    fn reset(&mut self) {
        self.good_counts.clear();
        self.bad_counts.clear();
        self.total_good = 0;
        self.total_bad = 0;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct CategoricalInformationValueFunction;

impl AggregateFunction for CategoricalInformationValueFunction {
    fn name(&self) -> &str {
        "CATEGORICAL_INFORMATION_VALUE"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(CategoricalInformationValueAccumulator::new())
    }
}

// === Time Series Functions ==================================================== //

/// DELTA_SUM - Sum of differences between consecutive values
#[derive(Debug, Clone)]
pub struct DeltaSumAccumulator {
    last_value: Option<f64>,
    delta_sum: f64,
}

impl Default for DeltaSumAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl DeltaSumAccumulator {
    pub fn new() -> Self {
        Self {
            last_value: None,
            delta_sum: 0.0,
        }
    }
}

impl Accumulator for DeltaSumAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(num) = numeric_value_to_f64(value)? {
            if let Some(last) = self.last_value {
                self.delta_sum += num - last;
            }
            self.last_value = Some(num);
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "DELTA_SUM merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Float64(self.delta_sum))
    }

    fn reset(&mut self) {
        self.last_value = None;
        self.delta_sum = 0.0;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct DeltaSumFunction;

impl AggregateFunction for DeltaSumFunction {
    fn name(&self) -> &str {
        "DELTA_SUM"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(DeltaSumAccumulator::new())
    }
}

/// DELTA_SUM_TIMESTAMP - Sum of value differences weighted by time intervals
#[derive(Debug, Clone)]
pub struct DeltaSumTimestampAccumulator {
    points: Vec<(i64, f64)>,
}

impl Default for DeltaSumTimestampAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl DeltaSumTimestampAccumulator {
    pub fn new() -> Self {
        Self { points: Vec::new() }
    }
}

impl Accumulator for DeltaSumTimestampAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                if let (Some(timestamp), Some(val)) =
                    (arr[0].as_i64(), numeric_value_to_f64(&arr[1])?)
                {
                    self.points.push((timestamp, val));
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "DELTA_SUM_TIMESTAMP merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.points.len() < 2 {
            return Ok(Value::Float64(0.0));
        }

        let mut sorted_points = self.points.clone();
        sorted_points.sort_by_key(|(timestamp, _)| *timestamp);

        let mut weighted_sum = 0.0;
        for i in 1..sorted_points.len() {
            let (t1, v1) = sorted_points[i - 1];
            let (t2, v2) = sorted_points[i];
            let time_diff = (t2 - t1) as f64;
            let value_diff = v2 - v1;
            weighted_sum += value_diff * time_diff;
        }

        Ok(Value::Float64(weighted_sum))
    }

    fn reset(&mut self) {
        self.points.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct DeltaSumTimestampFunction;

impl AggregateFunction for DeltaSumTimestampFunction {
    fn name(&self) -> &str {
        "DELTA_SUM_TIMESTAMP"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(DeltaSumTimestampAccumulator::new())
    }
}

// === Array Manipulation Functions ============================================= //

/// ARRAY_FLATTEN - Flatten nested arrays into a single-level array
#[derive(Debug, Clone)]
pub struct ArrayFlattenAccumulator {
    values: Vec<Value>,
}

impl Default for ArrayFlattenAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl ArrayFlattenAccumulator {
    pub fn new() -> Self {
        Self { values: Vec::new() }
    }

    fn flatten_value(&mut self, value: &Value) {
        match value {
            Value::Array(arr) => {
                for item in arr.iter() {
                    self.flatten_value(item);
                }
            }
            _ => self.values.push(value.clone()),
        }
    }
}

impl Accumulator for ArrayFlattenAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        self.flatten_value(value);
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "ARRAY_FLATTEN merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Array(self.values.clone()))
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct ArrayFlattenFunction;

impl AggregateFunction for ArrayFlattenFunction {
    fn name(&self) -> &str {
        "ARRAY_FLATTEN"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Unknown)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(ArrayFlattenAccumulator::new())
    }
}

/// ARRAY_REDUCE - Reduce array to single value using operation
#[derive(Debug, Clone)]
pub struct ArrayReduceAccumulator {
    operation: String,
    result: Option<f64>,
}

impl Default for ArrayReduceAccumulator {
    fn default() -> Self {
        Self::new("sum".to_string())
    }
}

impl ArrayReduceAccumulator {
    pub fn new(operation: String) -> Self {
        Self {
            operation,
            result: None,
        }
    }
}

impl Accumulator for ArrayReduceAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            for item in arr.iter() {
                if let Some(num) = numeric_value_to_f64(item)? {
                    self.result = Some(match self.result {
                        Some(current) => match self.operation.as_str() {
                            "sum" => current + num,
                            "product" | "mul" => current * num,
                            "min" => current.min(num),
                            "max" => current.max(num),
                            _ => current + num,
                        },
                        None => num,
                    });
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "ARRAY_REDUCE merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        match self.result {
            Some(val) => Ok(Value::Float64(val)),
            None => Ok(Value::Null),
        }
    }

    fn reset(&mut self) {
        self.result = None;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct ArrayReduceFunction {
    operation: String,
}

impl Default for ArrayReduceFunction {
    fn default() -> Self {
        Self {
            operation: "sum".to_string(),
        }
    }
}

impl ArrayReduceFunction {
    pub fn new(operation: String) -> Self {
        Self { operation }
    }
}

impl AggregateFunction for ArrayReduceFunction {
    fn name(&self) -> &str {
        "ARRAY_REDUCE"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(ArrayReduceAccumulator::new(self.operation.clone()))
    }
}

// === Bitmap Functions ========================================================= //

/// BITMAP_CARDINALITY - Count distinct bits set in bitmap aggregate
#[derive(Debug, Clone)]
pub struct BitmapCardinalityAccumulator {
    bitmap: std::collections::HashSet<i64>,
}

impl Default for BitmapCardinalityAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl BitmapCardinalityAccumulator {
    pub fn new() -> Self {
        Self {
            bitmap: std::collections::HashSet::new(),
        }
    }
}

impl Accumulator for BitmapCardinalityAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(bit) = value.as_i64() {
            self.bitmap.insert(bit);
        } else if let Value::Array(arr) = value {
            for item in arr.iter() {
                if let Some(bit) = item.as_i64() {
                    self.bitmap.insert(bit);
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "BITMAP_CARDINALITY merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Int64(self.bitmap.len() as i64))
    }

    fn reset(&mut self) {
        self.bitmap.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct BitmapCardinalityFunction;

impl AggregateFunction for BitmapCardinalityFunction {
    fn name(&self) -> &str {
        "BITMAP_CARDINALITY"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(BitmapCardinalityAccumulator::new())
    }
}

/// BITMAP_AND_CARDINALITY - Cardinality of bitmap AND operation
#[derive(Debug, Clone)]
pub struct BitmapAndCardinalityAccumulator {
    bitmaps: Vec<std::collections::HashSet<i64>>,
}

impl Default for BitmapAndCardinalityAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl BitmapAndCardinalityAccumulator {
    pub fn new() -> Self {
        Self {
            bitmaps: Vec::new(),
        }
    }
}

impl Accumulator for BitmapAndCardinalityAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            let mut bitmap = std::collections::HashSet::new();
            for item in arr.iter() {
                if let Some(bit) = item.as_i64() {
                    bitmap.insert(bit);
                }
            }
            self.bitmaps.push(bitmap);
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "BITMAP_AND_CARDINALITY merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.bitmaps.is_empty() {
            return Ok(Value::Int64(0));
        }

        let mut result = self.bitmaps[0].clone();
        for bitmap in &self.bitmaps[1..] {
            result = result.intersection(bitmap).copied().collect();
        }

        Ok(Value::Int64(result.len() as i64))
    }

    fn reset(&mut self) {
        self.bitmaps.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct BitmapAndCardinalityFunction;

impl AggregateFunction for BitmapAndCardinalityFunction {
    fn name(&self) -> &str {
        "BITMAP_AND_CARDINALITY"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_INT64
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(BitmapAndCardinalityAccumulator::new())
    }
}

/// BITMAP_OR_CARDINALITY - Cardinality of bitmap OR operation
#[derive(Debug, Clone)]
pub struct BitmapOrCardinalityAccumulator {
    bitmap: std::collections::HashSet<i64>,
}

impl Default for BitmapOrCardinalityAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl BitmapOrCardinalityAccumulator {
    pub fn new() -> Self {
        Self {
            bitmap: std::collections::HashSet::new(),
        }
    }
}

impl Accumulator for BitmapOrCardinalityAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            for item in arr.iter() {
                if let Some(bit) = item.as_i64() {
                    self.bitmap.insert(bit);
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "BITMAP_OR_CARDINALITY merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Int64(self.bitmap.len() as i64))
    }

    fn reset(&mut self) {
        self.bitmap.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct BitmapOrCardinalityFunction;

impl AggregateFunction for BitmapOrCardinalityFunction {
    fn name(&self) -> &str {
        "BITMAP_OR_CARDINALITY"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_INT64
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(BitmapOrCardinalityAccumulator::new())
    }
}

// === Advanced Quantile Functions ============================================== //

/// QUANTILE_DETERMINISTIC - Deterministic quantile using hash-based sampling
#[derive(Debug, Clone)]
pub struct QuantileDeterministicAccumulator {
    values: Vec<(f64, u64)>,
    quantile: f64,
}

impl Default for QuantileDeterministicAccumulator {
    fn default() -> Self {
        Self::new(0.5)
    }
}

impl QuantileDeterministicAccumulator {
    pub fn new(quantile: f64) -> Self {
        Self {
            values: Vec::new(),
            quantile: quantile.clamp(0.0, 1.0),
        }
    }

    fn hash_value(val: f64) -> u64 {
        val.to_bits()
    }
}

impl Accumulator for QuantileDeterministicAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                if let (Some(val), Some(det)) =
                    (numeric_value_to_f64(&arr[0])?, arr[1].as_i64())
                {
                    self.values.push((val, det as u64));
                }
            }
        } else if let Some(val) = numeric_value_to_f64(value)? {
            self.values.push((val, Self::hash_value(val)));
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "QUANTILE_DETERMINISTIC merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.values.is_empty() {
            return Ok(Value::Null);
        }

        let mut sorted = self.values.clone();
        sorted.sort_by(|(a, hash_a), (b, hash_b)| {
            hash_a.cmp(hash_b).then_with(|| {
                a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal)
            })
        });

        let index = ((sorted.len() - 1) as f64 * self.quantile).round() as usize;
        Ok(Value::Float64(sorted[index].0))
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct QuantileDeterministicFunction {
    quantile: f64,
}

impl Default for QuantileDeterministicFunction {
    fn default() -> Self {
        Self { quantile: 0.5 }
    }
}

impl QuantileDeterministicFunction {
    pub fn new(quantile: f64) -> Self {
        Self { quantile }
    }
}

impl AggregateFunction for QuantileDeterministicFunction {
    fn name(&self) -> &str {
        "QUANTILE_DETERMINISTIC"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(QuantileDeterministicAccumulator::new(self.quantile))
    }
}

/// QUANTILE_BFLOAT16 - Memory-efficient quantile using bfloat16 compression
#[derive(Debug, Clone)]
pub struct QuantileBFloat16Accumulator {
    values: Vec<u16>,
    quantile: f64,
}

impl Default for QuantileBFloat16Accumulator {
    fn default() -> Self {
        Self::new(0.5)
    }
}

impl QuantileBFloat16Accumulator {
    pub fn new(quantile: f64) -> Self {
        Self {
            values: Vec::new(),
            quantile: quantile.clamp(0.0, 1.0),
        }
    }

    fn f32_to_bf16(f: f32) -> u16 {
        (f.to_bits() >> 16) as u16
    }

    fn bf16_to_f32(bf: u16) -> f32 {
        f32::from_bits((bf as u32) << 16)
    }
}

impl Accumulator for QuantileBFloat16Accumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(num) = numeric_value_to_f64(value)? {
            let bf16 = Self::f32_to_bf16(num as f32);
            self.values.push(bf16);
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "QUANTILE_BFLOAT16 merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.values.is_empty() {
            return Ok(Value::Null);
        }

        let mut sorted = self.values.clone();
        sorted.sort_unstable();

        let index = ((sorted.len() - 1) as f64 * self.quantile).round() as usize;
        let result = Self::bf16_to_f32(sorted[index]);
        Ok(Value::Float64(result as f64))
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct QuantileBFloat16Function {
    quantile: f64,
}

impl Default for QuantileBFloat16Function {
    fn default() -> Self {
        Self { quantile: 0.5 }
    }
}

impl QuantileBFloat16Function {
    pub fn new(quantile: f64) -> Self {
        Self { quantile }
    }
}

impl AggregateFunction for QuantileBFloat16Function {
    fn name(&self) -> &str {
        "QUANTILE_BFLOAT16"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(QuantileBFloat16Accumulator::new(self.quantile))
    }
}

// === Statistical Test Functions =============================================== //

/// MANN_WHITNEY_U_TEST - Mann-Whitney U test (Wilcoxon rank-sum test)
#[derive(Debug, Clone)]
pub struct MannWhitneyUTestAccumulator {
    sample1: Vec<f64>,
    sample2: Vec<f64>,
}

impl Default for MannWhitneyUTestAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl MannWhitneyUTestAccumulator {
    pub fn new() -> Self {
        Self {
            sample1: Vec::new(),
            sample2: Vec::new(),
        }
    }
}

impl Accumulator for MannWhitneyUTestAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                if let (Some(val), Some(group)) =
                    (numeric_value_to_f64(&arr[0])?, arr[1].as_i64())
                {
                    if group == 0 {
                        self.sample1.push(val);
                    } else {
                        self.sample2.push(val);
                    }
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "MANN_WHITNEY_U_TEST merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.sample1.is_empty() || self.sample2.is_empty() {
            return Ok(Value::Null);
        }

        let n1 = self.sample1.len() as f64;
        let n2 = self.sample2.len() as f64;

        let mut combined: Vec<(f64, usize)> = Vec::new();
        for &val in &self.sample1 {
            combined.push((val, 0));
        }
        for &val in &self.sample2 {
            combined.push((val, 1));
        }
        combined.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap_or(std::cmp::Ordering::Equal));

        let mut rank_sum1 = 0.0;
        for (i, (_val, group)) in combined.iter().enumerate() {
            if *group == 0 {
                rank_sum1 += (i + 1) as f64;
            }
        }

        let u1 = rank_sum1 - (n1 * (n1 + 1.0)) / 2.0;
        let u2 = n1 * n2 - u1;
        let u = u1.min(u2);

        let mean_u = (n1 * n2) / 2.0;
        let std_u = ((n1 * n2 * (n1 + n2 + 1.0)) / 12.0).sqrt();

        let z = (u - mean_u) / std_u;

        Ok(Value::Array(Box::new(vec![
            Value::Float64(u),
            Value::Float64(z),
        ])))
    }

    fn reset(&mut self) {
        self.sample1.clear();
        self.sample2.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct MannWhitneyUTestFunction;

impl AggregateFunction for MannWhitneyUTestFunction {
    fn name(&self) -> &str {
        "MANN_WHITNEY_U_TEST"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Float64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(MannWhitneyUTestAccumulator::new())
    }
}

/// STUDENT_T_TEST - Student's t-test
#[derive(Debug, Clone)]
pub struct StudentTTestAccumulator {
    sample1: Vec<f64>,
    sample2: Vec<f64>,
}

impl Default for StudentTTestAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl StudentTTestAccumulator {
    pub fn new() -> Self {
        Self {
            sample1: Vec::new(),
            sample2: Vec::new(),
        }
    }

    fn mean(data: &[f64]) -> f64 {
        if data.is_empty() {
            return 0.0;
        }
        data.iter().sum::<f64>() / data.len() as f64
    }

    fn variance(data: &[f64], mean: f64) -> f64 {
        if data.len() <= 1 {
            return 0.0;
        }
        data.iter().map(|x| (x - mean).powi(2)).sum::<f64>() / (data.len() - 1) as f64
    }
}

impl Accumulator for StudentTTestAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                if let (Some(val), Some(group)) =
                    (numeric_value_to_f64(&arr[0])?, arr[1].as_i64())
                {
                    if group == 0 {
                        self.sample1.push(val);
                    } else {
                        self.sample2.push(val);
                    }
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "STUDENT_T_TEST merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.sample1.len() < 2 || self.sample2.len() < 2 {
            return Ok(Value::Null);
        }

        let n1 = self.sample1.len() as f64;
        let n2 = self.sample2.len() as f64;

        let mean1 = Self::mean(&self.sample1);
        let mean2 = Self::mean(&self.sample2);

        let var1 = Self::variance(&self.sample1, mean1);
        let var2 = Self::variance(&self.sample2, mean2);

        let pooled_var = ((n1 - 1.0) * var1 + (n2 - 1.0) * var2) / (n1 + n2 - 2.0);
        let se = (pooled_var * (1.0 / n1 + 1.0 / n2)).sqrt();

        let t = if se.abs() < f64::EPSILON {
            0.0
        } else {
            (mean1 - mean2) / se
        };

        let df = n1 + n2 - 2.0;

        Ok(Value::Array(Box::new(vec![
            Value::Float64(t),
            Value::Float64(df),
        ])))
    }

    fn reset(&mut self) {
        self.sample1.clear();
        self.sample2.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct StudentTTestFunction;

impl AggregateFunction for StudentTTestFunction {
    fn name(&self) -> &str {
        "STUDENT_T_TEST"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Float64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(StudentTTestAccumulator::new())
    }
}

/// WELCH_T_TEST - Welch's t-test (unequal variances)
#[derive(Debug, Clone)]
pub struct WelchTTestAccumulator {
    sample1: Vec<f64>,
    sample2: Vec<f64>,
}

impl Default for WelchTTestAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl WelchTTestAccumulator {
    pub fn new() -> Self {
        Self {
            sample1: Vec::new(),
            sample2: Vec::new(),
        }
    }

    fn mean(data: &[f64]) -> f64 {
        if data.is_empty() {
            return 0.0;
        }
        data.iter().sum::<f64>() / data.len() as f64
    }

    fn variance(data: &[f64], mean: f64) -> f64 {
        if data.len() <= 1 {
            return 0.0;
        }
        data.iter().map(|x| (x - mean).powi(2)).sum::<f64>() / (data.len() - 1) as f64
    }
}

impl Accumulator for WelchTTestAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                if let (Some(val), Some(group)) =
                    (numeric_value_to_f64(&arr[0])?, arr[1].as_i64())
                {
                    if group == 0 {
                        self.sample1.push(val);
                    } else {
                        self.sample2.push(val);
                    }
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "WELCH_T_TEST merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.sample1.len() < 2 || self.sample2.len() < 2 {
            return Ok(Value::Null);
        }

        let n1 = self.sample1.len() as f64;
        let n2 = self.sample2.len() as f64;

        let mean1 = Self::mean(&self.sample1);
        let mean2 = Self::mean(&self.sample2);

        let var1 = Self::variance(&self.sample1, mean1);
        let var2 = Self::variance(&self.sample2, mean2);

        let se = (var1 / n1 + var2 / n2).sqrt();

        let t = if se.abs() < f64::EPSILON {
            0.0
        } else {
            (mean1 - mean2) / se
        };

        let df_num = (var1 / n1 + var2 / n2).powi(2);
        let df_denom = (var1 / n1).powi(2) / (n1 - 1.0) + (var2 / n2).powi(2) / (n2 - 1.0);
        let df = if df_denom.abs() < f64::EPSILON {
            n1 + n2 - 2.0
        } else {
            df_num / df_denom
        };

        Ok(Value::Array(Box::new(vec![
            Value::Float64(t),
            Value::Float64(df),
        ])))
    }

    fn reset(&mut self) {
        self.sample1.clear();
        self.sample2.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct WelchTTestFunction;

impl AggregateFunction for WelchTTestFunction {
    fn name(&self) -> &str {
        "WELCH_T_TEST"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Float64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(WelchTTestAccumulator::new())
    }
}

// === Higher-Order Array Functions ============================================= //

/// ARRAY_MAP - Apply transformation to each array element
#[derive(Debug, Clone)]
pub struct ArrayMapAccumulator {
    operation: String,
    result: Vec<Value>,
}

impl Default for ArrayMapAccumulator {
    fn default() -> Self {
        Self::new("abs".to_string())
    }
}

impl ArrayMapAccumulator {
    pub fn new(operation: String) -> Self {
        Self {
            operation,
            result: Vec::new(),
        }
    }

    fn apply_operation(&self, value: &Value) -> Value {
        match self.operation.as_str() {
            "abs" => {
                if let Some(num) = numeric_value_to_f64(value).ok().flatten() {
                    Value::Float64(num.abs())
                } else {
                    value.clone()
                }
            }
            "negate" => {
                if let Some(num) = numeric_value_to_f64(value).ok().flatten() {
                    Value::Float64(-num)
                } else {
                    value.clone()
                }
            }
            "square" => {
                if let Some(num) = numeric_value_to_f64(value).ok().flatten() {
                    Value::Float64(num * num)
                } else {
                    value.clone()
                }
            }
            "sqrt" => {
                if let Some(num) = numeric_value_to_f64(value).ok().flatten() {
                    if num >= 0.0 {
                        Value::Float64(num.sqrt())
                    } else {
                        Value::Null
                    }
                } else {
                    value.clone()
                }
            }
            "upper" => {
                if let Some(s) = value.as_str() {
                    Value::String(s.to_uppercase())
                } else {
                    value.clone()
                }
            }
            "lower" => {
                if let Some(s) = value.as_str() {
                    Value::String(s.to_lowercase())
                } else {
                    value.clone()
                }
            }
            _ => value.clone(),
        }
    }
}

impl Accumulator for ArrayMapAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            for item in arr.iter() {
                self.result.push(self.apply_operation(item));
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "ARRAY_MAP merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Array(Box::new(self.result.clone())))
    }

    fn reset(&mut self) {
        self.result.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct ArrayMapFunction {
    operation: String,
}

impl Default for ArrayMapFunction {
    fn default() -> Self {
        Self {
            operation: "abs".to_string(),
        }
    }
}

impl ArrayMapFunction {
    pub fn new(operation: String) -> Self {
        Self { operation }
    }
}

impl AggregateFunction for ArrayMapFunction {
    fn name(&self) -> &str {
        "ARRAY_MAP"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Unknown)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(ArrayMapAccumulator::new(self.operation.clone()))
    }
}

/// ARRAY_FILTER - Filter array elements by predicate
#[derive(Debug, Clone)]
pub struct ArrayFilterAccumulator {
    predicate: String,
    result: Vec<Value>,
}

impl Default for ArrayFilterAccumulator {
    fn default() -> Self {
        Self::new("positive".to_string())
    }
}

impl ArrayFilterAccumulator {
    pub fn new(predicate: String) -> Self {
        Self {
            predicate,
            result: Vec::new(),
        }
    }

    fn check_predicate(&self, value: &Value) -> bool {
        match self.predicate.as_str() {
            "positive" => {
                if let Some(num) = numeric_value_to_f64(value).ok().flatten() {
                    num > 0.0
                } else {
                    false
                }
            }
            "negative" => {
                if let Some(num) = numeric_value_to_f64(value).ok().flatten() {
                    num < 0.0
                } else {
                    false
                }
            }
            "nonzero" => {
                if let Some(num) = numeric_value_to_f64(value).ok().flatten() {
                    num.abs() > f64::EPSILON
                } else {
                    false
                }
            }
            "notnull" => !value.is_null(),
            "even" => {
                if let Some(i) = value.as_i64() {
                    i % 2 == 0
                } else {
                    false
                }
            }
            "odd" => {
                if let Some(i) = value.as_i64() {
                    i % 2 != 0
                } else {
                    false
                }
            }
            _ => true,
        }
    }
}

impl Accumulator for ArrayFilterAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            for item in arr.iter() {
                if self.check_predicate(item) {
                    self.result.push(item.clone());
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "ARRAY_FILTER merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Array(Box::new(self.result.clone())))
    }

    fn reset(&mut self) {
        self.result.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Clone)]
pub struct ArrayFilterFunction {
    predicate: String,
}

impl Default for ArrayFilterFunction {
    fn default() -> Self {
        Self {
            predicate: "positive".to_string(),
        }
    }
}

impl ArrayFilterFunction {
    pub fn new(predicate: String) -> Self {
        Self { predicate }
    }
}

impl AggregateFunction for ArrayFilterFunction {
    fn name(&self) -> &str {
        "ARRAY_FILTER"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Unknown)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(ArrayFilterAccumulator::new(self.predicate.clone()))
    }
}

// === Array Combinator Functions =============================================== //

/// SUM_ARRAY - Sum each position across multiple arrays
#[derive(Debug, Clone)]
pub struct SumArrayAccumulator {
    sums: Vec<f64>,
}

impl Default for SumArrayAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl SumArrayAccumulator {
    pub fn new() -> Self {
        Self { sums: Vec::new() }
    }
}

impl Accumulator for SumArrayAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            for (i, item) in arr.iter().enumerate() {
                if let Some(num) = numeric_value_to_f64(item)? {
                    if i >= self.sums.len() {
                        self.sums.resize(i + 1, 0.0);
                    }
                    self.sums[i] += num;
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "SUM_ARRAY merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let result: Vec<Value> = self.sums.iter().map(|&v| Value::Float64(v)).collect();
        Ok(Value::Array(result))
    }

    fn reset(&mut self) {
        self.sums.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct SumArrayFunction;

impl AggregateFunction for SumArrayFunction {
    fn name(&self) -> &str {
        "SUM_ARRAY"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Float64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(SumArrayAccumulator::new())
    }
}

/// AVG_ARRAY - Average each position across multiple arrays
#[derive(Debug, Clone)]
pub struct AvgArrayAccumulator {
    sums: Vec<f64>,
    counts: Vec<usize>,
}

impl Default for AvgArrayAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl AvgArrayAccumulator {
    pub fn new() -> Self {
        Self {
            sums: Vec::new(),
            counts: Vec::new(),
        }
    }
}

impl Accumulator for AvgArrayAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            for (i, item) in arr.iter().enumerate() {
                if let Some(num) = numeric_value_to_f64(item)? {
                    if i >= self.sums.len() {
                        self.sums.resize(i + 1, 0.0);
                        self.counts.resize(i + 1, 0);
                    }
                    self.sums[i] += num;
                    self.counts[i] += 1;
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "AVG_ARRAY merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let result: Vec<Value> = self
            .sums
            .iter()
            .enumerate()
            .map(|(i, &sum)| {
                let count = self.counts.get(i).copied().unwrap_or(0);
                if count > 0 {
                    Value::Float64(sum / count as f64)
                } else {
                    Value::Null
                }
            })
            .collect();
        Ok(Value::Array(result))
    }

    fn reset(&mut self) {
        self.sums.clear();
        self.counts.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct AvgArrayFunction;

impl AggregateFunction for AvgArrayFunction {
    fn name(&self) -> &str {
        "AVG_ARRAY"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Float64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(AvgArrayAccumulator::new())
    }
}

/// MIN_ARRAY - Minimum at each position across multiple arrays
#[derive(Debug, Clone)]
pub struct MinArrayAccumulator {
    mins: Vec<Option<f64>>,
}

impl Default for MinArrayAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl MinArrayAccumulator {
    pub fn new() -> Self {
        Self { mins: Vec::new() }
    }
}

impl Accumulator for MinArrayAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            for (i, item) in arr.iter().enumerate() {
                if let Some(num) = numeric_value_to_f64(item)? {
                    if i >= self.mins.len() {
                        self.mins.resize(i + 1, None);
                    }
                    self.mins[i] = Some(match self.mins[i] {
                        Some(current) => current.min(num),
                        None => num,
                    });
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "MIN_ARRAY merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let result: Vec<Value> = self
            .mins
            .iter()
            .map(|&v| match v {
                Some(val) => Value::Float64(val),
                None => Value::Null,
            })
            .collect();
        Ok(Value::Array(result))
    }

    fn reset(&mut self) {
        self.mins.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct MinArrayFunction;

impl AggregateFunction for MinArrayFunction {
    fn name(&self) -> &str {
        "MIN_ARRAY"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Float64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(MinArrayAccumulator::new())
    }
}

/// MAX_ARRAY - Maximum at each position across multiple arrays
#[derive(Debug, Clone)]
pub struct MaxArrayAccumulator {
    maxs: Vec<Option<f64>>,
}

impl Default for MaxArrayAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl MaxArrayAccumulator {
    pub fn new() -> Self {
        Self { maxs: Vec::new() }
    }
}

impl Accumulator for MaxArrayAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            for (i, item) in arr.iter().enumerate() {
                if let Some(num) = numeric_value_to_f64(item)? {
                    if i >= self.maxs.len() {
                        self.maxs.resize(i + 1, None);
                    }
                    self.maxs[i] = Some(match self.maxs[i] {
                        Some(current) => current.max(num),
                        None => num,
                    });
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::unsupported_feature(
            "MAX_ARRAY merge not implemented".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        let result: Vec<Value> = self
            .maxs
            .iter()
            .map(|&v| match v {
                Some(val) => Value::Float64(val),
                None => Value::Null,
            })
            .collect();
        Ok(Value::Array(result))
    }

    fn reset(&mut self) {
        self.maxs.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct MaxArrayFunction;

impl AggregateFunction for MaxArrayFunction {
    fn name(&self) -> &str {
        "MAX_ARRAY"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Float64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(MaxArrayAccumulator::new())
    }
}

// === Helper Functions ========================================================== //

/// Convert Value to f64 if numeric, None if NULL
fn numeric_value_to_f64(value: &Value) -> Result<Option<f64>> {
    if value.is_null() {
        return Ok(None);
    }

    if let Some(i) = value.as_i64() {
        return Ok(Some(i as f64));
    }

    if let Some(f) = value.as_f64() {
        return Ok(Some(f));
    }

    if let Some(d) = value.as_numeric() {
        return d.to_f64().map(Some).ok_or_else(|| Error::TypeMismatch {
            expected: "NUMERIC".to_string(),
            actual: "NUMERIC (out of range)".to_string(),
        });
    }

    Err(Error::TypeMismatch {
        expected: "NUMERIC".to_string(),
        actual: value.data_type().to_string(),
    })
}

/// Convert a Value to a string key
fn value_to_string(value: &Value) -> String {
    if let Some(s) = value.as_str() {
        return s.to_string();
    }
    if let Some(i) = value.as_i64() {
        return i.to_string();
    }
    if let Some(f) = value.as_f64() {
        return f.to_string();
    }
    if let Some(b) = value.as_bool() {
        return b.to_string();
    }
    if let Some(d) = value.as_numeric() {
        return d.to_string();
    }
    if let Some(d) = value.as_date() {
        return d.to_string();
    }
    if let Some(ts) = value.as_timestamp() {
        return ts.to_string();
    }

    format!("{:?}", value)
}

/// Wrapper to provide `Hash` for `Value`
struct HashableValue<'a>(&'a Value);

impl<'a> Hash for HashableValue<'a> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        if self.0.is_null() {
            return 0_u8.hash(state);
        }

        if let Some(b) = self.0.as_bool() {
            return b.hash(state);
        }

        if let Some(i) = self.0.as_i64() {
            return i.hash(state);
        }

        if let Some(f) = self.0.as_f64() {
            return f.to_bits().hash(state);
        }

        if let Some(s) = self.0.as_str() {
            return s.hash(state);
        }

        if let Some(d) = self.0.as_date() {
            return d.to_string().hash(state);
        }

        if let Some(dt) = self.0.as_datetime() {
            return dt.timestamp_nanos_opt().unwrap_or(0).hash(state);
        }

        if let Some(ts) = self.0.as_timestamp() {
            return ts.timestamp_nanos_opt().unwrap_or(0).hash(state);
        }

        if let Some(d) = self.0.as_numeric() {
            return d.to_string().hash(state);
        }

        match self.0 {
            Value::Struct(fields) => {
                fields.len().hash(state);
                for (key, value) in fields.iter() {
                    key.hash(state);
                    HashableValue(value).hash(state);
                }
            }
            Value::Array(items) => {
                items.len().hash(state);
                for item in items.iter() {
                    HashableValue(item).hash(state);
                }
            }
            Value::Bytes(bytes) => bytes.hash(state),
            Value::Geography(wkt) => wkt.hash(state),
            Value::Json(json) => json.to_string().hash(state),
            Value::Uuid(uuid) => uuid.as_bytes().hash(state),
            _ => {
                // For any other variants (Inline, LargeString, Numeric, etc.)
                // use the Debug representation as a fallback
                format!("{:?}", self.0).hash(state)
            }
        }
    }
}
