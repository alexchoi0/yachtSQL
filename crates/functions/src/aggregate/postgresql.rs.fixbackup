//! PostgreSQL-specific aggregate functions

use crate::aggregate::{Accumulator, AggregateFunction};
use core::error::{Error, Result};
use core::types::DataType;
use std::sync::LazyLock;
use core::types::Value;
use std::collections::HashMap;


// Static type arrays for arg_types() methods
static ARRAY_OF_UNKNOWN: LazyLock<Vec<DataType>> = LazyLock::new(|| vec![DataType::Array(Box::new(DataType::Unknown))]);


/// Helper to convert numeric values to f64
fn numeric_value_to_f64(value: &Value) -> Result<Option<f64>> {
    use rust_decimal::prelude::ToPrimitive;
    if value.is_null() {
        return Ok(None);
    }

    if let Some(i) = value.as_i64() {
        return Ok(Some(i as f64));
    }

    if let Some(f) = value.as_f64() {
        return Ok(Some(f));
    }

    if let Some(n) = value.as_numeric() {
        return Ok(n.to_f64());
    }

    Err(Error::InvalidOperation(format!(
        "Cannot convert {:?} to f64",
        value
    )))
}

/// ARRAY_REMOVE - Remove all occurrences of a value from an array
#[derive(Debug, Clone)]
pub struct ArrayRemoveAccumulator {
    arrays: Vec<Vec<Value>>,
    remove_value: Value,
}

impl Default for ArrayRemoveAccumulator {
    fn default() -> Self {
        Self {
            arrays: Vec::new(),
            remove_value: Value::Null,
        }
    }
}

impl ArrayRemoveAccumulator {
    pub fn new(remove_value: Value) -> Self {
        Self {
            arrays: Vec::new(),
            remove_value,
        }
    }
}

impl Accumulator for ArrayRemoveAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            let filtered: Vec<Value> = arr
                .iter()
                .filter(|v| *v != &self.remove_value)
                .cloned()
                .collect();
            self.arrays.push(filtered);
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::InternalError(
            "Merge not supported for ARRAY_REMOVE".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        if self.arrays.is_empty() {
            return Ok(Value::Array(Box::new(Vec::new())));
        }

        let mut result = Vec::new();
        for arr in &self.arrays {
            result.extend(arr.clone());
        }
        Ok(Value::Array(Box::new(result)))
    }

    fn reset(&mut self) {
        self.arrays.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug)]
pub struct ArrayRemoveFunction {
    remove_value: Value,
}

impl Default for ArrayRemoveFunction {
    fn default() -> Self {
        Self {
            remove_value: Value::Null,
        }
    }
}

impl ArrayRemoveFunction {
    pub fn new(remove_value: Value) -> Self {
        Self { remove_value }
    }
}

impl AggregateFunction for ArrayRemoveFunction {
    fn name(&self) -> &str {
        "ARRAY_REMOVE"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Unknown)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(ArrayRemoveAccumulator::new(self.remove_value.clone()))
    }
}

/// ARRAY_POSITIONS - Find all positions of a value in an array
#[derive(Debug, Clone, Default)]
pub struct ArrayPositionsAccumulator {
    search_value: Value,
    result: Vec<i64>,
}

impl ArrayPositionsAccumulator {
    pub fn new(search_value: Value) -> Self {
        Self {
            search_value,
            result: Vec::new(),
        }
    }
}

impl Accumulator for ArrayPositionsAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            for (idx, val) in arr.iter().enumerate() {
                if val == &self.search_value {
                    self.result.push((idx + 1) as i64);
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, _other: &dyn Accumulator) -> Result<()> {
        Err(Error::InternalError(
            "Merge not supported for ARRAY_POSITIONS".to_string(),
        ))
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Array(Box::new(
            self.result.iter().map(|&i| Value::Int64(i)).collect(),
        )))
    }

    fn reset(&mut self) {
        self.result.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug)]
pub struct ArrayPositionsFunction {
    search_value: Value,
}

impl Default for ArrayPositionsFunction {
    fn default() -> Self {
        Self {
            search_value: Value::Null,
        }
    }
}

impl ArrayPositionsFunction {
    pub fn new(search_value: Value) -> Self {
        Self { search_value }
    }
}

impl AggregateFunction for ArrayPositionsFunction {
    fn name(&self) -> &str {
        "ARRAY_POSITIONS"
    }

    fn arg_types(&self) -> &[DataType] {
        &ARRAY_OF_UNKNOWN
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Array(Box::new(DataType::Int64)))
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(ArrayPositionsAccumulator::new(self.search_value.clone()))
    }
}

/// REGR_AVGX - Average of the independent variable (x)
#[derive(Debug, Clone, Default)]
pub struct RegrAvgXAccumulator {
    x_values: Vec<f64>,
}

impl Accumulator for RegrAvgXAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                if let Some(x) = numeric_value_to_f64(&arr[1])? {
                    self.x_values.push(x);
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, other: &dyn Accumulator) -> Result<()> {
        if let Some(other_acc) = other.as_any().downcast_ref::<RegrAvgXAccumulator>() {
            self.x_values.extend(&other_acc.x_values);
            Ok(())
        } else {
            Err(Error::InternalError(
                "Cannot merge different accumulator types".to_string(),
            ))
        }
    }

    fn finalize(&self) -> Result<Value> {
        if self.x_values.is_empty() {
            return Ok(Value::Null);
        }

        let sum: f64 = self.x_values.iter().sum();
        let avg = sum / self.x_values.len() as f64;
        Ok(Value::Float64(avg))
    }

    fn reset(&mut self) {
        self.x_values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug)]
pub struct RegrAvgXFunction;

impl AggregateFunction for RegrAvgXFunction {
    fn name(&self) -> &str {
        "REGR_AVGX"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Float64, DataType::Float64]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(RegrAvgXAccumulator::default())
    }
}

/// REGR_AVGY - Average of the dependent variable (y)
#[derive(Debug, Clone, Default)]
pub struct RegrAvgYAccumulator {
    y_values: Vec<f64>,
}

impl Accumulator for RegrAvgYAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                if let Some(y) = numeric_value_to_f64(&arr[0])? {
                    self.y_values.push(y);
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, other: &dyn Accumulator) -> Result<()> {
        if let Some(other_acc) = other.as_any().downcast_ref::<RegrAvgYAccumulator>() {
            self.y_values.extend(&other_acc.y_values);
            Ok(())
        } else {
            Err(Error::InternalError(
                "Cannot merge different accumulator types".to_string(),
            ))
        }
    }

    fn finalize(&self) -> Result<Value> {
        if self.y_values.is_empty() {
            return Ok(Value::Null);
        }

        let sum: f64 = self.y_values.iter().sum();
        let avg = sum / self.y_values.len() as f64;
        Ok(Value::Float64(avg))
    }

    fn reset(&mut self) {
        self.y_values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug)]
pub struct RegrAvgYFunction;

impl AggregateFunction for RegrAvgYFunction {
    fn name(&self) -> &str {
        "REGR_AVGY"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Float64, DataType::Float64]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(RegrAvgYAccumulator::default())
    }
}

/// REGR_COUNT - Number of non-null pairs
#[derive(Debug, Clone, Default)]
pub struct RegrCountAccumulator {
    count: i64,
}

impl Accumulator for RegrCountAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 && !arr[0].is_null() && !arr[1].is_null() {
                self.count += 1;
            }
        }
        Ok(())
    }

    fn merge(&mut self, other: &dyn Accumulator) -> Result<()> {
        if let Some(other_acc) = other.as_any().downcast_ref::<RegrCountAccumulator>() {
            self.count += other_acc.count;
            Ok(())
        } else {
            Err(Error::InternalError(
                "Cannot merge different accumulator types".to_string(),
            ))
        }
    }

    fn finalize(&self) -> Result<Value> {
        Ok(Value::Int64(self.count))
    }

    fn reset(&mut self) {
        self.count = 0;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug)]
pub struct RegrCountFunction;

impl AggregateFunction for RegrCountFunction {
    fn name(&self) -> &str {
        "REGR_COUNT"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Float64, DataType::Float64]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Int64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(RegrCountAccumulator::default())
    }
}

/// REGR_SXX - Sum of squares of the independent variable
#[derive(Debug, Clone, Default)]
pub struct RegrSxxAccumulator {
    x_values: Vec<f64>,
}

impl Accumulator for RegrSxxAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                if let Some(x) = numeric_value_to_f64(&arr[1])? {
                    self.x_values.push(x);
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, other: &dyn Accumulator) -> Result<()> {
        if let Some(other_acc) = other.as_any().downcast_ref::<RegrSxxAccumulator>() {
            self.x_values.extend(&other_acc.x_values);
            Ok(())
        } else {
            Err(Error::InternalError(
                "Cannot merge different accumulator types".to_string(),
            ))
        }
    }

    fn finalize(&self) -> Result<Value> {
        if self.x_values.is_empty() {
            return Ok(Value::Null);
        }

        let mean = self.x_values.iter().sum::<f64>() / self.x_values.len() as f64;
        let sxx: f64 = self.x_values.iter().map(|x| (x - mean).powi(2)).sum();
        Ok(Value::Float64(sxx))
    }

    fn reset(&mut self) {
        self.x_values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug)]
pub struct RegrSxxFunction;

impl AggregateFunction for RegrSxxFunction {
    fn name(&self) -> &str {
        "REGR_SXX"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Float64, DataType::Float64]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(RegrSxxAccumulator::default())
    }
}

/// REGR_SYY - Sum of squares of the dependent variable
#[derive(Debug, Clone, Default)]
pub struct RegrSyyAccumulator {
    y_values: Vec<f64>,
}

impl Accumulator for RegrSyyAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                if let Some(y) = numeric_value_to_f64(&arr[0])? {
                    self.y_values.push(y);
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, other: &dyn Accumulator) -> Result<()> {
        if let Some(other_acc) = other.as_any().downcast_ref::<RegrSyyAccumulator>() {
            self.y_values.extend(&other_acc.y_values);
            Ok(())
        } else {
            Err(Error::InternalError(
                "Cannot merge different accumulator types".to_string(),
            ))
        }
    }

    fn finalize(&self) -> Result<Value> {
        if self.y_values.is_empty() {
            return Ok(Value::Null);
        }

        let mean = self.y_values.iter().sum::<f64>() / self.y_values.len() as f64;
        let syy: f64 = self.y_values.iter().map(|y| (y - mean).powi(2)).sum();
        Ok(Value::Float64(syy))
    }

    fn reset(&mut self) {
        self.y_values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug)]
pub struct RegrSyyFunction;

impl AggregateFunction for RegrSyyFunction {
    fn name(&self) -> &str {
        "REGR_SYY"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Float64, DataType::Float64]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(RegrSyyAccumulator::default())
    }
}

/// REGR_SXY - Sum of products of deviations
#[derive(Debug, Clone, Default)]
pub struct RegrSxyAccumulator {
    pairs: Vec<(f64, f64)>,
}

impl Accumulator for RegrSxyAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Value::Array(arr) = value {
            if arr.len() == 2 {
                if let (Some(y), Some(x)) = (
                    numeric_value_to_f64(&arr[0])?,
                    numeric_value_to_f64(&arr[1])?,
                ) {
                    self.pairs.push((x, y));
                }
            }
        }
        Ok(())
    }

    fn merge(&mut self, other: &dyn Accumulator) -> Result<()> {
        if let Some(other_acc) = other.as_any().downcast_ref::<RegrSxyAccumulator>() {
            self.pairs.extend(&other_acc.pairs);
            Ok(())
        } else {
            Err(Error::InternalError(
                "Cannot merge different accumulator types".to_string(),
            ))
        }
    }

    fn finalize(&self) -> Result<Value> {
        if self.pairs.is_empty() {
            return Ok(Value::Null);
        }

        let n = self.pairs.len() as f64;
        let mean_x = self.pairs.iter().map(|(x, _)| x).sum::<f64>() / n;
        let mean_y = self.pairs.iter().map(|(_, y)| y).sum::<f64>() / n;

        let sxy: f64 = self
            .pairs
            .iter()
            .map(|(x, y)| (x - mean_x) * (y - mean_y))
            .sum();

        Ok(Value::Float64(sxy))
    }

    fn reset(&mut self) {
        self.pairs.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug)]
pub struct RegrSxyFunction;

impl AggregateFunction for RegrSxyFunction {
    fn name(&self) -> &str {
        "REGR_SXY"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Float64, DataType::Float64]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(RegrSxyAccumulator::default())
    }
}

/// MODE - Most frequently occurring value (PostgreSQL version)
#[derive(Debug, Clone, Default)]
pub struct ModeAccumulator {
    value_counts: HashMap<String, i64>,
}

impl Accumulator for ModeAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if !value.is_null() {
            let key = format!("{:?}", value);
            *self.value_counts.entry(key).or_insert(0) += 1;
        }
        Ok(())
    }

    fn merge(&mut self, other: &dyn Accumulator) -> Result<()> {
        if let Some(other_acc) = other.as_any().downcast_ref::<ModeAccumulator>() {
            for (key, count) in &other_acc.value_counts {
                *self.value_counts.entry(key.clone()).or_insert(0) += count;
            }
            Ok(())
        } else {
            Err(Error::InternalError(
                "Cannot merge different accumulator types".to_string(),
            ))
        }
    }

    fn finalize(&self) -> Result<Value> {
        if self.value_counts.is_empty() {
            return Ok(Value::Null);
        }

        let max_count = *self.value_counts.values().max().unwrap();
        let mode_key = self
            .value_counts
            .iter()
            .find(|(_, count)| **count == max_count)
            .map(|(key, _)| key)
            .unwrap();

        Ok(Value::String(mode_key.clone()))
    }

    fn reset(&mut self) {
        self.value_counts.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug)]
pub struct ModeFunction;

impl AggregateFunction for ModeFunction {
    fn name(&self) -> &str {
        "MODE"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::String)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(ModeAccumulator::default())
    }
}

/// PERCENTILE_CONT - Continuous percentile (interpolated)
#[derive(Debug, Clone)]
pub struct PercentileContAccumulator {
    values: Vec<f64>,
    percentile: f64,
}

impl Default for PercentileContAccumulator {
    fn default() -> Self {
        Self {
            values: Vec::new(),
            percentile: 0.5,
        }
    }
}

impl PercentileContAccumulator {
    pub fn new(percentile: f64) -> Self {
        Self {
            values: Vec::new(),
            percentile,
        }
    }
}

impl Accumulator for PercentileContAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(val) = numeric_value_to_f64(value)? {
            self.values.push(val);
        }
        Ok(())
    }

    fn merge(&mut self, other: &dyn Accumulator) -> Result<()> {
        if let Some(other_acc) = other.as_any().downcast_ref::<PercentileContAccumulator>() {
            self.values.extend(&other_acc.values);
            Ok(())
        } else {
            Err(Error::InternalError(
                "Cannot merge different accumulator types".to_string(),
            ))
        }
    }

    fn finalize(&self) -> Result<Value> {
        if self.values.is_empty() {
            return Ok(Value::Null);
        }

        let mut sorted = self.values.clone();
        sorted.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));

        let position = self.percentile * (sorted.len() - 1) as f64;
        let lower_idx = position.floor() as usize;
        let upper_idx = position.ceil() as usize;
        let fraction = position - position.floor();

        let result = if lower_idx == upper_idx {
            sorted[lower_idx]
        } else {
            sorted[lower_idx] * (1.0 - fraction) + sorted[upper_idx] * fraction
        };

        Ok(Value::Float64(result))
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug)]
pub struct PercentileContFunction {
    percentile: f64,
}

impl Default for PercentileContFunction {
    fn default() -> Self {
        Self { percentile: 0.5 }
    }
}

impl PercentileContFunction {
    pub fn new(percentile: f64) -> Self {
        Self { percentile }
    }
}

impl AggregateFunction for PercentileContFunction {
    fn name(&self) -> &str {
        "PERCENTILE_CONT"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Float64]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(PercentileContAccumulator::new(self.percentile))
    }
}

/// PERCENTILE_DISC - Discrete percentile (nearest value)
#[derive(Debug, Clone)]
pub struct PercentileDiscAccumulator {
    values: Vec<f64>,
    percentile: f64,
}

impl Default for PercentileDiscAccumulator {
    fn default() -> Self {
        Self {
            values: Vec::new(),
            percentile: 0.5,
        }
    }
}

impl PercentileDiscAccumulator {
    pub fn new(percentile: f64) -> Self {
        Self {
            values: Vec::new(),
            percentile,
        }
    }
}

impl Accumulator for PercentileDiscAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if let Some(val) = numeric_value_to_f64(value)? {
            self.values.push(val);
        }
        Ok(())
    }

    fn merge(&mut self, other: &dyn Accumulator) -> Result<()> {
        if let Some(other_acc) = other.as_any().downcast_ref::<PercentileDiscAccumulator>() {
            self.values.extend(&other_acc.values);
            Ok(())
        } else {
            Err(Error::InternalError(
                "Cannot merge different accumulator types".to_string(),
            ))
        }
    }

    fn finalize(&self) -> Result<Value> {
        if self.values.is_empty() {
            return Ok(Value::Null);
        }

        let mut sorted = self.values.clone();
        sorted.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));

        let position = (self.percentile * (sorted.len() - 1) as f64).round() as usize;
        Ok(Value::Float64(sorted[position]))
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug)]
pub struct PercentileDiscFunction {
    percentile: f64,
}

impl Default for PercentileDiscFunction {
    fn default() -> Self {
        Self { percentile: 0.5 }
    }
}

impl PercentileDiscFunction {
    pub fn new(percentile: f64) -> Self {
        Self { percentile }
    }
}

impl AggregateFunction for PercentileDiscFunction {
    fn name(&self) -> &str {
        "PERCENTILE_DISC"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Float64]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Float64)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(PercentileDiscAccumulator::new(self.percentile))
    }
}

/// FIRST_VALUE - Return the first value in an ordered set
#[derive(Debug, Clone, Default)]
pub struct FirstValueAccumulator {
    first_value: Option<Value>,
}

impl Accumulator for FirstValueAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if self.first_value.is_none() && !value.is_null() {
            self.first_value = Some(value.clone());
        }
        Ok(())
    }

    fn merge(&mut self, other: &dyn Accumulator) -> Result<()> {
        if let Some(other_acc) = other.as_any().downcast_ref::<FirstValueAccumulator>() {
            if self.first_value.is_none() {
                self.first_value = other_acc.first_value.clone();
            }
            Ok(())
        } else {
            Err(Error::InternalError(
                "Cannot merge different accumulator types".to_string(),
            ))
        }
    }

    fn finalize(&self) -> Result<Value> {
        Ok(self.first_value.clone().unwrap_or(Value::Null))
    }

    fn reset(&mut self) {
        self.first_value = None;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug)]
pub struct FirstValueFunction;

impl AggregateFunction for FirstValueFunction {
    fn name(&self) -> &str {
        "FIRST_VALUE"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Unknown)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(FirstValueAccumulator::default())
    }
}

/// LAST_VALUE - Return the last value in an ordered set
#[derive(Debug, Clone, Default)]
pub struct LastValueAccumulator {
    last_value: Option<Value>,
}

impl Accumulator for LastValueAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if !value.is_null() {
            self.last_value = Some(value.clone());
        }
        Ok(())
    }

    fn merge(&mut self, other: &dyn Accumulator) -> Result<()> {
        if let Some(other_acc) = other.as_any().downcast_ref::<LastValueAccumulator>() {
            if other_acc.last_value.is_some() {
                self.last_value = other_acc.last_value.clone();
            }
            Ok(())
        } else {
            Err(Error::InternalError(
                "Cannot merge different accumulator types".to_string(),
            ))
        }
    }

    fn finalize(&self) -> Result<Value> {
        Ok(self.last_value.clone().unwrap_or(Value::Null))
    }

    fn reset(&mut self) {
        self.last_value = None;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug)]
pub struct LastValueFunction;

impl AggregateFunction for LastValueFunction {
    fn name(&self) -> &str {
        "LAST_VALUE"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Unknown)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(LastValueAccumulator::default())
    }
}

/// NTH_VALUE - Return the nth value in an ordered set
#[derive(Debug, Clone)]
pub struct NthValueAccumulator {
    values: Vec<Value>,
    n: usize,
}

impl Default for NthValueAccumulator {
    fn default() -> Self {
        Self {
            values: Vec::new(),
            n: 1,
        }
    }
}

impl NthValueAccumulator {
    pub fn new(n: usize) -> Self {
        Self {
            values: Vec::new(),
            n,
        }
    }
}

impl Accumulator for NthValueAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        if !value.is_null() {
            self.values.push(value.clone());
        }
        Ok(())
    }

    fn merge(&mut self, other: &dyn Accumulator) -> Result<()> {
        if let Some(other_acc) = other.as_any().downcast_ref::<NthValueAccumulator>() {
            self.values.extend(other_acc.values.clone());
            Ok(())
        } else {
            Err(Error::InternalError(
                "Cannot merge different accumulator types".to_string(),
            ))
        }
    }

    fn finalize(&self) -> Result<Value> {
        if self.n == 0 || self.n > self.values.len() {
            return Ok(Value::Null);
        }
        Ok(self.values[self.n - 1].clone())
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug)]
pub struct NthValueFunction {
    n: usize,
}

impl Default for NthValueFunction {
    fn default() -> Self {
        Self { n: 1 }
    }
}

impl NthValueFunction {
    pub fn new(n: usize) -> Self {
        Self { n }
    }
}

impl AggregateFunction for NthValueFunction {
    fn name(&self) -> &str {
        "NTH_VALUE"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Unknown)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(NthValueAccumulator::new(self.n))
    }
}

/// LAG - Access value from a previous row
#[derive(Debug, Clone)]
pub struct LagAccumulator {
    values: Vec<Value>,
    offset: usize,
    default_value: Value,
}

impl Default for LagAccumulator {
    fn default() -> Self {
        Self {
            values: Vec::new(),
            offset: 1,
            default_value: Value::Null,
        }
    }
}

impl LagAccumulator {
    pub fn new(offset: usize, default_value: Value) -> Self {
        Self {
            values: Vec::new(),
            offset,
            default_value,
        }
    }
}

impl Accumulator for LagAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        self.values.push(value.clone());
        Ok(())
    }

    fn merge(&mut self, other: &dyn Accumulator) -> Result<()> {
        if let Some(other_acc) = other.as_any().downcast_ref::<LagAccumulator>() {
            self.values.extend(other_acc.values.clone());
            Ok(())
        } else {
            Err(Error::InternalError(
                "Cannot merge different accumulator types".to_string(),
            ))
        }
    }

    fn finalize(&self) -> Result<Value> {
        if self.values.len() <= self.offset {
            return Ok(self.default_value.clone());
        }
        let idx = self.values.len() - self.offset - 1;
        Ok(self.values[idx].clone())
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug)]
pub struct LagFunction {
    offset: usize,
    default_value: Value,
}

impl Default for LagFunction {
    fn default() -> Self {
        Self {
            offset: 1,
            default_value: Value::Null,
        }
    }
}

impl LagFunction {
    pub fn new(offset: usize, default_value: Value) -> Self {
        Self {
            offset,
            default_value,
        }
    }
}

impl AggregateFunction for LagFunction {
    fn name(&self) -> &str {
        "LAG"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Unknown)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(LagAccumulator::new(self.offset, self.default_value.clone()))
    }
}

/// LEAD - Access value from a following row
#[derive(Debug, Clone)]
pub struct LeadAccumulator {
    values: Vec<Value>,
    offset: usize,
    default_value: Value,
    current_index: usize,
}

impl Default for LeadAccumulator {
    fn default() -> Self {
        Self {
            values: Vec::new(),
            offset: 1,
            default_value: Value::Null,
            current_index: 0,
        }
    }
}

impl LeadAccumulator {
    pub fn new(offset: usize, default_value: Value) -> Self {
        Self {
            values: Vec::new(),
            offset,
            default_value,
            current_index: 0,
        }
    }
}

impl Accumulator for LeadAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        self.values.push(value.clone());
        Ok(())
    }

    fn merge(&mut self, other: &dyn Accumulator) -> Result<()> {
        if let Some(other_acc) = other.as_any().downcast_ref::<LeadAccumulator>() {
            self.values.extend(other_acc.values.clone());
            Ok(())
        } else {
            Err(Error::InternalError(
                "Cannot merge different accumulator types".to_string(),
            ))
        }
    }

    fn finalize(&self) -> Result<Value> {
        let target_idx = self.current_index + self.offset;
        if target_idx >= self.values.len() {
            return Ok(self.default_value.clone());
        }
        Ok(self.values[target_idx].clone())
    }

    fn reset(&mut self) {
        self.values.clear();
        self.current_index = 0;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

#[derive(Debug)]
pub struct LeadFunction {
    offset: usize,
    default_value: Value,
}

impl Default for LeadFunction {
    fn default() -> Self {
        Self {
            offset: 1,
            default_value: Value::Null,
        }
    }
}

impl LeadFunction {
    pub fn new(offset: usize, default_value: Value) -> Self {
        Self {
            offset,
            default_value,
        }
    }
}

impl AggregateFunction for LeadFunction {
    fn name(&self) -> &str {
        "LEAD"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::Unknown)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(LeadAccumulator::new(self.offset, self.default_value.clone()))
    }
}
