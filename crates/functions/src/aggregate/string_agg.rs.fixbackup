//! LISTAGG aggregate function implementation (SQL:2023 F562)
//!
//! LISTAGG concatenates strings from multiple rows into a single string,
//! with optional ordering and overflow handling.
//!
//! **SQL:2023 Standard Reference:** ISO/IEC 9075-2:2023 Section 10.9
//! **Feature ID:** F562 (Enhanced grouping operations)
//!
//! ## Syntax
//!
//! ```sql
//! LISTAGG(expression [, separator])
//!   [WITHIN GROUP (ORDER BY sort_expression [ASC|DESC])]
//!   [ON OVERFLOW TRUNCATE [truncation_literal] [WITH|WITHOUT COUNT]]
//! ```
//!
//! ## Features
//!
//! - Basic concatenation with default (empty) or custom delimiter
//! - WITHIN GROUP ordering (handled by executor, not accumulator)
//! - ON OVERFLOW TRUNCATE with truncation indicators
//! - WITH COUNT / WITHOUT COUNT options
//! - NULL value skipping (standard behavior)
//! - Window function variant support
//!
//! ## Implementation Notes
//!
//! - NULL values are skipped (not included in concatenation)
//! - Empty result set or all-NULL values return NULL
//! - Default delimiter is empty string ("")
//! - Maximum output length can be configured (default: 1MB)
//! - Overflow handling uses "..." as default truncation indicator

use super::{Accumulator, AggregateFunction};
use core::error::{Error, Result};
use core::types::{DataType, Value};

/// Default maximum output length (1 MB)
const DEFAULT_MAX_LENGTH: usize = 1_048_576;

/// Configuration for LISTAGG overflow behavior
#[derive(Debug, Clone)]
pub enum OverflowBehavior {
    None,
    TruncateWithoutCount(String),
    TruncateWithCount(String),
}

/// Accumulator for LISTAGG aggregate function
#[derive(Debug, Clone)]
pub struct ListAggAccumulator {
    values: Vec<String>,
    delimiter: String,
    max_length: usize,
    overflow_behavior: OverflowBehavior,
}

impl ListAggAccumulator {
    /// Create a new LISTAGG accumulator with default delimiter (empty string)
    pub fn new() -> Self {
        Self {
            values: Vec::new(),
            delimiter: String::new(),
            max_length: DEFAULT_MAX_LENGTH,
            overflow_behavior: OverflowBehavior::None,
        }
    }

    /// Create accumulator with custom delimiter
    pub fn with_delimiter(delimiter: String) -> Self {
        Self {
            values: Vec::new(),
            delimiter,
            max_length: DEFAULT_MAX_LENGTH,
            overflow_behavior: OverflowBehavior::None,
        }
    }

    /// Set maximum output length
    pub fn with_max_length(mut self, max_length: usize) -> Self {
        self.max_length = max_length;
        self
    }

    /// Set overflow behavior
    pub fn with_overflow_behavior(mut self, behavior: OverflowBehavior) -> Self {
        self.overflow_behavior = behavior;
        self
    }

    /// Concatenate values with delimiter, respecting max length and overflow behavior
    fn concatenate_with_overflow(&self) -> String {
        if self.values.is_empty() {
            return String::new();
        }

        // Fast path: single value
        if self.values.len() == 1 {
            let value = &self.values[0];
            return self.apply_overflow_truncation(value, 0);
        }

        // Build result string with delimiter
        let mut result = String::new();
        let delimiter_len = self.delimiter.len();

        for (idx, value) in self.values.iter().enumerate() {
            if idx > 0 {
                // Check if adding delimiter would exceed max length
                if result.len() + delimiter_len > self.max_length {
                    return self.finalize_with_overflow(result, idx);
                }
                result.push_str(&self.delimiter);
            }

            // Check if adding this value would exceed max length
            if result.len() + value.len() > self.max_length {
                return self.finalize_with_overflow(result, idx);
            }

            result.push_str(value);
        }

        result
    }

    /// Apply overflow truncation to a single value
    fn apply_overflow_truncation(&self, value: &str, _truncated_count: usize) -> String {
        if value.len() <= self.max_length {
            return value.to_string();
        }

        match &self.overflow_behavior {
            OverflowBehavior::None => value.to_string(),
            OverflowBehavior::TruncateWithoutCount(indicator) => {
                let indicator_len = indicator.len();
                if self.max_length > indicator_len {
                    let keep_len = self.max_length - indicator_len;
                    format!("{}{}", &value[..keep_len], indicator)
                } else {
                    indicator.clone()
                }
            }
            OverflowBehavior::TruncateWithCount(indicator) => {
                // For single value, count is always 1
                let suffix = format!("{} (1)", indicator);
                let suffix_len = suffix.len();
                if self.max_length > suffix_len {
                    let keep_len = self.max_length - suffix_len;
                    format!("{}{}", &value[..keep_len], suffix)
                } else {
                    suffix
                }
            }
        }
    }

    /// Finalize result with overflow handling
    fn finalize_with_overflow(&self, partial_result: String, truncated_from_idx: usize) -> String {
        let truncated_count = self.values.len() - truncated_from_idx;

        match &self.overflow_behavior {
            OverflowBehavior::None => partial_result,
            OverflowBehavior::TruncateWithoutCount(indicator) => {
                format!("{}{}", partial_result, indicator)
            }
            OverflowBehavior::TruncateWithCount(indicator) => {
                format!("{}{} ({})", partial_result, indicator, truncated_count)
            }
        }
    }
}

impl Default for ListAggAccumulator {
    fn default() -> Self {
        Self::new()
    }
}

impl Accumulator for ListAggAccumulator {
    fn accumulate(&mut self, value: &Value) -> Result<()> {
        // Skip NULL values (standard SQL behavior)
        if value.is_null() {
            return Ok(());
        }

        // Convert value to string using accessor methods
        let string_value = if let Some(s) = value.as_str() {
            s.to_string()
        } else if let Some(i) = value.as_i64() {
            i.to_string()
        } else if let Some(f) = value.as_f64() {
            f.to_string()
        } else if let Some(b) = value.as_bool() {
            b.to_string()
        } else if let Some(d) = value.as_numeric() {
            d.to_string()
        } else if let Some(d) = value.as_date() {
            d.to_string()
        } else if let Some(dt) = value.as_datetime() {
            dt.to_string()
        } else if let Some(t) = value.as_time() {
            t.to_string()
        } else if let Some(ts) = value.as_timestamp() {
            ts.to_string()
        } else {
            // Try UUID via match on heap type
            match value {
                Value::Uuid(u) => u.to_string(),
                _ => return Err(Error::type_mismatch_value("STRING or scalar type", value)),
            }
        };

        self.values.push(string_value);
        Ok(())
    }

    fn merge(&mut self, other: &dyn Accumulator) -> Result<()> {
        // Downcast other accumulator to ListAggAccumulator
        let other = other
            .as_any()
            .downcast_ref::<ListAggAccumulator>()
            .ok_or_else(|| {
                Error::internal("Cannot merge LISTAGG accumulator with different type")
            })?;

        // Merge values from other accumulator
        self.values.extend_from_slice(&other.values);
        Ok(())
    }

    fn finalize(&self) -> Result<Value> {
        // If no non-NULL values accumulated, return NULL
        if self.values.is_empty() {
            return Ok(Value::Null);
        }

        // Concatenate with overflow handling
        let result = self.concatenate_with_overflow();
        Ok(Value::String(result))
    }

    fn reset(&mut self) {
        self.values.clear();
    }

    /// Helper for downcasting in merge
    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

/// LISTAGG aggregate function
#[derive(Debug)]
pub struct ListAggFunction {
    delimiter: Option<String>,
    max_length: usize,
    overflow_behavior: OverflowBehavior,
}

impl ListAggFunction {
    /// Create LISTAGG function with default delimiter
    pub fn new() -> Self {
        Self {
            delimiter: None,
            max_length: DEFAULT_MAX_LENGTH,
            overflow_behavior: OverflowBehavior::None,
        }
    }

    /// Create LISTAGG function with custom delimiter
    pub fn with_delimiter(delimiter: String) -> Self {
        Self {
            delimiter: Some(delimiter),
            max_length: DEFAULT_MAX_LENGTH,
            overflow_behavior: OverflowBehavior::None,
        }
    }

    /// Set maximum output length
    pub fn with_max_length(mut self, max_length: usize) -> Self {
        self.max_length = max_length;
        self
    }

    /// Set overflow behavior
    pub fn with_overflow_behavior(mut self, behavior: OverflowBehavior) -> Self {
        self.overflow_behavior = behavior;
        self
    }
}

impl Default for ListAggFunction {
    fn default() -> Self {
        Self::new()
    }
}

impl AggregateFunction for ListAggFunction {
    fn name(&self) -> &str {
        "LISTAGG"
    }

    fn arg_types(&self) -> &[DataType] {
        // LISTAGG accepts any scalar type
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::String)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        let mut acc = match &self.delimiter {
            Some(delim) => ListAggAccumulator::with_delimiter(delim.clone()),
            None => ListAggAccumulator::new(),
        };

        acc = acc
            .with_max_length(self.max_length)
            .with_overflow_behavior(self.overflow_behavior.clone());

        Box::new(acc)
    }
}

// === STRING_AGG Function (PostgreSQL/BigQuery compatible) ==================== //

/// STRING_AGG aggregate function - PostgreSQL and BigQuery compatible string aggregation
///
/// Simpler syntax than LISTAGG, commonly used in PostgreSQL and BigQuery:
/// STRING_AGG(expression, delimiter)
#[derive(Debug, Clone)]
pub struct StringAggFunction {
    delimiter: String,
}

impl StringAggFunction {
    /// Create STRING_AGG function with specified delimiter
    pub fn new(delimiter: String) -> Self {
        Self { delimiter }
    }
}

impl Default for StringAggFunction {
    fn default() -> Self {
        Self::new(",".to_string())
    }
}

impl AggregateFunction for StringAggFunction {
    fn name(&self) -> &str {
        "STRING_AGG"
    }

    fn arg_types(&self) -> &[DataType] {
        &[DataType::Unknown]
    }

    fn return_type(&self, _arg_types: &[DataType]) -> Result<DataType> {
        Ok(DataType::String)
    }

    fn create_accumulator(&self) -> Box<dyn Accumulator> {
        Box::new(ListAggAccumulator::with_delimiter(self.delimiter.clone()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_listagg_basic_empty() {
        let mut acc = ListAggAccumulator::new();
        assert_eq!(acc.finalize().unwrap(), Value::Null);
    }

    #[test]
    fn test_listagg_single_value() {
        let mut acc = ListAggAccumulator::new();
        acc.accumulate(&Value::String("Alice".to_string())).unwrap();
        assert_eq!(acc.finalize().unwrap(), Value::String("Alice".to_string()));
    }

    #[test]
    fn test_listagg_multiple_values_no_delimiter() {
        let mut acc = ListAggAccumulator::new();
        acc.accumulate(&Value::String("Alice".to_string())).unwrap();
        acc.accumulate(&Value::String("Bob".to_string())).unwrap();
        acc.accumulate(&Value::String("Charlie".to_string()))
            .unwrap();
        assert_eq!(
            acc.finalize().unwrap(),
            Value::String("AliceBobCharlie".to_string())
        );
    }

    #[test]
    fn test_listagg_with_delimiter() {
        let mut acc = ListAggAccumulator::with_delimiter(", ".to_string());
        acc.accumulate(&Value::String("Alice".to_string())).unwrap();
        acc.accumulate(&Value::String("Bob".to_string())).unwrap();
        acc.accumulate(&Value::String("Charlie".to_string()))
            .unwrap();
        assert_eq!(
            acc.finalize().unwrap(),
            Value::String("Alice, Bob, Charlie".to_string())
        );
    }

    #[test]
    fn test_listagg_skips_nulls() {
        let mut acc = ListAggAccumulator::with_delimiter(", ".to_string());
        acc.accumulate(&Value::String("Alice".to_string())).unwrap();
        acc.accumulate(&Value::Null).unwrap();
        acc.accumulate(&Value::String("Bob".to_string())).unwrap();
        acc.accumulate(&Value::Null).unwrap();
        acc.accumulate(&Value::String("Charlie".to_string()))
            .unwrap();
        assert_eq!(
            acc.finalize().unwrap(),
            Value::String("Alice, Bob, Charlie".to_string())
        );
    }

    #[test]
    fn test_listagg_all_nulls_returns_null() {
        let mut acc = ListAggAccumulator::new();
        acc.accumulate(&Value::Null).unwrap();
        acc.accumulate(&Value::Null).unwrap();
        acc.accumulate(&Value::Null).unwrap();
        assert_eq!(acc.finalize().unwrap(), Value::Null);
    }

    #[test]
    fn test_listagg_numeric_values() {
        let mut acc = ListAggAccumulator::with_delimiter(", ".to_string());
        acc.accumulate(&Value::Int64(10)).unwrap();
        acc.accumulate(&Value::Int64(20)).unwrap();
        acc.accumulate(&Value::Int64(30)).unwrap();
        assert_eq!(
            acc.finalize().unwrap(),
            Value::String("10, 20, 30".to_string())
        );
    }

    #[test]
    fn test_listagg_overflow_truncate_without_count() {
        let mut acc = ListAggAccumulator::with_delimiter(", ".to_string())
            .with_max_length(20)
            .with_overflow_behavior(OverflowBehavior::TruncateWithoutCount("...".to_string()));

        acc.accumulate(&Value::String("Alice".to_string())).unwrap();
        acc.accumulate(&Value::String("Bob".to_string())).unwrap();
        acc.accumulate(&Value::String("Charlie".to_string()))
            .unwrap();
        acc.accumulate(&Value::String("Diana".to_string())).unwrap();

        let result = acc.finalize().unwrap();
        if let Value::String(s) = result {
            assert!(s.len() <= 20);
            assert!(s.ends_with("..."));
            assert!(s.starts_with("Alice, Bob"));
        } else {
            panic!("Expected string result");
        }
    }

    #[test]
    fn test_listagg_overflow_truncate_with_count() {
        let mut acc = ListAggAccumulator::with_delimiter(", ".to_string())
            .with_max_length(25)
            .with_overflow_behavior(OverflowBehavior::TruncateWithCount("...".to_string()));

        acc.accumulate(&Value::String("Alice".to_string())).unwrap();
        acc.accumulate(&Value::String("Bob".to_string())).unwrap();
        acc.accumulate(&Value::String("Charlie".to_string()))
            .unwrap();
        acc.accumulate(&Value::String("Diana".to_string())).unwrap();

        let result = acc.finalize().unwrap();
        if let Value::String(s) = result {
            assert!(s.contains("..."));
            // Should have count of truncated items
            assert!(s.contains('(') && s.contains(')'));
        } else {
            panic!("Expected string result");
        }
    }
}
